diff --git a/Makefile.am b/Makefile.am
deleted file mode 100644
index e00379078..000000000
--- a/Makefile.am
+++ /dev/null
@@ -1,221 +0,0 @@
-AUTOMAKE_OPTIONS=nostdinc
-
-# Required for automake < 1.14
-ACLOCAL_AMFLAGS = -I m4
-
-if COMPOSITE
-COMPOSITE_DIR=composite
-endif
-
-if GLX
-GLX_DIR=glx
-endif
-
-if DBE
-DBE_DIR=dbe
-endif
-
-if RECORD
-RECORD_DIR=record
-endif
-
-if DRI3
-DRI3_DIR=dri3
-endif
-
-if PRESENT
-PRESENT_DIR=present
-endif
-
-if PSEUDORAMIX
-PSEUDORAMIX_DIR=pseudoramiX
-endif
-
-if GLAMOR
-GLAMOR_DIR=glamor
-endif
-
-SUBDIRS = \
-	doc \
-	man \
-	include \
-	dix  \
-	fb \
-	mi \
-	Xext \
-	miext \
-	os \
-	randr \
-	render  \
-	Xi \
-	xkb \
-	$(PSEUDORAMIX_DIR) \
-	$(DBE_DIR) \
-	$(RECORD_DIR) \
-	xfixes \
-	damageext \
-	$(COMPOSITE_DIR) \
-	$(GLX_DIR) \
-	$(PRESENT_DIR) \
-	$(DRI3_DIR) \
-	exa \
-	$(GLAMOR_DIR) \
-	config \
-	hw \
-	test
-
-if XORG
-aclocaldir = $(datadir)/aclocal
-aclocal_DATA = xorg-server.m4
-
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = xorg-server.pc
-endif
-
-EXTRA_DIST = xorg-server.pc.in xorg-server.m4 autogen.sh README.md
-
-DISTCHECK_CONFIGURE_FLAGS=\
-	--with-xkb-path=$(XKB_BASE_DIRECTORY) \
-	--with-xkb-bin-directory=$(XKB_BIN_DIRECTORY) \
-	--with-xkb-output='$${datadir}/X11/xkb/compiled'
-
-.PHONY: ChangeLog INSTALL
-
-INSTALL:
-	$(INSTALL_CMD)
-
-ChangeLog:
-	$(CHANGELOG_CMD)
-
-dist-hook: ChangeLog INSTALL
-
-DIST_SUBDIRS = \
-	doc \
-	man \
-	include \
-	dix  \
-	fb \
-	mi \
-	Xext \
-	miext \
-	os \
-	pseudoramiX \
-	randr \
-	render  \
-	Xi \
-	xkb \
-	dbe \
-	record \
-	xfixes \
-	damageext \
-	composite \
-	glx \
-	exa \
-	glamor \
-	config \
-	dri3 \
-	present \
-	hw \
-	test
-
-# gross hack
-relink: all
-	$(AM_V_at)$(MAKE) -C hw relink
-
-install-headers: Makefile
-	+find . -name Makefile | while read m; do			\
-		if grep -q install-sdkHEADERS $$m; then			\
-			(cd `dirname "$$m"` && make install-sdkHEADERS)	\
-		fi							\
-	done
-
-distcheck-hook:
-	cd $(srcdir) && \
-	meson setup _distcheck_build && \
-	meson configure _distcheck_build && \
-	ninja -C _distcheck_build && \
-	rm -rf _distcheck_build && \
-	cd -
-
-EXTRA_DIST += \
-	meson_options.txt \
-	include/xorg-config.h.meson.in \
-	include/xwin-config.h.meson.in \
-	hw/xfree86/loader/symbol-test.c \
-	composite/meson.build \
-	config/meson.build \
-	damageext/meson.build \
-	dbe/meson.build \
-	dix/meson.build \
-	doc/dtrace/meson.build \
-	doc/meson.build \
-	dri3/meson.build \
-	exa/meson.build \
-	fb/meson.build \
-	glamor/meson.build \
-	glx/meson.build \
-	hw/kdrive/ephyr/meson.build \
-	hw/kdrive/meson.build \
-	hw/kdrive/src/meson.build \
-	hw/meson.build \
-	hw/vfb/meson.build \
-	hw/xfree86/common/meson.build \
-	hw/xfree86/ddc/meson.build \
-	hw/xfree86/dixmods/meson.build \
-	hw/xfree86/doc/meson.build \
-	hw/xfree86/dri2/meson.build \
-	hw/xfree86/dri/meson.build \
-	hw/xfree86/drivers/inputtest/meson.build \
-	hw/xfree86/drivers/modesetting/meson.build \
-	hw/xfree86/exa/meson.build \
-	hw/xfree86/fbdevhw/meson.build \
-	hw/xfree86/glamor_egl/meson.build \
-	hw/xfree86/i2c/meson.build \
-	hw/xfree86/int10/meson.build \
-	hw/xfree86/loader/meson.build \
-	hw/xfree86/meson.build \
-	hw/xfree86/modes/meson.build \
-	hw/xfree86/os-support/meson.build \
-	hw/xfree86/parser/meson.build \
-	hw/xfree86/ramdac/meson.build \
-	hw/xfree86/shadowfb/meson.build \
-	hw/xfree86/vgahw/meson.build \
-	hw/xfree86/x86emu/meson.build \
-	hw/xfree86/xkb/meson.build \
-	hw/xnest/meson.build \
-	hw/xquartz/bundle/meson.build \
-	hw/xquartz/GL/meson.build \
-	hw/xquartz/mach-startup/meson.build \
-	hw/xquartz/meson.build \
-	hw/xquartz/pbproxy/meson.build \
-	hw/xquartz/xpr/meson.build \
-	hw/xwin/dri/meson.build \
-	hw/xwin/glx/meson.build \
-	hw/xwin/meson.build \
-	hw/xwin/winclipboard/meson.build \
-	include/meson.build \
-	meson.build \
-	miext/damage/meson.build \
-	miext/rootless/meson.build \
-	miext/shadow/meson.build \
-	miext/sync/meson.build \
-	mi/meson.build \
-	os/meson.build \
-	present/meson.build \
-	pseudoramiX/meson.build \
-	randr/meson.build \
-	record/meson.build \
-	render/meson.build \
-	test/bigreq/meson.build \
-	test/bigreq/request-length.c \
-	test/damage/meson.build \
-	test/damage/primitives.c \
-	test/meson.build \
-	test/sync/meson.build \
-	test/sync/sync.c \
-	Xext/meson.build \
-	xfixes/meson.build \
-	Xi/meson.build \
-	xkb/meson.build
-
-DISTCLEANFILES = buildDateTime.h
diff --git a/Xext/Makefile.am b/Xext/Makefile.am
deleted file mode 100644
index f15a15a3e..000000000
--- a/Xext/Makefile.am
+++ /dev/null
@@ -1,120 +0,0 @@
-noinst_LTLIBRARIES = libXext.la libXvidmode.la libhashtable.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-if XORG
-sdk_HEADERS = xvdix.h xvmcext.h geext.h geint.h shmint.h syncsdk.h
-endif
-
-# Sources always included in libXextbuiltin.la, libXext.la
-BUILTIN_SRCS =			\
-	bigreq.c		\
-        geext.c			\
-	shape.c			\
-	sleepuntil.c		\
-	sleepuntil.h		\
-	sync.c			\
-	syncsdk.h		\
-	syncsrv.h		\
-	xcmisc.c		\
-	xtest.c
-BUILTIN_LIBS =
-
-# Optional sources included if extension enabled by configure.ac rules
-
-# MIT Shared Memory extension
-MITSHM_SRCS = shm.c shmint.h
-if MITSHM
-BUILTIN_SRCS += $(MITSHM_SRCS)
-endif
-
-# XVideo extension
-XV_SRCS = xvmain.c xvdisp.c xvmc.c xvdix.h xvmcext.h xvdisp.h
-if XV
-BUILTIN_SRCS  += $(XV_SRCS)
-endif
-
-# XResource extension: lets clients get data about per-client resource usage
-RES_SRCS = xres.c
-if RES
-BUILTIN_SRCS  += $(RES_SRCS)
-endif
-
-# MIT ScreenSaver extension
-SCREENSAVER_SRCS = saver.c
-if SCREENSAVER
-BUILTIN_SRCS  += $(SCREENSAVER_SRCS)
-endif
-
-# Xinerama extension: making multiple video devices act as one virtual screen
-XINERAMA_SRCS = panoramiX.c panoramiX.h panoramiXh.h panoramiXsrv.h panoramiXprocs.c panoramiXSwap.c 
-if XINERAMA
-BUILTIN_SRCS += $(XINERAMA_SRCS)
-if XORG
-sdk_HEADERS += panoramiXsrv.h panoramiX.h
-endif
-endif
-
-# X-ACE extension: provides hooks for building security policy extensions
-# like XC-Security, X-SELinux & XTSol
-XACE_SRCS = xace.c xace.h xacestr.h
-if XACE
-BUILTIN_SRCS += $(XACE_SRCS)
-if XORG
-sdk_HEADERS += xace.h xacestr.h
-endif
-endif
-
-# SELinux extension: provides SELinux policy support for X objects
-# requires X-ACE extension
-XSELINUX_SRCS = xselinux_ext.c xselinux_hooks.c xselinux_label.c xselinux.h xselinuxint.h
-if XSELINUX
-BUILTIN_SRCS += $(XSELINUX_SRCS)
-BUILTIN_LIBS += $(SELINUX_LIBS)
-endif
-
-# Security extension: multi-level security to protect clients from each other
-XCSECURITY_SRCS = security.c securitysrv.h
-if XCSECURITY   
-BUILTIN_SRCS += $(XCSECURITY_SRCS)
-endif
-
-# XF86 Big Font extension
-BIGFONT_SRCS = xf86bigfont.c xf86bigfontsrv.h
-if XF86BIGFONT
-BUILTIN_SRCS += $(BIGFONT_SRCS)
-endif
-
-# DPMS extension
-DPMS_SRCS = dpms.c dpmsproc.h
-if DPMSExtension
-BUILTIN_SRCS += $(DPMS_SRCS)
-endif
-
-# Now take all of the above, mix well, bake for 10 minutes and get libXext*.la
-
-libXext_la_SOURCES =		$(BUILTIN_SRCS)
-libXext_la_LIBADD =		$(BUILTIN_LIBS)
-if RES
-libXext_la_LIBADD += libhashtable.la
-endif
-
-# XVidMode extension
-libXvidmode_la_SOURCES = vidmode.c
-
-#Hashtable
-libhashtable_la_SOURCES = hashtable.c hashtable.h
-
-EXTRA_DIST = \
-	$(MITSHM_SRCS) \
-	$(XV_SRCS) \
-	$(RES_SRCS) \
-	$(SCREENSAVER_SRCS) \
-	$(XACE_SRCS) \
-	$(XCSECURITY_SRCS) \
-	$(XSELINUX_SRCS) \
-	$(XINERAMA_SRCS) \
-	$(BIGFONT_SRCS) \
-	$(DPMS_SRCS) \
-        $(GE_SRCS)
-
diff --git a/Xext/xtest.c b/Xext/xtest.c
index 9b55b20b3..dde5c4cf9 100644
--- a/Xext/xtest.c
+++ b/Xext/xtest.c
@@ -382,7 +382,7 @@ ProcXTestFakeInput(ClientPtr client)
             if ((flags & POINTER_ABSOLUTE) && firstValuator <= 1 && numValuators > 0) {
                 if (firstValuator == 0)
                     valuators[0] += root->drawable.pScreen->x;
-                if (firstValuator < 2 && firstValuator + numValuators > 1)
+                if (firstValuator + numValuators > 1)
                     valuators[1 - firstValuator] += root->drawable.pScreen->y;
             }
         }
diff --git a/Xi/Makefile.am b/Xi/Makefile.am
deleted file mode 100644
index 6c456c4ac..000000000
--- a/Xi/Makefile.am
+++ /dev/null
@@ -1,111 +0,0 @@
-noinst_LTLIBRARIES = libXi.la libXistubs.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-libXi_la_SOURCES =	\
-	allowev.c \
-	allowev.h \
-	chgdctl.c \
-	chgdctl.h \
-	chgfctl.c \
-	chgfctl.h \
-	chgkbd.c \
-	chgkbd.h \
-	chgkmap.c \
-	chgkmap.h \
-	chgprop.c \
-	chgprop.h \
-	chgptr.c \
-	chgptr.h \
-	closedev.c \
-	closedev.h \
-	devbell.c \
-	devbell.h \
-	exevents.c \
-	exglobals.h \
-	extinit.c \
-	getbmap.c \
-	getbmap.h \
-	getdctl.c \
-	getdctl.h \
-	getfctl.c \
-	getfctl.h \
-	getfocus.c \
-	getfocus.h \
-	getkmap.c \
-	getkmap.h \
-	getmmap.c \
-	getmmap.h \
-	getprop.c \
-	getprop.h \
-	getselev.c \
-	getselev.h \
-	getvers.c \
-	getvers.h \
-	grabdev.c \
-	grabdev.h \
-	grabdevb.c \
-	grabdevb.h \
-	grabdevk.c \
-	grabdevk.h \
-	gtmotion.c \
-	gtmotion.h \
-	listdev.c \
-	listdev.h \
-	opendev.c \
-	opendev.h \
-	queryst.c \
-	queryst.h \
-	selectev.c \
-	selectev.h \
-	sendexev.c \
-	sendexev.h \
-	setbmap.c \
-	setbmap.h \
-	setdval.c \
-	setdval.h \
-	setfocus.c \
-	setfocus.h \
-	setmmap.c \
-	setmmap.h \
-	setmode.c \
-	setmode.h \
-	ungrdev.c \
-	ungrdev.h \
-	ungrdevb.c \
-	ungrdevb.h \
-	ungrdevk.c \
-	ungrdevk.h \
-	xiallowev.c \
-	xiallowev.h \
-	xibarriers.c \
-	xibarriers.h \
-	xichangecursor.c \
-	xichangecursor.h \
-	xichangehierarchy.c \
-	xichangehierarchy.h \
-	xigetclientpointer.c \
-	xigetclientpointer.h \
-	xigrabdev.c \
-	xigrabdev.h \
-	xipassivegrab.h \
-	xipassivegrab.c \
-	xiproperty.c \
-	xiproperty.h \
-	xiquerydevice.c \
-	xiquerydevice.h \
-	xiquerypointer.c \
-	xiquerypointer.h \
-	xiqueryversion.c \
-	xiqueryversion.h \
-	xiselectev.c \
-	xiselectev.h \
-	xisetclientpointer.c \
-	xisetclientpointer.h \
-	xisetdevfocus.c \
-	xisetdevfocus.h \
-	xiwarppointer.c \
-	xiwarppointer.h
-
-libXistubs_la_SOURCES =	\
-	stubs.c
diff --git a/autogen.sh b/autogen.sh
deleted file mode 100755
index 4de97bf8e..000000000
--- a/autogen.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#! /bin/sh
-
-srcdir=`dirname "$0"`
-test -z "$srcdir" && srcdir=.
-
-ORIGDIR=`pwd`
-cd "$srcdir"
-
-autoreconf --force -v --install || exit 1
-cd "$ORIGDIR" || exit $?
-
-git config --local --get format.subjectPrefix ||
-    git config --local format.subjectPrefix "PATCH xserver"
-
-if test -z "$NOCONFIGURE"; then
-    exec "$srcdir"/configure "$@"
-fi
diff --git a/composite/Makefile.am b/composite/Makefile.am
deleted file mode 100644
index c2f5123f2..000000000
--- a/composite/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-noinst_LTLIBRARIES = libcomposite.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-if XORG
-sdk_HEADERS = compositeext.h
-endif
-
-libcomposite_la_SOURCES = 	\
-	compalloc.c		\
-	compext.c		\
-	compint.h		\
-	compinit.c		\
-	compoverlay.c		\
-	compwindow.c		
diff --git a/config/10-quirks.conf b/config/10-quirks.conf
index 47907d82d..54dd908a7 100644
--- a/config/10-quirks.conf
+++ b/config/10-quirks.conf
@@ -36,3 +36,13 @@ Section "InputClass"
         MatchDriver "evdev"
         Option "TypeName" "MOUSE"
 EndSection
+
+# https://bugzilla.redhat.com/show_bug.cgi?id=2152414
+# Xorg server does not correctly select the DCP for the display without
+# a quirk on Apple Silicon
+Section "OutputClass"
+        Identifier "appledrm"
+        MatchDriver "apple"
+        Driver "modesetting"
+        Option "PrimaryGPU" "true"
+EndSection
diff --git a/config/Makefile.am b/config/Makefile.am
deleted file mode 100644
index 51aae473e..000000000
--- a/config/Makefile.am
+++ /dev/null
@@ -1,41 +0,0 @@
-AM_CFLAGS = $(DIX_CFLAGS)
-
-noinst_LTLIBRARIES = libconfig.la
-libconfig_la_SOURCES = config.c config-backends.h
-libconfig_la_LIBADD =
-
-if NEED_DBUS
-AM_CFLAGS += $(DBUS_CFLAGS)
-libconfig_la_SOURCES += dbus-core.c
-libconfig_la_LIBADD += $(DBUS_LIBS)
-endif
-
-if CONFIG_UDEV
-
-AM_CFLAGS += $(UDEV_CFLAGS)
-libconfig_la_SOURCES += udev.c
-libconfig_la_LIBADD += $(UDEV_LIBS)
-
-if XORG
-xorgconfddir = $(datadir)/X11/$(XF86CONFIGDIR)
-xorgconfd_DATA = 10-quirks.conf
-endif
-
-else
-
-if CONFIG_HAL
-AM_CFLAGS += $(HAL_CFLAGS)
-libconfig_la_SOURCES += hal.c
-libconfig_la_LIBADD += $(HAL_LIBS)
-
-else
-
-if CONFIG_WSCONS
-libconfig_la_SOURCES += wscons.c
-endif # CONFIG_WSCONS
-
-endif # !CONFIG_HAL
-
-endif # !CONFIG_UDEV
-
-EXTRA_DIST = x11-input.fdi fdi2iclass.py 10-quirks.conf
diff --git a/config/fdi2iclass.py b/config/fdi2iclass.py
index 897444068..840d36f5a 100755
--- a/config/fdi2iclass.py
+++ b/config/fdi2iclass.py
@@ -150,7 +150,7 @@ def parse_all_matches(node):
 
         # walk up to a parent match node
         node = node.parentNode
-        if node == None or not is_match_node(node):
+        if node is None or not is_match_node(node):
             break
 
         # leave if there other options at this level
@@ -184,9 +184,6 @@ def parse_fdi(fdi):
     # find all <match> leaf nodes
     num = 0
     for match_node in fdi.getElementsByTagName('match'):
-        children = set([n.tagName for n in match_node.childNodes
-                if n.nodeType == xml.dom.minidom.Node.ELEMENT_NODE])
-
         # see if there are any options at this level
         (driver, ignore, options) = parse_options(match_node)
         if not driver and not ignore and not options:
diff --git a/config/meson.build b/config/meson.build
index 2b5ab18bb..db7c49346 100644
--- a/config/meson.build
+++ b/config/meson.build
@@ -19,7 +19,7 @@ if build_udev
     config_dep += udev_dep
 endif
 
-if host_machine.system() == 'openbsd'
+if host_machine.system() == 'netbsd' or host_machine.system() == 'openbsd'
     srcs_config += 'wscons.c'
 endif
 
diff --git a/config/wscons.c b/config/wscons.c
index ee4567590..e9368be6a 100644
--- a/config/wscons.c
+++ b/config/wscons.c
@@ -30,6 +30,7 @@
 
 #include <sys/ioctl.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -54,7 +55,10 @@ struct nameint {
     char *name;
 } kbdenc[] = {
     KB_OVRENC,
-    KB_ENCTAB,
+    KB_ENCTAB
+#ifndef __NetBSD__
+    ,
+#endif
     {0}
 };
 
@@ -220,7 +224,11 @@ wscons_add_pointers(void)
     for (i = 0; i < 4; i++) {
         snprintf(devname, sizeof(devname), "%s%d", WSCONS_MOUSE_PREFIX, i);
         LogMessageVerb(X_INFO, 10, "wsmouse: checking %s\n", devname);
-        fd = open_device(devnamem O_RDWR | O_NONBLOCK | O_EXCL);
+#ifdef HAVE_OPEN_DEVICE
+        fd = open_device(devname, O_RDWR | O_NONBLOCK | O_EXCL);
+#else
+        fd = open(devname, O_RDWR | O_NONBLOCK | O_EXCL);
+#endif
         if (fd == -1) {
             LogMessageVerb(X_WARNING, 10, "%s: %s\n", devname, strerror(errno));
             continue;
@@ -233,9 +241,11 @@ wscons_add_pointers(void)
         }
         close(fd);
         switch (wsmouse_type) {
+#ifdef WSMOUSE_TYPE_SYNAPTICS
         case WSMOUSE_TYPE_SYNAPTICS:
             wscons_add_pointer(devname, "synaptics", ATTR_TOUCHPAD);
             break;
+#endif
         case WSMOUSE_TYPE_TPANEL:
             wscons_add_pointer(devname, "ws", ATTR_TOUCHSCREEN);
             break;
@@ -243,8 +253,8 @@ wscons_add_pointers(void)
             break;
         }
     }
-    /* Add a default entry catching all other mux elements as "mouse" */
-    wscons_add_pointer(WSCONS_MOUSE_PREFIX, "mouse", ATTR_POINTER);
+    /* Add a default entry catching all other mux elements as pointers */
+    wscons_add_pointer(WSCONS_MOUSE_PREFIX, "ws", ATTR_POINTER);
 }
 
 int
diff --git a/configure.ac b/configure.ac
deleted file mode 100644
index 88c25abce..000000000
--- a/configure.ac
+++ /dev/null
@@ -1,2364 +0,0 @@
-dnl Copyright © 2003-2007 Keith Packard, Daniel Stone
-dnl
-dnl Permission is hereby granted, free of charge, to any person obtaining a
-dnl copy of this software and associated documentation files (the "Software"),
-dnl to deal in the Software without restriction, including without limitation
-dnl the rights to use, copy, modify, merge, publish, distribute, sublicense,
-dnl and/or sell copies of the Software, and to permit persons to whom the
-dnl Software is furnished to do so, subject to the following conditions:
-dnl
-dnl The above copyright notice and this permission notice (including the next
-dnl paragraph) shall be included in all copies or substantial portions of the
-dnl Software.
-dnl
-dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-dnl IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-dnl DEALINGS IN THE SOFTWARE.
-dnl
-dnl Authors: Keith Packard <keithp@keithp.com>
-dnl          Daniel Stone <daniel@fooishbar.org>
-dnl          an unwitting cast of miscellaneous others
-dnl
-dnl Process this file with autoconf to create configure.
-
-AC_PREREQ(2.60)
-AC_INIT([xorg-server], 21.1.6, [https://gitlab.freedesktop.org/xorg/xserver/issues], xorg-server)
-RELEASE_DATE="2022-12-19"
-RELEASE_NAME="Caramel Ice Cream"
-AC_CONFIG_SRCDIR([Makefile.am])
-AC_CONFIG_MACRO_DIR([m4])
-AM_INIT_AUTOMAKE([foreign dist-xz])
-AC_USE_SYSTEM_EXTENSIONS
-
-# Require xorg-macros minimum of 1.14 for XORG_COMPILER_BRAND in XORG_DEFAULT_OPTIONS
-m4_ifndef([XORG_MACROS_VERSION],
-          [m4_fatal([must install xorg-macros 1.14 or later before running autoconf/autogen])])
-XORG_MACROS_VERSION(1.14)
-XORG_DEFAULT_OPTIONS
-XORG_WITH_DOXYGEN(1.6.1)
-XORG_CHECK_SGML_DOCTOOLS(1.8)
-XORG_ENABLE_DOCS
-XORG_ENABLE_DEVEL_DOCS
-XORG_WITH_XMLTO(0.0.20)
-XORG_WITH_FOP
-XORG_WITH_XSLTPROC
-XORG_ENABLE_UNIT_TESTS
-XORG_LD_WRAP([optional])
-
-m4_ifndef([XORG_FONT_MACROS_VERSION], [m4_fatal([must install font-util 1.1 or later before running autoconf/autogen])])
-XORG_FONT_MACROS_VERSION(1.1)
-
-dnl this gets generated by autoheader, and thus contains all the defines.  we
-dnl don't ever actually use it, internally.
-AC_CONFIG_HEADERS(include/do-not-use-config.h)
-dnl xorg-server.h is an external header, designed to be included by loadable
-dnl drivers.
-AC_CONFIG_HEADERS(include/xorg-server.h)
-dnl dix-config.h covers most of the DIX (i.e. everything but the DDX, not just
-dnl dix/).
-AC_CONFIG_HEADERS(include/dix-config.h)
-dnl xorg-config.h covers the Xorg DDX.
-AC_CONFIG_HEADERS(include/xorg-config.h)
-dnl xkb-config.h covers XKB for the Xorg and Xnest DDXs.
-AC_CONFIG_HEADERS(include/xkb-config.h)
-dnl xwin-config.h covers the XWin DDX.
-AC_CONFIG_HEADERS(include/xwin-config.h)
-dnl version-config.h covers the version numbers so they can be bumped without
-dnl forcing an entire recompile.x
-AC_CONFIG_HEADERS(include/version-config.h)
-
-AM_PROG_AS
-AC_PROG_LN_S
-LT_PREREQ([2.2])
-LT_INIT([disable-static win32-dll])
-PKG_PROG_PKG_CONFIG
-AC_PROG_LEX
-AC_PROG_YACC
-AC_SYS_LARGEFILE
-XORG_PROG_RAWCPP
-
-# Quoted so that make will expand $(CWARNFLAGS) in makefiles to allow
-# easier overrides at build time.
-XSERVER_CFLAGS='$(CWARNFLAGS)'
-
-dnl Explicitly add -fno-strict-aliasing since this option should disappear
-dnl from util-macros CWARNFLAGS
-if  test "x$GCC" = xyes ; then
-    XSERVER_CFLAGS="$XSERVER_CFLAGS -fno-strict-aliasing"
-fi
-
-dnl Check for dtrace program (needed to build Xserver dtrace probes)
-dnl Also checks for <sys/sdt.h>, since some Linux distros have an 
-dnl ISDN trace program named dtrace
-AC_ARG_WITH(dtrace, AS_HELP_STRING([--with-dtrace=PATH],
-	     [Enable dtrace probes (default: enabled if dtrace found)]),
-	     [WDTRACE=$withval], [WDTRACE=auto])
-if test "x$WDTRACE" = "xyes" -o "x$WDTRACE" = "xauto" ; then
-	AC_PATH_PROG(DTRACE, [dtrace], [not_found], [$PATH:/usr/sbin])
-	if test "x$DTRACE" = "xnot_found" ; then
-		if test "x$WDTRACE" = "xyes" ; then
-			AC_MSG_FAILURE([dtrace requested but not found])
-		fi
-		WDTRACE="no"
-	else
-		AC_CHECK_HEADER(sys/sdt.h, [HAS_SDT_H="yes"], [HAS_SDT_H="no"])
-		if test "x$WDTRACE" = "xauto" -a "x$HAS_SDT_H" = "xno" ; then
-			WDTRACE="no"
-		fi
-	fi
-fi
-if test "x$WDTRACE" != "xno" ; then
-  AC_DEFINE(XSERVER_DTRACE, 1, 
-      [Define to 1 if the DTrace Xserver provider probes should be built in.])
-
-# Solaris/OpenSolaris require dtrace -G to build dtrace probe information into
-# object files, and require linking with those as relocatable objects, not .a
-# archives. MacOS X handles all this in the normal compiler toolchain, and on
-# some releases (like Tiger), will error out on dtrace -G.  For now, other
-# platforms with Dtrace ports are assumed to support -G (the FreeBSD and Linux
-# ports appear to, based on my web searches, but have not yet been tested).
-	case $host_os in
-		darwin*)	SPECIAL_DTRACE_OBJECTS=no ;;
-		*)		SPECIAL_DTRACE_OBJECTS=yes ;;
-	esac
-fi
-AM_CONDITIONAL(XSERVER_DTRACE, [test "x$WDTRACE" != "xno"])
-AM_CONDITIONAL(SPECIAL_DTRACE_OBJECTS, [test "x$SPECIAL_DTRACE_OBJECTS" = "xyes"])
-
-AC_HEADER_DIRENT
-AC_HEADER_STDC
-AC_CHECK_HEADERS([fcntl.h stdlib.h string.h unistd.h dlfcn.h stropts.h \
- fnmatch.h sys/mkdev.h sys/sysmacros.h sys/utsname.h])
-
-dnl Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_C_TYPEOF
-AC_C_BIGENDIAN(AC_DEFINE(X_BYTE_ORDER, X_BIG_ENDIAN, [byte order]),
-               AC_DEFINE(X_BYTE_ORDER, X_LITTLE_ENDIAN, [byte order]))
-
-AC_CHECK_SIZEOF([unsigned long])
-if test "$ac_cv_sizeof_unsigned_long" = 8; then
-	AC_DEFINE(_XSERVER64, 1, [Define to 1 if unsigned long is 64 bits.])
-fi
-
-AC_TYPE_PID_T
-
-dnl Check to see if dlopen is in default libraries (like Solaris, which
-dnl has it in libc), or if libdl is needed to get it.
-AC_CHECK_FUNC([dlopen], [],
-	AC_CHECK_LIB([dl], [dlopen], DLOPEN_LIBS="-ldl"))
-AC_SUBST(DLOPEN_LIBS)
-
-dnl Checks for library functions.
-AC_CHECK_FUNCS([backtrace geteuid getuid issetugid getresuid \
-	getdtablesize getifaddrs getpeereid getpeerucred getprogname getzoneid \
-	mmap posix_fallocate seteuid shmctl64 strncasecmp vasprintf vsnprintf \
-	walkcontext setitimer poll epoll_create1 mkostemp memfd_create \
-	sigprocmask isastream])
-AC_CONFIG_LIBOBJ_DIR([os])
-AC_REPLACE_FUNCS([reallocarray strcasecmp strcasestr strlcat strlcpy strndup\
-	timingsafe_memcmp])
-AM_CONDITIONAL(POLL, [test "x$ac_cv_func_poll" = "xyes"])
-
-AC_CHECK_LIB([bsd], [arc4random_buf])
-AC_CHECK_FUNCS([arc4random_buf])
-
-AC_CHECK_DECLS([program_invocation_short_name], [], [], [[#include <errno.h>]])
-
-dnl Check for SO_PEERCRED #define
-AC_CACHE_CHECK([for SO_PEERCRED in sys/socket.h],
-	       [xorg_cv_sys_have_so_peercred],
-	       [AC_EGREP_CPP(yes_have_so_peercred,[
-#include <sys/types.h>
-#include <sys/socket.h>
-#ifdef SO_PEERCRED
-yes_have_so_peercred
-#endif
-],
-	       [xorg_cv_sys_have_so_peercred=yes],
-	       [xorg_cv_sys_have_so_peercred=no])])
-
-dnl define NO_LOCAL_CLIENT_CRED if no getpeereid, getpeerucred or SO_PEERCRED
-if test "x$ac_cv_func_getpeereid" = xno && test "x$ac_cv_func_getpeerucred" = xno && test "x$xorg_cv_sys_have_so_peercred" = xno ; then
-	AC_DEFINE([NO_LOCAL_CLIENT_CRED], 1, [Define to 1 if no local socket credentials interface exists])
-fi
-
-dnl Find the math library, then check for cbrt function in it.
-AC_CHECK_LIB(m, sqrt)
-AC_CHECK_FUNCS([cbrt])
-
-dnl AGPGART headers
-AC_ARG_ENABLE(agp, AS_HELP_STRING([--enable-agp],
-				  [Enable AGP support (default: auto)]),
-			          [AGP=$enableval], [AGP=auto])
-if test "x$AGP" = "xauto" ; then
-    AC_CHECK_HEADERS([linux/agpgart.h sys/agpio.h sys/agpgart.h], AGP=yes)
-fi
-AM_CONDITIONAL(AGP, [test "x$AGP" = xyes])
-
-dnl fbdev header
-AC_CHECK_HEADERS([linux/fb.h], FBDEV=yes)
-AM_CONDITIONAL(FBDEVHW, [test "x$FBDEV" = xyes])
-
-dnl FreeBSD kldload support (sys/linker.h)
-AC_CHECK_HEADERS([sys/linker.h],
-	[ac_cv_sys_linker_h=yes],
-	[ac_cv_sys_linker_h=no],
-	[#include <sys/param.h>])
-AM_CONDITIONAL(FREEBSD_KLDLOAD, [test "x$ac_cv_sys_linker_h" = xyes])
-
-AC_CACHE_CHECK([for SYSV IPC],
-		ac_cv_sysv_ipc,
-               [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
-#include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/shm.h>
-#include <sys/stat.h>
-]],[[
-{ 
-    int id;
-    id = shmget(IPC_PRIVATE, 512, S_IRUSR | S_IWUSR);
-    if (id < 0) return -1;
-    return shmctl(id, IPC_RMID, 0);
-}]])],
-       [ac_cv_sysv_ipc=yes],
-       [ac_cv_sysv_ipc=no])])
-if test "x$ac_cv_sysv_ipc" = xyes; then
-	AC_DEFINE(HAVE_SYSV_IPC, 1, [Define to 1 if SYSV IPC is available])
-fi
-
-dnl OpenBSD /dev/xf86 aperture driver 
-if test -c /dev/xf86 ; then
-	AC_DEFINE(HAS_APERTURE_DRV, 1, [System has /dev/xf86 aperture driver])
-fi
-	
-dnl glibc backtrace support check
-AC_CHECK_HEADER([execinfo.h],[
-    AC_CHECK_LIB(c, backtrace, [
-        AC_DEFINE(HAVE_BACKTRACE, 1, [Has backtrace support])
-        AC_DEFINE(HAVE_EXECINFO_H, 1, [Have execinfo.h])
-    ])]
-)
-
-dnl ---------------------------------------------------------------------------
-dnl Bus options and CPU capabilities.  Replaces logic in
-dnl hw/xfree86/os-support/bus/Makefile.am, among others.
-dnl ---------------------------------------------------------------------------
-DEFAULT_INT10="x86emu"
-
-dnl Override defaults as needed for specific platforms:
-
-case $host_cpu in
-  alpha*)
-	ALPHA_VIDEO=yes
-	case $host_os in
-	        *freebsd*)	SYS_LIBS=-lio ;;
-		*netbsd*)	AC_DEFINE(USE_ALPHA_PIO, 1, [NetBSD PIO alpha IO]) ;;
-	esac
-	GLX_ARCH_DEFINES="-D__GLX_ALIGN64 -mieee"
-	;;
-  arm*)
-	ARM_VIDEO=yes
-	DEFAULT_INT10="stub"
-	;;
-  i*86)
-	I386_VIDEO=yes
-	case $host_os in
-		*freebsd*)	AC_DEFINE(USE_DEV_IO) ;;
-		*dragonfly*)	AC_DEFINE(USE_DEV_IO) ;;
-		*netbsd*)	AC_DEFINE(USE_I386_IOPL)
-				SYS_LIBS=-li386
-				;;
-		*openbsd*)	AC_DEFINE(USE_I386_IOPL) 
-				SYS_LIBS=-li386
-				;;
-	esac
-        ;;
-  powerpc*)
-	PPC_VIDEO=yes
-	case $host_os in
-		*freebsd*)	DEFAULT_INT10=stub ;;
-	esac
-	;;
-  sparc*)
-	SPARC64_VIDEO=yes
-	BSD_ARCH_SOURCES="sparc64_video.c ioperm_noop.c"
-	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
-	;;
-  x86_64*|amd64*)
-	I386_VIDEO=yes
-	case $host_os in
-		*freebsd*)	AC_DEFINE(USE_DEV_IO, 1, [BSD /dev/io]) ;;
-		*dragonfly*)	AC_DEFINE(USE_DEV_IO, 1, [BSD /dev/io]) ;;
-		*netbsd*)	AC_DEFINE(USE_I386_IOPL, 1, [BSD i386 iopl])
-				SYS_LIBS=-lx86_64
-				;;
-		*openbsd*)	AC_DEFINE(USE_AMD64_IOPL, 1, [BSD AMD64 iopl])
-				SYS_LIBS=-lamd64
-				;;
-	esac
-	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
-	;;
-  ia64*)
-  	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
-	;;
-  s390*)
-  	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
-	;;
-esac
-AC_SUBST(GLX_ARCH_DEFINES)
-
-dnl BSD *_video.c selection
-AM_CONDITIONAL(ALPHA_VIDEO, [test "x$ALPHA_VIDEO" = xyes])
-AM_CONDITIONAL(ARM_VIDEO, [test "x$ARM_VIDEO" = xyes])
-AM_CONDITIONAL(I386_VIDEO, [test "x$I386_VIDEO" = xyes])
-AM_CONDITIONAL(PPC_VIDEO, [test "x$PPC_VIDEO" = xyes])
-AM_CONDITIONAL(SPARC64_VIDEO, [test "x$SPARC64_VIDEO" = xyes])
-
-DRI=no
-dnl it would be nice to autodetect these *CONS_SUPPORTs
-case $host_os in
-  *freebsd* | *dragonfly*)
-	case $host_os in
-		kfreebsd*-gnu) ;;
-		*) AC_DEFINE(CSRG_BASED, 1, [System is BSD-like]) ;;
-	esac
-	AC_DEFINE(PCCONS_SUPPORT, 1, [System has PC console])
-	AC_DEFINE(PCVT_SUPPORT, 1, [System has PCVT console])
-	AC_DEFINE(SYSCONS_SUPPORT, 1, [System has syscons console])
-	DRI=yes
-	;;
-  *netbsd*)
-	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
-	AC_DEFINE(PCCONS_SUPPORT, 1, [System has PC console])
-	AC_DEFINE(PCVT_SUPPORT, 1, [System has PCVT console])
-	AC_DEFINE(WSCONS_SUPPORT, 1, [System has wscons console])
-	DRI=yes
-	;;
-  *openbsd*)
-	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
-	AC_DEFINE(PCVT_SUPPORT, 1, [System has PC console])
-	AC_DEFINE(WSCONS_SUPPORT, 1, [System has wscons console])
-	;;
-  *linux*)
-	DRI=yes
-	;;
-  *solaris*)
-	DRI=yes
-	;;
-  darwin*)
-	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
-	;;
-  cygwin*|mingw*)
-	CFLAGS="$CFLAGS -DFD_SETSIZE=512"
-	;;
-esac
-
-dnl augment XORG_RELEASE_VERSION for our snapshot number and to expose the
-dnl major number
-PVMAJOR=`echo $PACKAGE_VERSION | cut -d . -f 1`
-
-dnl Convert to the old-style 1.x.y version scheme used up to 1.20.x for
-dnl backwards compatibility
-VENDOR_RELEASE="((10000000) + (($PVMAJOR) * 100000) + (($PVM) * 1000) + $PVP)"
-VENDOR_MAN_VERSION="Version ${PACKAGE_VERSION}"
-
-VENDOR_NAME="The X.Org Foundation"
-VENDOR_NAME_SHORT="X.Org"
-VENDOR_WEB="http://wiki.x.org"
-
-dnl Build options.
-AC_ARG_ENABLE(werror,        AS_HELP_STRING([--enable-werror],
-		  [Obsolete - use --enable-strict-compilation instead]),
-  AC_MSG_ERROR([--enable-werror has been replaced by --enable-strict-compilation]))
-
-AC_ARG_ENABLE(debug,         AS_HELP_STRING([--enable-debug],
-				  [Enable debugging (default: disabled)]),
-			        [DEBUGGING=$enableval], [DEBUGGING=no])
-AC_ARG_WITH(int10,           AS_HELP_STRING([--with-int10=BACKEND], [int10 backend: vm86, x86emu or stub]),
-				[INT10="$withval"],
-				[INT10="$DEFAULT_INT10"])
-AC_ARG_WITH(vendor-name,     AS_HELP_STRING([--with-vendor-name=VENDOR],
-				  [Vendor string reported by the server]),
-				[ VENDOR_NAME="$withval" ], [])
-AC_ARG_WITH(vendor-name-short, AS_HELP_STRING([--with-vendor-name-short=VENDOR],
-				  [Short version of vendor string reported by the server]),
-				[ VENDOR_NAME_SHORT="$withval" ], [])
-AC_ARG_WITH(vendor-web,      AS_HELP_STRING([--with-vendor-web=URL],
-				  [Vendor web address reported by the server]),
-				[ VENDOR_WEB="$withval" ], [])
-AC_ARG_WITH(module-dir,      AS_HELP_STRING([--with-module-dir=DIR],
-				  [Directory where modules are installed (default: $libdir/xorg/modules)]),
-				[ moduledir="$withval" ],
-				[ moduledir="${libdir}/xorg/modules" ])
-AC_ARG_WITH(log-dir,         AS_HELP_STRING([--with-log-dir=DIR],
-				  [Directory where log files are kept (default: $localstatedir/log)]),
-				[ logdir="$withval" ],
-				[ logdir="$localstatedir/log" ])
-AC_ARG_WITH(builder-addr,    AS_HELP_STRING([--with-builder-addr=ADDRESS],
-				  [Builder address (default: xorg@lists.freedesktop.org)]),
-				[ BUILDERADDR="$withval" ],
-				[ BUILDERADDR="xorg@lists.freedesktop.org" ])
-AC_ARG_WITH(builderstring,   AS_HELP_STRING([--with-builderstring=BUILDERSTRING], [Additional builder string]),
-				[ BUILDERSTRING="$withval" ]
-				[ ])
-AC_ARG_ENABLE(listen-tcp,    AS_HELP_STRING([--enable-listen-tcp],
-                                            [Listen on TCP by default (default:disabled)]),
-                                [LISTEN_TCP=$enableval], [LISTEN_TCP=no])
-AC_ARG_ENABLE(listen-unix,   AS_HELP_STRING([--disable-listen-unix],
-                                            [Listen on Unix by default (default:enabled)]),
-                                [LISTEN_UNIX=$enableval], [LISTEN_UNIX=yes])
-
-AC_ARG_ENABLE(listen-local,  AS_HELP_STRING([--disable-listen-local],
-                                            [Listen on local by default (default:enabled)]),
-                                [LISTEN_LOCAL=$enableval], [LISTEN_LOCAL=yes])
-
-case $host_os in
-    linux*)
-        FALLBACK_INPUT_DRIVER="libinput"
-        ;;
-    *)
-        FALLBACK_INPUT_DRIVER=""
-        ;;
-esac
-AC_ARG_WITH(fallback-input-driver,
-            AC_HELP_STRING([--with-fallback-input-driver=$FALLBACK_INPUT_DRIVER],
-                           [Input driver fallback if the requested driver for a device is unavailable]),
-                           [ FALLBACK_INPUT_DRIVER=$withval ], [])
-if test "x$FALLBACK_INPUT_DRIVER" = "xno"; then
-    FALLBACK_INPUT_DRIVER=""
-fi
-AC_MSG_CHECKING([for fallback input driver])
-AC_MSG_RESULT([$FALLBACK_INPUT_DRIVER])
-AC_DEFINE_UNQUOTED(FALLBACK_INPUT_DRIVER, ["$FALLBACK_INPUT_DRIVER"], [ Fallback input driver ])
-
-dnl Determine font path
-XORG_FONTROOTDIR
-XORG_FONTSUBDIR(FONTMISCDIR, fontmiscdir, misc)
-XORG_FONTSUBDIR(FONTOTFDIR, fontotfdir, OTF)
-XORG_FONTSUBDIR(FONTTTFDIR, fontttfdir, TTF)
-XORG_FONTSUBDIR(FONTTYPE1DIR, fonttype1dir, Type1)
-XORG_FONTSUBDIR(FONT75DPIDIR, font75dpidir, 75dpi)
-XORG_FONTSUBDIR(FONT100DPIDIR, font100dpidir, 100dpi)
-
-dnl Uses --with-default-font-path if set, otherwise uses standard
-dnl subdirectories of FONTROOTDIR. Some distros set the default font path to
-dnl "catalogue:/etc/X11/fontpath.d,built-ins"
-DEFAULT_FONT_PATH="${FONTMISCDIR}/,${FONTTTFDIR}/,${FONTOTFDIR}/,${FONTTYPE1DIR}/,${FONT100DPIDIR}/,${FONT75DPIDIR}/"
-case $host_os in
-    darwin*) DEFAULT_FONT_PATH="${DEFAULT_FONT_PATH},/Library/Fonts,/System/Library/Fonts" ;;
-esac
-
-AC_ARG_WITH(default-font-path, AS_HELP_STRING([--with-default-font-path=PATH], [Comma separated list of font dirs]),
-				[ FONTPATH="$withval" ],
-				[ FONTPATH="${DEFAULT_FONT_PATH}" ])
-
-AC_MSG_CHECKING([for default font path])
-AC_MSG_RESULT([$FONTPATH])
-
-AC_ARG_WITH(xkb-path,         AS_HELP_STRING([--with-xkb-path=PATH], [Path to XKB base dir (default: auto)]),
-				[ XKBPATH="$withval" ],
-				[ XKBPATH="auto" ])
-AC_ARG_WITH(xkb-output,       AS_HELP_STRING([--with-xkb-output=PATH], [Path to XKB output dir (default: ${datadir}/X11/xkb/compiled)]),
-				[ XKBOUTPUT="$withval" ],
-				[ XKBOUTPUT="compiled" ])
-AC_ARG_WITH(default-xkb-rules, AS_HELP_STRING([--with-default-xkb-rules=RULES],
-                                   [Keyboard ruleset (default: base/evdev)]),
-                                [ XKB_DFLT_RULES="$withval" ],
-                                [ XKB_DFLT_RULES="" ])
-AC_ARG_WITH(default-xkb-model, AS_HELP_STRING([--with-default-xkb-model=MODEL],
-                                   [Keyboard model (default: pc105)]),
-                                [ XKB_DFLT_MODEL="$withval" ],
-                                [ XKB_DFLT_MODEL="pc105" ])
-AC_ARG_WITH(default-xkb-layout, AS_HELP_STRING([--with-default-xkb-layout=LAYOUT],
-                                   [Keyboard layout (default: us)]),
-                                [ XKB_DFLT_LAYOUT="$withval" ],
-                                [ XKB_DFLT_LAYOUT="us" ])
-AC_ARG_WITH(default-xkb-variant, AS_HELP_STRING([--with-default-xkb-variant=VARIANT],
-                                   [Keyboard variant (default: (none))]),
-                                [ XKB_DFLT_VARIANT="$withval" ],
-                                [ XKB_DFLT_VARIANT="" ])
-AC_ARG_WITH(default-xkb-options, AS_HELP_STRING([--with-default-xkb-options=OPTIONS],
-                                   [Keyboard layout options (default: (none))]),
-                                [ XKB_DFLT_OPTIONS="$withval" ],
-                                [ XKB_DFLT_OPTIONS="" ])
-AC_ARG_WITH(serverconfig-path, AS_HELP_STRING([--with-serverconfig-path=PATH],
-				   [Directory where ancillary server config files are installed (default: ${libdir}/xorg)]),
-				[ SERVERCONFIG="$withval" ],
-				[ SERVERCONFIG="${libdir}/xorg" ])
-AC_ARG_WITH(apple-applications-dir,AS_HELP_STRING([--with-apple-applications-dir=PATH], [Path to the Applications directory (default: /Applications/Utilities)]),
-				[ APPLE_APPLICATIONS_DIR="${withval}" ],
-				[ APPLE_APPLICATIONS_DIR="/Applications/Utilities" ])
-AC_SUBST([APPLE_APPLICATIONS_DIR])
-AC_ARG_WITH(apple-application-name,AS_HELP_STRING([--with-apple-application-name=NAME], [Name for the .app (default: X11)]),
-				[ APPLE_APPLICATION_NAME="${withval}" ],
-				[ APPLE_APPLICATION_NAME="X11" ])
-AC_SUBST([APPLE_APPLICATION_NAME])
-AC_ARG_WITH(bundle-id-prefix,  AS_HELP_STRING([--with-bundle-id-prefix=RDNS_PREFIX], [Prefix to use for bundle identifiers (default: org.x)]),
-                               [ BUNDLE_ID_PREFIX="${withval}" ])
-AC_SUBST([BUNDLE_ID_PREFIX])
-AC_DEFINE_UNQUOTED(BUNDLE_ID_PREFIX, "$BUNDLE_ID_PREFIX", [Prefix to use for bundle identifiers])
-m4_define(DEFAULT_BUNDLE_VERSION, m4_esyscmd([echo ]AC_PACKAGE_VERSION[ | cut -f1-3 -d. | tr -d '\n']))
-AC_ARG_WITH(bundle-version,    AS_HELP_STRING([--with-bundle-version=VERSION], [Version to use for X11.app's CFBundleVersion (default: ]DEFAULT_BUNDLE_VERSION[)]),
-                               [ BUNDLE_VERSION="${withval}" ],
-                               [ BUNDLE_VERSION="DEFAULT_BUNDLE_VERSION" ])
-AC_SUBST([BUNDLE_VERSION])
-AC_ARG_WITH(bundle-version-string, AS_HELP_STRING([--with-bundle-version-string=VERSION], [Version to use for X11.app's CFBundleShortVersionString (default: ]AC_PACKAGE_VERSION[)]),
-                               [ BUNDLE_VERSION_STRING="${withval}" ],
-                               [ BUNDLE_VERSION_STRING="${PACKAGE_VERSION}" ])
-AC_SUBST([BUNDLE_VERSION_STRING])
-AC_ARG_ENABLE(sparkle,AS_HELP_STRING([--enable-sparkle], [Enable updating of X11.app using the Sparkle Framework (default: disabled)]),
-				[ XQUARTZ_SPARKLE="${enableval}" ],
-				[ XQUARTZ_SPARKLE="no" ])
-AC_SUBST([XQUARTZ_SPARKLE])
-AC_ARG_WITH(sparkle-feed-url,  AS_HELP_STRING([--with-sparkle-feed-url=URL], [URL for the Sparkle feed (default: https://www.xquartz.org/releases/sparkle/release.xml)]),
-                               [ XQUARTZ_SPARKLE_FEED_URL="${withval}" ],
-                               [ XQUARTZ_SPARKLE_FEED_URL="https://www.xquartz.org/releases/sparkle/release.xml" ])
-AC_SUBST([XQUARTZ_SPARKLE_FEED_URL])
-AC_ARG_ENABLE(visibility,     AS_HELP_STRING([--enable-visibility], [Enable symbol visibility (default: auto)]),
-				[SYMBOL_VISIBILITY=$enableval],
-				[SYMBOL_VISIBILITY=auto])
-
-dnl GLX build options
-AC_ARG_WITH(khronos-spec-dir, AS_HELP_STRING([--with-khronos-spec-dir=PATH], [Path to Khronos OpenGL registry database files (default: auto)]),
-				[KHRONOS_SPEC_DIR="${withval}"],
-				[KHRONOS_SPEC_DIR=auto])
-
-dnl Extensions.
-AC_ARG_ENABLE(composite,      AS_HELP_STRING([--disable-composite], [Build Composite extension (default: enabled)]), [COMPOSITE=$enableval], [COMPOSITE=yes])
-AC_ARG_ENABLE(mitshm,         AS_HELP_STRING([--disable-mitshm], [Build SHM extension (default: auto)]), [MITSHM=$enableval], [MITSHM=auto])
-AC_ARG_ENABLE(xres,           AS_HELP_STRING([--disable-xres], [Build XRes extension (default: enabled)]), [RES=$enableval], [RES=yes])
-AC_ARG_ENABLE(record,         AS_HELP_STRING([--disable-record], [Build Record extension (default: enabled)]), [RECORD=$enableval], [RECORD=yes])
-AC_ARG_ENABLE(xv,             AS_HELP_STRING([--disable-xv], [Build Xv extension (default: enabled)]), [XV=$enableval], [XV=yes])
-AC_ARG_ENABLE(xvmc,           AS_HELP_STRING([--disable-xvmc], [Build XvMC extension (default: enabled)]), [XVMC=$enableval], [XVMC=yes])
-AC_ARG_ENABLE(dga,            AS_HELP_STRING([--disable-dga], [Build DGA extension (default: auto)]), [DGA=$enableval], [DGA=auto])
-AC_ARG_ENABLE(screensaver,    AS_HELP_STRING([--disable-screensaver], [Build ScreenSaver extension (default: enabled)]), [SCREENSAVER=$enableval], [SCREENSAVER=yes])
-AC_ARG_ENABLE(xdmcp,          AS_HELP_STRING([--disable-xdmcp], [Build XDMCP extension (default: auto)]), [XDMCP=$enableval], [XDMCP=auto])
-AC_ARG_ENABLE(xdm-auth-1,     AS_HELP_STRING([--disable-xdm-auth-1], [Build XDM-Auth-1 extension (default: auto)]), [XDMAUTH=$enableval], [XDMAUTH=auto])
-AC_ARG_ENABLE(glx,            AS_HELP_STRING([--disable-glx], [Build GLX extension (default: enabled)]), [GLX=$enableval], [GLX=yes])
-AC_ARG_ENABLE(dri,            AS_HELP_STRING([--enable-dri], [Build DRI extension (default: auto)]), [DRI=$enableval])
-AC_ARG_ENABLE(dri2,           AS_HELP_STRING([--enable-dri2], [Build DRI2 extension (default: auto)]), [DRI2=$enableval], [DRI2=auto])
-AC_ARG_ENABLE(dri3,           AS_HELP_STRING([--enable-dri3], [Build DRI3 extension (default: auto)]), [DRI3=$enableval], [DRI3=auto])
-AC_ARG_ENABLE(present,	      AS_HELP_STRING([--disable-present], [Build Present extension (default: enabled)]), [PRESENT=$enableval], [PRESENT=yes])
-AC_ARG_ENABLE(xinerama,	      AS_HELP_STRING([--disable-xinerama], [Build Xinerama extension (default: enabled)]), [XINERAMA=$enableval], [XINERAMA=yes])
-AC_ARG_ENABLE(xf86vidmode,    AS_HELP_STRING([--disable-xf86vidmode], [Build XF86VidMode extension (default: auto)]), [XF86VIDMODE=$enableval], [XF86VIDMODE=auto])
-AC_ARG_ENABLE(xace,           AS_HELP_STRING([--disable-xace], [Build X-ACE extension (default: enabled)]), [XACE=$enableval], [XACE=yes])
-AC_ARG_ENABLE(xselinux,       AS_HELP_STRING([--enable-xselinux], [Build SELinux extension (default: disabled)]), [XSELINUX=$enableval], [XSELINUX=no])
-AC_ARG_ENABLE(xcsecurity,     AS_HELP_STRING([--enable-xcsecurity], [Build Security extension (default: disabled)]), [XCSECURITY=$enableval], [XCSECURITY=no])
-AC_ARG_ENABLE(dbe,            AS_HELP_STRING([--disable-dbe], [Build DBE extension (default: enabled)]), [DBE=$enableval], [DBE=yes])
-AC_ARG_ENABLE(xf86bigfont,    AS_HELP_STRING([--enable-xf86bigfont], [Build XF86 Big Font extension (default: disabled)]), [XF86BIGFONT=$enableval], [XF86BIGFONT=no])
-AC_ARG_ENABLE(dpms,           AS_HELP_STRING([--disable-dpms], [Build DPMS extension (default: enabled)]), [DPMSExtension=$enableval], [DPMSExtension=yes])
-AC_ARG_ENABLE(config-udev,    AS_HELP_STRING([--enable-config-udev], [Build udev support (default: auto)]), [CONFIG_UDEV=$enableval], [CONFIG_UDEV=auto])
-AC_ARG_ENABLE(config-udev-kms,    AS_HELP_STRING([--enable-config-udev-kms], [Build udev kms support (default: auto)]), [CONFIG_UDEV_KMS=$enableval], [CONFIG_UDEV_KMS=auto])
-AC_ARG_ENABLE(config-hal,     AS_HELP_STRING([--disable-config-hal], [Build HAL support (default: auto)]), [CONFIG_HAL=$enableval], [CONFIG_HAL=auto])
-AC_ARG_ENABLE(config-wscons,  AS_HELP_STRING([--enable-config-wscons], [Build wscons config support (default: auto)]), [CONFIG_WSCONS=$enableval], [CONFIG_WSCONS=auto])
-AC_ARG_ENABLE(xfree86-utils,     AS_HELP_STRING([--enable-xfree86-utils], [Build xfree86 DDX utilities (default: enabled)]), [XF86UTILS=$enableval], [XF86UTILS=yes])
-AC_ARG_ENABLE(vgahw,          AS_HELP_STRING([--enable-vgahw], [Build Xorg with vga access (default: enabled)]), [VGAHW=$enableval], [VGAHW=yes])
-AC_ARG_ENABLE(int10-module,     AS_HELP_STRING([--enable-int10-module], [Build Xorg with int10 module (default: enabled)]), [INT10MODULE=$enableval], [INT10MODULE=yes])
-AC_ARG_ENABLE(windowsdri,     AS_HELP_STRING([--enable-windowsdri], [Build XWin with WindowsDRI extension (default: auto)]), [WINDOWSDRI=$enableval], [WINDOWSDRI=auto])
-AC_ARG_ENABLE(libdrm,         AS_HELP_STRING([--enable-libdrm], [Build Xorg with libdrm support (default: enabled)]), [DRM=$enableval],[DRM=yes])
-AC_ARG_ENABLE(clientids,      AS_HELP_STRING([--disable-clientids], [Build Xorg with client ID tracking (default: enabled)]), [CLIENTIDS=$enableval], [CLIENTIDS=yes])
-AC_ARG_ENABLE(pciaccess, AS_HELP_STRING([--enable-pciaccess], [Build Xorg with pciaccess library (default: enabled)]), [PCI=$enableval], [PCI=yes])
-AC_ARG_ENABLE(linux_acpi, AS_HELP_STRING([--disable-linux-acpi], [Disable building ACPI support on Linux (if available).]), [enable_linux_acpi=$enableval], [enable_linux_acpi=yes])
-AC_ARG_ENABLE(linux_apm, AS_HELP_STRING([--disable-linux-apm], [Disable building APM support on Linux (if available).]), [enable_linux_apm=$enableval], [enable_linux_apm=yes])
-AC_ARG_ENABLE(systemd-logind, AS_HELP_STRING([--enable-systemd-logind], [Build systemd-logind support (default: auto)]), [SYSTEMD_LOGIND=$enableval], [SYSTEMD_LOGIND=auto])
-AC_ARG_ENABLE(suid-wrapper, AS_HELP_STRING([--enable-suid-wrapper], [Build suid-root wrapper for legacy driver support on rootless xserver systems (default: no)]), [SUID_WRAPPER=$enableval], [SUID_WRAPPER=no])
-
-dnl DDXes.
-AC_ARG_ENABLE(xorg,    	      AS_HELP_STRING([--enable-xorg], [Build Xorg server (default: auto)]), [XORG=$enableval], [XORG=auto])
-AC_ARG_ENABLE(xvfb,    	      AS_HELP_STRING([--enable-xvfb], [Build Xvfb server (default: yes)]), [XVFB=$enableval], [XVFB=yes])
-AC_ARG_ENABLE(xnest,   	      AS_HELP_STRING([--enable-xnest], [Build Xnest server (default: auto)]), [XNEST=$enableval], [XNEST=auto])
-AC_ARG_ENABLE(xquartz,        AS_HELP_STRING([--enable-xquartz], [Build Xquartz server for OS-X (default: auto)]), [XQUARTZ=$enableval], [XQUARTZ=auto])
-AC_ARG_ENABLE(standalone-xpbproxy, AS_HELP_STRING([--enable-standalone-xpbproxy], [Build a standalone xpbproxy (in addition to the one integrated into Xquartz as a separate thread) (default: no)]), [STANDALONE_XPBPROXY=$enableval], [STANDALONE_XPBPROXY=no])
-AC_ARG_ENABLE(xwin,    	      AS_HELP_STRING([--enable-xwin], [Build XWin server (default: auto)]), [XWIN=$enableval], [XWIN=auto])
-AC_ARG_ENABLE(glamor,         AS_HELP_STRING([--enable-glamor], [Build glamor dix module (default: auto)]), [GLAMOR=$enableval], [GLAMOR=auto])
-AC_ARG_ENABLE(xf86-input-inputtest, AS_HELP_STRING([--enable-xf86-input-inputtest], [Build Xorg test input driver (default: yes)]), [XORG_DRIVER_INPUT_INPUTTEST=$enableval], [XORG_DRIVER_INPUT_INPUTTEST=yes])
-dnl kdrive and its subsystems
-AC_ARG_ENABLE(kdrive,         AS_HELP_STRING([--enable-kdrive], [Build kdrive servers (default: no)]), [KDRIVE=$enableval], [KDRIVE=no])
-AC_ARG_ENABLE(xephyr,         AS_HELP_STRING([--enable-xephyr], [Build the kdrive Xephyr server (default: auto)]), [XEPHYR=$enableval], [XEPHYR=auto])
-dnl kdrive options
-AC_ARG_ENABLE(libunwind,      AS_HELP_STRING([--enable-libunwind], [Use libunwind for backtracing (default: auto)]), [LIBUNWIND="$enableval"], [LIBUNWIND="auto"])
-AC_ARG_ENABLE(xshmfence,      AS_HELP_STRING([--disable-xshmfence], [Disable xshmfence (default: auto)]), [XSHMFENCE="$enableval"], [XSHMFENCE="auto"])
-
-
-dnl chown/chmod to be setuid root as part of build
-dnl Replaces InstallXserverSetUID in imake
-AC_ARG_ENABLE(install-setuid, 
-    AS_HELP_STRING([--enable-install-setuid],
-       [Install Xorg server as owned by root with setuid bit (default: auto)]),
-    [SETUID=$enableval], [SETUID=auto])
-AC_MSG_CHECKING([to see if we can install the Xorg server as root])
-if test "x$SETUID" = "xauto" ; then
-	case $host_os in
-	    cygwin*)		SETUID="no"  ;;
-	    mingw*)		SETUID="no"  ;;
-	    darwin*)		SETUID="no"  ;;
-	    *)
-	   	case $host_cpu in
-		    sparc)	SETUID="no"  ;;
-		    *)		SETUID="yes" ;;
-		esac
-	esac
-	if test "x$SETUID" = xyes; then
-		touch testfile
-		chown root testfile > /dev/null 2>&1 || SETUID="no"
-		rm -f testfile
-	fi
-fi
-AC_MSG_RESULT([$SETUID])
-AM_CONDITIONAL(INSTALL_SETUID, [test "x$SETUID" = "xyes"])
-
-dnl Issue an error if xtrans.m4 was not found and XTRANS_CONNECTION_FLAGS macro
-dnl was not expanded, since xorg-server with no transport types is rather useless.
-dnl
-dnl If you're seeing an error here, be sure you installed the lib/xtrans module
-dnl first and if it's not in the default location, that you set the ACLOCAL
-dnl environment variable to find it, such as:
-dnl	ACLOCAL="aclocal -I ${PREFIX}/share/aclocal"
-m4_pattern_forbid([^XTRANS_CONNECTION_FLAGS$])
-
-# Transport selection macro from xtrans.m4
-XTRANS_CONNECTION_FLAGS
-
-# Secure RPC detection macro from xtrans.m4
-XTRANS_SECURE_RPC_FLAGS
-AM_CONDITIONAL(SECURE_RPC, [test "x$SECURE_RPC" = xyes])
-
-AM_CONDITIONAL(INT10_VM86, [test "x$INT10" = xvm86])
-AM_CONDITIONAL(INT10_X86EMU, [test "x$INT10" = xx86emu])
-AM_CONDITIONAL(INT10_STUB, [test "x$INT10" = xstub])
-
-dnl DDX Detection... Yes, it's ugly to have it here... but we need to
-dnl handle this early on so that we don't require unsupported extensions
-case $host_os in
-	cygwin* | mingw*)
-		CONFIG_HAL=no
-		CONFIG_UDEV=no
-		CONFIG_UDEV_KMS=no
-		DGA=no
-		DRM=no
-		DRI2=no
-		DRI3=no
-		INT10MODULE=no
-		PCI=no
-		VGAHW=no
-		XF86UTILS=no
-		XF86VIDMODE=no
-		XSELINUX=no
-		SYMBOL_VISIBILITY=no
-		;;
-	darwin*)
-		PCI=no
-		INT10MODULE=no
-		VGAHW=no
-		DRM=no
-		DRI2=no
-		DRI3=no
-
-		if test x$XQUARTZ = xauto; then
-			AC_CACHE_CHECK([whether to build Xquartz],xorg_cv_Carbon_framework,[
-		 		save_LDFLAGS=$LDFLAGS
-				LDFLAGS="$LDFLAGS -framework Carbon"
-				AC_LINK_IFELSE([AC_LANG_SOURCE([char FSFindFolder(); int main() { FSFindFolder(); return 0;}])],
-				               [xorg_cv_Carbon_framework=yes],
-				               [xorg_cv_Carbon_framework=no])
-			        LDFLAGS=$save_LDFLAGS])
-                
-			if test "X$xorg_cv_Carbon_framework" = Xyes; then
-				XQUARTZ=yes
-			else
-				XQUARTZ=no
-			fi
-		fi
-
-		if test "x$XQUARTZ" = xyes ; then
-			XQUARTZ=yes
-			XVFB=no
-			XNEST=no
-
-			COMPOSITE=no
-			DGA=no
-			DPMSExtension=no
-			XF86VIDMODE=no
-		fi
-		;;
-	gnu*)
-		DRM=no
-		DRI2=no
-		DRI3=no
-		;;
-	*) XQUARTZ=no ;;
-esac
-
-dnl ---------------------------------------------------------------------------
-dnl Extension section
-dnl ---------------------------------------------------------------------------
-XEXT_INC='-I$(top_srcdir)/Xext'
-XEXT_LIB='$(top_builddir)/Xext/libXext.la'
-
-dnl Optional modules
-VIDEOPROTO="videoproto"
-COMPOSITEPROTO="compositeproto >= 0.4"
-RECORDPROTO="recordproto >= 1.13.99.1"
-SCRNSAVERPROTO="scrnsaverproto >= 1.1"
-RESOURCEPROTO="resourceproto >= 1.2.0"
-DRIPROTO="xf86driproto >= 2.1.0"
-DRI2PROTO="dri2proto >= 2.8"
-DRI3PROTO="dri3proto >= 1.2"
-XINERAMAPROTO="xineramaproto"
-BIGFONTPROTO="xf86bigfontproto >= 1.2.0"
-DGAPROTO="xf86dgaproto >= 2.0.99.1"
-GLPROTO="glproto >= 1.4.17"
-VIDMODEPROTO="xf86vidmodeproto >= 2.2.99.1"
-APPLEWMPROTO="applewmproto >= 1.4"
-LIBXSHMFENCE="xshmfence >= 1.1"
-
-dnl Required modules
-XPROTO="xproto >= 7.0.31"
-RANDRPROTO="randrproto >= 1.6.0"
-RENDERPROTO="renderproto >= 0.11"
-XEXTPROTO="xextproto >= 7.2.99.901"
-INPUTPROTO="inputproto >= 2.3.99.1"
-KBPROTO="kbproto >= 1.0.3"
-FONTSPROTO="fontsproto >= 2.1.3"
-FIXESPROTO="fixesproto >= 6.0"
-DAMAGEPROTO="damageproto >= 1.1"
-XCMISCPROTO="xcmiscproto >= 1.2.0"
-BIGREQSPROTO="bigreqsproto >= 1.1.0"
-XTRANS="xtrans >= 1.3.5"
-PRESENTPROTO="presentproto >= 1.2"
-
-dnl List of libraries that require a specific version
-LIBAPPLEWM="applewm >= 1.4"
-LIBDRI="dri >= 7.8.0"
-LIBDRM="libdrm >= 2.4.89"
-LIBEGL="egl"
-LIBGBM="gbm >= 10.2.0"
-LIBGL="gl >= 1.2"
-LIBXEXT="xext >= 1.0.99.4"
-LIBXFONT="xfont2 >= 2.0.0"
-LIBXI="xi >= 1.2.99.1"
-LIBXTST="xtst >= 1.0.99.2"
-LIBPCIACCESS="pciaccess >= 0.12.901"
-LIBUDEV="libudev >= 143"
-LIBSELINUX="libselinux >= 2.0.86"
-LIBDBUS="dbus-1 >= 1.0"
-LIBPIXMAN="pixman-1 >= 0.27.2"
-LIBXCVT="libxcvt"
-
-dnl Pixman is always required, but we separate it out so we can link
-dnl specific modules against it
-PKG_CHECK_MODULES(PIXMAN, $LIBPIXMAN)
-REQUIRED_LIBS="$REQUIRED_LIBS $LIBPIXMAN $LIBXFONT xau"
-
-dnl Core modules for most extensions, et al.
-SDK_REQUIRED_MODULES="$XPROTO $RANDRPROTO $RENDERPROTO $XEXTPROTO $INPUTPROTO $KBPROTO $FONTSPROTO $LIBPIXMAN $LIBXCVT"
-# Make SDK_REQUIRED_MODULES available for inclusion in xorg-server.pc
-AC_SUBST(SDK_REQUIRED_MODULES)
-
-AC_CHECK_DECL([PTHREAD_MUTEX_RECURSIVE], [HAVE_RECURSIVE_MUTEX=yes], [HAVE_RECURSIVE_MUTEX=no], [[#include <pthread.h>]])
-
-THREAD_DEFAULT=no
-
-if test "x$HAVE_RECURSIVE_MUTEX" = "xyes" ; then
-	THREAD_DEFAULT=yes
-fi
-
-case $host_os in
-	mingw*) THREAD_DEFAULT=no  ;;
-	*)
-esac
-
-AC_ARG_ENABLE(input-thread, AS_HELP_STRING([--enable-input-thread],
-	     [Enable input threads]),
-	     [INPUTTHREAD=$enableval], [INPUTTHREAD=$THREAD_DEFAULT])
-
-if test "x$INPUTTHREAD" = "xyes" ; then
-    AX_PTHREAD(,AC_MSG_ERROR([threaded input requested but no pthread support has been found]))
-    SYS_LIBS="$SYS_LIBS $PTHREAD_LIBS"
-    CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-    AC_DEFINE(INPUTTHREAD, 1, [Use a separate input thread])
-
-    save_LIBS="$LIBS"
-    LIBS="$LIBS $SYS_LIBS"
-    dnl MacOS X 10.6 & higher
-    AC_MSG_CHECKING(for pthread_setname_np(const char*))
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],
-	                            [pthread_setname_np("example")])],
-                   [AC_MSG_RESULT(yes)
-		    AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID,1,
-		              [Have function pthread_setname_np(const char*)])],
-                   [AC_MSG_RESULT(no)])
-    dnl GNU libc 2.12 & higher, Solaris 11.3 & higher
-    AC_MSG_CHECKING(for pthread_setname_np(pthread_t, const char*))
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],
-                             [pthread_setname_np(pthread_self(), "example")])],
-                   [AC_MSG_RESULT(yes)
-		    AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITH_TID,1,
-	                      [Have function pthread_setname_np(pthread_t, const char*)])],
-		   [AC_MSG_RESULT(no)])
-    LIBS="$save_LIBS"
-fi
-
-REQUIRED_MODULES="$FIXESPROTO $DAMAGEPROTO $XCMISCPROTO $XTRANS $BIGREQSPROTO $SDK_REQUIRED_MODULES"
-
-dnl systemd socket activation
-dnl activate the code in libxtrans that grabs systemd's socket fds
-dnl libsystemd-daemon was moved into libsystemd in version 209
-LIBSYSTEMD="libsystemd >= 209"
-AC_ARG_WITH([systemd-daemon],
-	AS_HELP_STRING([--with-systemd-daemon],
-		[support systemd socket activation (default: auto)]),
-	[WITH_SYSTEMD_DAEMON=$withval], [WITH_SYSTEMD_DAEMON=auto])
-if test "x$WITH_SYSTEMD_DAEMON" = "xyes" -o "x$WITH_SYSTEMD_DAEMON" = "xauto" ; then
-	PKG_CHECK_MODULES([SYSTEMD_DAEMON], [$LIBSYSTEMD],
-			  [HAVE_SYSTEMD_DAEMON=yes;
-			   LIBSYSTEMD_DAEMON="$LIBSYSTEMD"],
-			  [PKG_CHECK_MODULES([SYSTEMD_DAEMON], [libsystemd-daemon],
-					     [HAVE_SYSTEMD_DAEMON=yes;
-					      LIBSYSTEMD_DAEMON=libsystemd-daemon],
-					     [HAVE_SYSTEMD_DAEMON=no])])
-	if test "x$HAVE_SYSTEMD_DAEMON" = xyes; then
-		AC_DEFINE(HAVE_SYSTEMD_DAEMON, 1, [Define to 1 if libsystemd-daemon is available])
-		REQUIRED_LIBS="$REQUIRED_LIBS $LIBSYSTEMD_DAEMON"
-	elif test "x$WITH_SYSTEMD_DAEMON" = xyes; then
-		AC_MSG_ERROR([systemd support requested but no library has been found])
-	fi
-fi
-AM_CONDITIONAL([HAVE_SYSTEMD_DAEMON], [test "x$HAVE_SYSTEMD_DAEMON" = "xyes"])
-
-if test "x$CONFIG_UDEV" = xyes && test "x$CONFIG_HAL" = xyes; then
-	AC_MSG_ERROR([Hotplugging through both libudev and hal not allowed])
-fi
-
-PKG_CHECK_MODULES(UDEV, $LIBUDEV, [HAVE_LIBUDEV=yes], [HAVE_LIBUDEV=no])
-if test "x$CONFIG_UDEV" = xauto; then
-	CONFIG_UDEV="$HAVE_LIBUDEV"
-fi
-AM_CONDITIONAL(CONFIG_UDEV, [test "x$CONFIG_UDEV" = xyes])
-if test "x$CONFIG_UDEV" = xyes; then
-	CONFIG_HAL=no
-	if test "x$CONFIG_UDEV_KMS" = xauto; then
-		CONFIG_UDEV_KMS="$HAVE_LIBUDEV"
-	fi
-	if ! test "x$HAVE_LIBUDEV" = xyes; then
-		AC_MSG_ERROR([udev configuration API requested, but libudev is not installed])
-	fi
-	AC_DEFINE(CONFIG_UDEV, 1, [Use libudev for input hotplug])
-	if test "x$CONFIG_UDEV_KMS" = xyes; then
-		AC_DEFINE(CONFIG_UDEV_KMS, 1, [Use libudev for kms enumeration])
-	fi
-	SAVE_LIBS=$LIBS
-	SAVE_CFLAGS=$CFLAGS
-	CFLAGS="$CFLAGS $UDEV_CFLAGS"
-	LIBS=$UDEV_LIBS
-	AC_CHECK_FUNCS([udev_monitor_filter_add_match_tag])
-	AC_CHECK_FUNCS([udev_enumerate_add_match_tag])
-	LIBS=$SAVE_LIBS
-	CFLAGS=$SAVE_CFLAGS
-fi
-AM_CONDITIONAL(CONFIG_UDEV_KMS, [test "x$CONFIG_UDEV_KMS" = xyes])
-
-PKG_CHECK_MODULES(DBUS, $LIBDBUS, [HAVE_DBUS=yes], [HAVE_DBUS=no])
-if test "x$HAVE_DBUS" = xyes; then
-	AC_DEFINE(HAVE_DBUS, 1, [Have D-Bus support])
-fi
-AM_CONDITIONAL(HAVE_DBUS, [test "x$HAVE_DBUS" = xyes])
-
-PKG_CHECK_MODULES(HAL, hal, [HAVE_HAL=yes], [HAVE_HAL=no])
-if test "x$CONFIG_HAL" = xauto; then
-	CONFIG_HAL="$HAVE_HAL"
-fi
-if test "x$CONFIG_HAL" = xyes; then
-	if ! test "x$HAVE_HAL" = xyes; then
-		AC_MSG_ERROR([HAL hotplug API requested, but HAL is not installed.])
-	fi
-
-	AC_DEFINE(CONFIG_HAL, 1, [Use the HAL hotplug API])
-	NEED_DBUS="yes"
-fi
-AM_CONDITIONAL(CONFIG_HAL, [test "x$CONFIG_HAL" = xyes])
-
-if test "x$SYSTEMD_LOGIND" = xauto; then
-        if test "x$HAVE_DBUS" = xyes -a "x$CONFIG_UDEV" = xyes ; then
-                SYSTEMD_LOGIND=yes
-        else
-                SYSTEMD_LOGIND=no
-        fi
-fi
-if test "x$SYSTEMD_LOGIND" = xyes; then
-        if ! test "x$HAVE_DBUS" = xyes; then
-                AC_MSG_ERROR([systemd-logind requested, but D-Bus is not installed.])
-        fi
-        if ! test "x$CONFIG_UDEV" = xyes ; then
-                AC_MSG_ERROR([systemd-logind is only supported in combination with udev configuration.])
-        fi
-
-        AC_DEFINE(SYSTEMD_LOGIND, 1, [Enable systemd-logind integration])
-        NEED_DBUS="yes"
-fi
-AM_CONDITIONAL(SYSTEMD_LOGIND, [test "x$SYSTEMD_LOGIND" = xyes])
-
-if test "x$SUID_WRAPPER" = xyes; then
-        dnl This is a define so that if some platforms want to put the wrapper
-        dnl somewhere else this can be easily changed
-        AC_DEFINE_DIR(SUID_WRAPPER_DIR, libexecdir, [Where to install the Xorg binary and Xorg.wrap])
-        SETUID="no"
-fi
-AM_CONDITIONAL(SUID_WRAPPER, [test "x$SUID_WRAPPER" = xyes])
-
-if test "x$NEED_DBUS" = xyes; then
-        AC_DEFINE(NEED_DBUS, 1, [Enable D-Bus core])
-fi
-AM_CONDITIONAL(NEED_DBUS, [test "x$NEED_DBUS" = xyes])
-
-if test "x$CONFIG_WSCONS" = xauto; then
-	case $host_os in
-		*openbsd*)
-			CONFIG_WSCONS=yes;
-			;;
-		*)
-			CONFIG_WSCONS=no;
-			;;
-	esac
-fi
-AM_CONDITIONAL(CONFIG_WSCONS, [test "x$CONFIG_WSCONS" = xyes])
-if test "x$CONFIG_WSCONS" = xyes; then
-	AC_DEFINE(CONFIG_WSCONS, 1, [Use wscons for input auto configuration])
-fi
-
-
-AC_MSG_CHECKING([for glibc...])
-AC_PREPROC_IFELSE([AC_LANG_SOURCE([
-#include <features.h>
-#ifndef __GLIBC__
-#error
-#endif
-])], glibc=yes, glibc=no)
-AC_MSG_RESULT([$glibc])
-
-AC_CHECK_FUNCS([clock_gettime], [have_clock_gettime=yes],
-               [AC_CHECK_LIB([rt], [clock_gettime], [have_clock_gettime=-lrt],
-                             [have_clock_gettime=no])])
-
-AC_MSG_CHECKING([for a useful monotonic clock ...])
-
-if ! test "x$have_clock_gettime" = xno; then
-    if ! test "x$have_clock_gettime" = xyes; then
-        CLOCK_LIBS="$have_clock_gettime"
-    else
-        CLOCK_LIBS=""
-    fi
-
-    LIBS_SAVE="$LIBS"
-    LIBS="$CLOCK_LIBS"
-    CPPFLAGS_SAVE="$CPPFLAGS"
-
-    if test x"$glibc" = xyes; then
-        CPPFLAGS="$CPPFLAGS -D_POSIX_C_SOURCE=200112L"
-    fi
-
-    AC_RUN_IFELSE([AC_LANG_SOURCE([
-#include <time.h>
-
-int main(int argc, char *argv[[]]) {
-    struct timespec tp;
-
-    if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
-        return 0;
-    else
-        return 1;
-}
-    ])], [MONOTONIC_CLOCK=yes], [MONOTONIC_CLOCK=no],
-       [MONOTONIC_CLOCK="cross compiling"])
-
-    if test "$MONOTONIC_CLOCK" = "cross compiling"; then
-        AC_CHECK_DECL([CLOCK_MONOTONIC],[MONOTONIC_CLOCK="guessing yes"],[MONOTONIC_CLOCK=no],[#include <time.h>])
-    fi
-
-    LIBS="$LIBS_SAVE"
-    CPPFLAGS="$CPPFLAGS_SAVE"
-else
-    MONOTONIC_CLOCK=no
-fi
-
-AC_MSG_RESULT([$MONOTONIC_CLOCK])
-if test "$MONOTONIC_CLOCK" = "guessing yes"; then
-	MONOTONIC_CLOCK=yes
-fi
-
-if test "x$MONOTONIC_CLOCK" = xyes; then
-    AC_DEFINE(MONOTONIC_CLOCK, 1, [Have monotonic clock from clock_gettime()])
-    LIBS="$LIBS $CLOCK_LIBS"
-fi
-
-AM_CONDITIONAL(XV, [test "x$XV" = xyes])
-if test "x$XV" = xyes; then
-	AC_DEFINE(XV, 1, [Support Xv extension])
-	AC_DEFINE(XvExtension, 1, [Build Xv extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $VIDEOPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $VIDEOPROTO"
-else
-	XVMC=no
-fi
-
-AM_CONDITIONAL(XVMC, [test "x$XVMC" = xyes])
-if test "x$XVMC" = xyes; then
-	AC_DEFINE(XvMCExtension, 1, [Build XvMC extension])
-fi
-
-AM_CONDITIONAL(COMPOSITE, [test "x$COMPOSITE" = xyes])
-if test "x$COMPOSITE" = xyes; then
-	AC_DEFINE(COMPOSITE, 1, [Support Composite Extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $COMPOSITEPROTO"
-	COMPOSITE_LIB='$(top_builddir)/composite/libcomposite.la'
-	COMPOSITE_INC='-I$(top_srcdir)/composite'
-fi
-
-if test "x$MITSHM" = xauto; then
-	MITSHM="$ac_cv_sysv_ipc"
-fi
-AM_CONDITIONAL(MITSHM, [test "x$MITSHM" = xyes])
-if test "x$MITSHM" = xyes; then
-	AC_DEFINE(MITSHM, 1, [Support MIT-SHM extension])
-	AC_DEFINE(HAS_SHM, 1, [Support SHM])
-fi
-
-AM_CONDITIONAL(RECORD, [test "x$RECORD" = xyes])
-if test "x$RECORD" = xyes; then
-	AC_DEFINE(XRECORD, 1, [Support Record extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $RECORDPROTO"
-	RECORD_LIB='$(top_builddir)/record/librecord.la'
-fi
-
-AM_CONDITIONAL(SCREENSAVER, [test "x$SCREENSAVER" = xyes])
-if test "x$SCREENSAVER" = xyes; then
-	AC_DEFINE(SCREENSAVER, 1, [Support MIT-SCREEN-SAVER extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $SCRNSAVERPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $SCRNSAVERPROTO"
-fi
-
-HASHTABLE=no
-AM_CONDITIONAL(RES, [test "x$RES" = xyes])
-if test "x$RES" = xyes; then
-	AC_DEFINE(RES, 1, [Support X resource extension])
-	HASHTABLE=yes
-	REQUIRED_MODULES="$REQUIRED_MODULES $RESOURCEPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $RESOURCEPROTO"
-fi
-
-if test "x$LISTEN_TCP" = xyes; then
-	AC_DEFINE(LISTEN_TCP, 1, [Listen on TCP socket])
-fi
-if test "x$LISTEN_UNIX" = xyes; then
-	AC_DEFINE(LISTEN_UNIX, 1, [Listen on Unix socket])
-fi
-if test "x$LISTEN_LOCAL" = xyes; then
-	AC_DEFINE(LISTEN_LOCAL, 1, [Listen on local socket])
-fi
-
-# The XRes extension may support client ID tracking only if it has
-# been specifically enabled. Client ID tracking is implicitly not
-# supported if XRes extension is disabled.
-AC_MSG_CHECKING([whether to track client ids])
-if test "x$RES" = xyes && test "x$CLIENTIDS" = xyes; then
-	AC_DEFINE(CLIENTIDS, 1, [Support client ID tracking])
-else
-	CLIENTIDS=no
-fi
-if test "x$CLIENTIDS" = xyes; then
-	case $host_os in
-	openbsd*)
-		SYS_LIBS="$SYS_LIBS -lkvm"
-	;;
-	esac
-fi
-AC_MSG_RESULT([$CLIENTIDS])
-AM_CONDITIONAL(CLIENTIDS, [test "x$CLIENTIDS" = xyes])
-
-AM_CONDITIONAL(DRI, test "x$DRI" = xyes)
-if test "x$DRI" = xyes; then
-	AC_DEFINE(XF86DRI, 1, [Build DRI extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $DRIPROTO $GLPROTO $LIBDRI"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $DRIPROTO $GLPROTO $LIBDRI"
-fi
-
-PKG_CHECK_MODULES([DRI2PROTO], $DRI2PROTO,
-                  [HAVE_DRI2PROTO=yes], [HAVE_DRI2PROTO=no])
-case "$DRI2,$HAVE_DRI2PROTO" in
-	yes,no)
-		AC_MSG_ERROR([DRI2 requested, but dri2proto not found.])
-		;;
-	yes,yes | auto,yes)
-		AC_DEFINE(DRI2, 1, [Build DRI2 extension])
-		DRI2=yes
-		LIBGL="gl >= 1.2"
-		SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $DRI2PROTO"
-		;;
-esac
-AM_CONDITIONAL(DRI2, test "x$DRI2" = xyes)
-
-AC_ARG_ENABLE(xtrans-send-fds,	AS_HELP_STRING([--disable-xtrans-send-fds], [Use Xtrans support for fd passing (default: auto)]), [XTRANS_SEND_FDS=$enableval], [XTRANS_SEND_FDS=auto])
-
-case "x$XTRANS_SEND_FDS" in
-xauto)
-	case "$host_os" in
-	linux*|solaris*|freebsd*|dragonfly*|openbsd*)
-		XTRANS_SEND_FDS=yes
-		;;
-	*)
-		XTRANS_SEND_FDS=no
-		;;
-	esac
-esac
-
-case "x$XTRANS_SEND_FDS" in
-xyes)
-	AC_DEFINE(XTRANS_SEND_FDS, 1, [Enable xtrans fd passing support])
-	;;
-esac
-
-case "$DRI3,$XTRANS_SEND_FDS" in
-	yes,yes | auto,yes)
-		;;
-	yes,no)
-		AC_MSG_ERROR([DRI3 requested, but xtrans fd passing support not found.])
-		DRI3=no
-		;;
-	no,*)
-		;;
-	*)
-		AC_MSG_NOTICE([DRI3 disabled because xtrans fd passing support not found.])
-		DRI3=no
-		;;
-esac
-
-PKG_CHECK_MODULES([DRI3PROTO], $DRI3PROTO,
-                  [HAVE_DRI3PROTO=yes], [HAVE_DRI3PROTO=no])
-
-case "$DRI3,$HAVE_DRI3PROTO" in
-	yes,yes | auto,yes)
-		REQUIRED_MODULES="$REQUIRED_MODULES dri3proto"
-		;;
-	yes,no)
-		AC_MSG_ERROR([DRI3 requested, but dri3proto not found.])
-		DRI3=no
-		;;
-	no,*)
-		;;
-	*)
-		AC_MSG_NOTICE([DRI3 disabled because dri3proto not found.])
-		DRI3=no
-		;;
-esac
-
-AC_CHECK_FUNCS([sigaction])
-
-BUSFAULT=no
-
-case x"$ac_cv_func_sigaction" in
-	xyes)
-		AC_DEFINE(HAVE_SIGACTION, 1, [Have sigaction function])
-		BUSFAULT=yes
-		;;
-esac
-
-case x"$BUSFAULT" in
-	xyes)
-		AC_DEFINE(BUSFAULT, 1, [Include busfault OS API])
-		;;
-esac
-
-AM_CONDITIONAL(BUSFAULT, test x"$BUSFAULT" = xyes)
-
-
-PKG_CHECK_MODULES([XSHMFENCE], $LIBXSHMFENCE, [HAVE_XSHMFENCE=yes], [HAVE_XSHMFENCE=no])
-if test "x$XSHMFENCE" = "xauto"; then
-    XSHMFENCE="$HAVE_XSHMFENCE"
-fi
-
-if test "x$XSHMFENCE" = "xyes"; then
-    if test "x$HAVE_XSHMFENCE" != "xyes"; then
-        AC_MSG_ERROR([xshmfence requested but not installed.])
-    fi
-    AC_DEFINE(HAVE_XSHMFENCE, 1, [Have xshmfence support])
-    REQUIRED_LIBS="$REQUIRED_LIBS $LIBXSHMFENCE"
-fi
-
-AM_CONDITIONAL(XSHMFENCE, [test "x$XSHMFENCE" = xyes])
-
-case "$DRI3,$XSHMFENCE" in
-	yes,yes | auto,yes)
-		;;
-	yes,no)
-		AC_MSG_ERROR([DRI3 requested, but xshmfence not found.])
-		DRI3=no
-		;;
-	no,*)
-		;;
-	*)
-		AC_MSG_NOTICE([DRI3 disabled because xshmfence not found.])
-		DRI3=no
-		;;
-esac
-
-case x"$DRI3" in
-	xyes|xauto)
-		DRI3=yes
-		AC_DEFINE(DRI3, 1, [Build DRI3 extension])
-		DRI3_LIB='$(top_builddir)/dri3/libdri3.la'
-		SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $DRI3PROTO"
-		AC_MSG_NOTICE([DRI3 enabled]);
-		;;
-esac
-
-AM_CONDITIONAL(DRI3, test "x$DRI3" = xyes)
-
-if test "x$DRI" = xyes || test "x$DRI2" = xyes || test "x$DRI3" = xyes || test "x$CONFIG_UDEV_KMS" = xyes || test "x$XORG" = xyes; then
-	if test "x$DRM" = xyes; then
-		AC_DEFINE(WITH_LIBDRM, 1, [Building with libdrm support])
-		PKG_CHECK_MODULES([LIBDRM], $LIBDRM)
-	fi
-fi
-
-if test "x$GLX" = xyes; then
-	PKG_CHECK_MODULES([XLIB], [x11])
-	PKG_CHECK_MODULES([GL], $GLPROTO $LIBGL)
-	AC_SUBST(XLIB_CFLAGS)
-	AC_DEFINE(GLXEXT, 1, [Build GLX extension])
-	HASHTABLE=yes
-	GLX_LIBS='$(top_builddir)/glx/libglx.la $(top_builddir)/glx/libglxvnd.la'
-	GLX_SYS_LIBS="$GLX_SYS_LIBS $GL_LIBS"
-else
-        GLX=no
-fi
-AM_CONDITIONAL(GLX, test "x$GLX" = xyes)
-
-AM_CONDITIONAL(HASHTABLE, test "x$HASHTABLE" = xyes)
-
-AC_SUBST([GLX_DEFINES])
-AC_SUBST([GLX_SYS_LIBS])
-
-AM_CONDITIONAL(PRESENT, [test "x$PRESENT" = xyes])
-if test "x$PRESENT" = xyes; then
-	AC_DEFINE(PRESENT, 1, [Support Present extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $PRESENTPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $PRESENTPROTO"
-	PRESENT_INC='-I$(top_srcdir)/present'
-	PRESENT_LIB='$(top_builddir)/present/libpresent.la'
-fi
-
-AM_CONDITIONAL(XINERAMA, [test "x$XINERAMA" = xyes])
-if test "x$XINERAMA" = xyes; then
-	AC_DEFINE(XINERAMA, 1, [Support Xinerama extension])
-	AC_DEFINE(PANORAMIX, 1, [Internal define for Xinerama])
-	REQUIRED_MODULES="$REQUIRED_MODULES $XINERAMAPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $XINERAMAPROTO"
-fi
-
-AM_CONDITIONAL(XACE, [test "x$XACE" = xyes])
-if test "x$XACE" = xyes; then
-	AC_DEFINE(XACE, 1, [Build X-ACE extension])
-fi
-
-AM_CONDITIONAL(XSELINUX, [test "x$XSELINUX" = xyes])
-if test "x$XSELINUX" = xyes; then
-	if test "x$XACE" != xyes; then
-		AC_MSG_ERROR([cannot build SELinux extension without X-ACE])
-	fi
-	AC_CHECK_HEADERS([libaudit.h], [], AC_MSG_ERROR([SELinux extension requires audit system headers]))
-	AC_CHECK_LIB(audit, audit_open, [], AC_MSG_ERROR([SELinux extension requires audit system library]))
-	PKG_CHECK_MODULES([SELINUX], $LIBSELINUX)
-	SELINUX_LIBS="$SELINUX_LIBS -laudit"
-	AC_DEFINE(XSELINUX, 1, [Build SELinux extension])
-fi
-
-AM_CONDITIONAL(XCSECURITY, [test "x$XCSECURITY" = xyes])
-if test "x$XCSECURITY" = xyes; then
-	if test "x$XACE" != xyes; then
-		AC_MSG_ERROR([cannot build Security extension without X-ACE])
-	fi
-	AC_DEFINE(XCSECURITY, 1, [Build Security extension])
-fi
-
-AM_CONDITIONAL(DBE, [test "x$DBE" = xyes])
-if test "x$DBE" = xyes; then
-	AC_DEFINE(DBE, 1, [Support DBE extension])
-	DBE_LIB='$(top_builddir)/dbe/libdbe.la'
-	DBE_INC='-I$(top_srcdir)/dbe'
-fi
-
-AM_CONDITIONAL(XF86BIGFONT, [test "x$XF86BIGFONT" = xyes])
-if test "x$XF86BIGFONT" = xyes; then
-	AC_DEFINE(XF86BIGFONT, 1, [Support XF86 Big font extension])
-	REQUIRED_MODULES="$REQUIRED_MODULES $BIGFONTPROTO"
-	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $BIGFONTPROTO"
-fi
-
-AM_CONDITIONAL(DPMSExtension, [test "x$DPMSExtension" = xyes])
-if test "x$DPMSExtension" = xyes; then
-	AC_DEFINE(DPMSExtension, 1, [Support DPMS extension])
-fi
-
-AC_DEFINE(RENDER, 1, [Support RENDER extension])
-RENDER_LIB='$(top_builddir)/render/librender.la'
-RENDER_INC='-I$(top_srcdir)/render'
-
-AC_DEFINE(RANDR, 1, [Support RANDR extension])
-RANDR_LIB='$(top_builddir)/randr/librandr.la'
-RANDR_INC='-I$(top_srcdir)/randr'
-
-AC_DEFINE(XFIXES,1,[Support XFixes extension])
-FIXES_LIB='$(top_builddir)/xfixes/libxfixes.la'
-FIXES_INC='-I$(top_srcdir)/xfixes'
-
-AC_DEFINE(DAMAGE,1,[Support Damage extension])
-DAMAGE_LIB='$(top_builddir)/damageext/libdamageext.la'
-DAMAGE_INC='-I$(top_srcdir)/damageext'
-MIEXT_DAMAGE_LIB='$(top_builddir)/miext/damage/libdamage.la'
-MIEXT_DAMAGE_INC='-I$(top_srcdir)/miext/damage'
-
-# XINPUT extension is integral part of the server
-AC_DEFINE(XINPUT, 1, [Support X Input extension])
-XI_LIB='$(top_builddir)/Xi/libXi.la'
-XI_INC='-I$(top_srcdir)/Xi'
-
-AM_CONDITIONAL(XF86UTILS, test "x$XF86UTILS" = xyes)
-AM_CONDITIONAL(VGAHW, test "x$VGAHW" = xyes)
-AM_CONDITIONAL(INT10MODULE, test "x$INT10MODULE" = xyes)
-
-AC_DEFINE(SHAPE, 1, [Support SHAPE extension])
-
-if test "x$XKBPATH" = "xauto"; then
-    XKBPATH=$(pkg-config --variable datadir xkbcomp || echo ${datadir})/X11/xkb
-fi
-
-AC_DEFINE_DIR(XKB_BASE_DIRECTORY, XKBPATH, [Path to XKB data])
-AC_ARG_WITH(xkb-bin-directory,
-				AS_HELP_STRING([--with-xkb-bin-directory=DIR], [Directory containing xkbcomp program (default: auto)]),
-				[XKB_BIN_DIRECTORY="$withval"],
-				[XKB_BIN_DIRECTORY="auto"])
-
-if test "x$XKB_BIN_DIRECTORY" = "xauto"; then
-    XKB_BIN_DIRECTORY=$(pkg-config --variable bindir xkbcomp)
-    if test -z $XKB_BIN_DIRECTORY; then
-        XKB_BIN_DIRECTORY="$bindir"
-    fi
-fi
-
-AC_DEFINE_DIR(XKB_BIN_DIRECTORY, XKB_BIN_DIRECTORY, [Path to XKB bin dir])
-
-dnl Make sure XKM_OUTPUT_DIR is an absolute path
-XKBOUTPUT_FIRSTCHAR=`echo $XKBOUTPUT | cut -b 1`
-if [[ x$XKBOUTPUT_FIRSTCHAR != x/ -a x$XKBOUTPUT_FIRSTCHAR != 'x$' ]] ; then
-   XKBOUTPUT="$XKB_BASE_DIRECTORY/$XKBOUTPUT"
-fi
-
-dnl XKM_OUTPUT_DIR (used in code) must end in / or file names get hosed
-dnl XKB_COMPILED_DIR (used in Makefiles) must not or install-sh gets confused
-
-XKBOUTPUT=`echo $XKBOUTPUT/ | $SED 's|/*$|/|'`
-XKB_COMPILED_DIR=`echo $XKBOUTPUT | $SED 's|/*$||'`
-AC_DEFINE_DIR(XKM_OUTPUT_DIR, XKBOUTPUT, [Path to XKB output dir])
-AC_SUBST(XKB_COMPILED_DIR)
-
-if test "x$XKB_DFLT_RULES" = x; then
-    case $host_os in
-    linux*)
-        dnl doesn't take AutoAddDevices into account, but whatever.
-        XKB_DFLT_RULES="evdev"
-        ;;
-    *)
-        XKB_DFLT_RULES="base"
-        ;;
-    esac
-fi
-AC_DEFINE_UNQUOTED(XKB_DFLT_RULES, ["$XKB_DFLT_RULES"], [Default XKB ruleset])
-AC_DEFINE_UNQUOTED(XKB_DFLT_MODEL, ["$XKB_DFLT_MODEL"], [Default XKB model])
-AC_DEFINE_UNQUOTED(XKB_DFLT_LAYOUT, ["$XKB_DFLT_LAYOUT"], [Default XKB layout])
-AC_DEFINE_UNQUOTED(XKB_DFLT_VARIANT, ["$XKB_DFLT_VARIANT"], [Default XKB variant])
-AC_DEFINE_UNQUOTED(XKB_DFLT_OPTIONS, ["$XKB_DFLT_OPTIONS"], [Default XKB options])
-AC_SUBST([XKB_DFLT_RULES])
-AC_SUBST([XKB_DFLT_MODEL])
-AC_SUBST([XKB_DFLT_LAYOUT])
-AC_SUBST([XKB_DFLT_VARIANT])
-AC_SUBST([XKB_DFLT_OPTIONS])
-
-XKB_LIB='$(top_builddir)/xkb/libxkb.la'
-XKB_STUB_LIB='$(top_builddir)/xkb/libxkbstubs.la'
-REQUIRED_MODULES="$REQUIRED_MODULES xkbfile"
-
-PKG_CHECK_MODULES([XDMCP], [xdmcp], [have_libxdmcp="yes"], [have_libxdmcp="no"])
-if test "x$XDMCP" = xauto; then
-	if test "x$have_libxdmcp" = xyes; then
-		XDMCP=yes
-	else
-		XDMCP=no
-	fi
-fi
-if test "x$XDMAUTH" = xauto; then
-	if test "x$have_libxdmcp" = xyes; then
-		XDMAUTH=yes
-	else
-		XDMAUTH=no
-	fi
-fi
-
-AM_CONDITIONAL(XDMCP, [test "x$XDMCP" = xyes])
-if test "x$XDMCP" = xyes; then
-	AC_DEFINE(XDMCP, 1, [Support XDM Control Protocol])
-	REQUIRED_LIBS="$REQUIRED_LIBS xdmcp"
-	XDMCP_MODULES="xdmcp"
-fi
-
-AM_CONDITIONAL(XDMAUTH, [test "x$XDMAUTH" = xyes])
-if test "x$XDMAUTH" = xyes; then
-	AC_DEFINE(HASXDMAUTH,1,[Support XDM-AUTH*-1])
-	if ! test "x$XDMCP" = xyes; then
-		REQUIRED_LIBS="$REQUIRED_LIBS xdmcp"
-		XDMCP_MODULES="xdmcp"
-	fi
-fi
-
-if test "x$XF86VIDMODE" = xauto; then
-	PKG_CHECK_EXISTS($VIDMODEPROTO, [XF86VIDMODE=yes], [XF86VIDMODE=no])
-fi
-if test "x$XF86VIDMODE" = xyes; then
-	AC_DEFINE(XF86VIDMODE, 1, [Support XFree86 Video Mode extension])
-fi
-AM_CONDITIONAL([XF86VIDMODE], [test "x$XF86VIDMODE" = xyes])
-
-AC_DEFINE_DIR(COMPILEDDEFAULTFONTPATH, FONTPATH, [Default font path])
-AC_DEFINE_DIR(SERVER_MISC_CONFIG_PATH, SERVERCONFIG, [Server miscellaneous config path])
-AC_DEFINE_DIR(BASE_FONT_PATH, FONTROOTDIR, [Default base font path])
-dridriverdir=`$PKG_CONFIG --variable=dridriverdir dri`
-AC_DEFINE_DIR(DRI_DRIVER_PATH, dridriverdir, [Default DRI driver path])
-AC_DEFINE_UNQUOTED(XVENDORNAME, ["$VENDOR_NAME"], [Vendor name])
-AC_DEFINE_UNQUOTED(XVENDORNAMESHORT, ["$VENDOR_NAME_SHORT"], [Short vendor name])
-AC_DEFINE_UNQUOTED(XORG_MAN_VERSION, ["$VENDOR_MAN_VERSION"], [Vendor man version])
-AC_DEFINE_UNQUOTED(BUILDERADDR, ["$BUILDERADDR"], [Builder address])
-
-AC_DEFINE_UNQUOTED(BUILDERSTRING, ["$BUILDERSTRING"], [Builder string])
-
-AC_SUBST([VENDOR_NAME_SHORT])
-AC_DEFINE_UNQUOTED(VENDOR_NAME, ["$VENDOR_NAME"], [Vendor name])
-AC_DEFINE_UNQUOTED(VENDOR_NAME_SHORT, ["$VENDOR_NAME_SHORT"], [Vendor name])
-AC_DEFINE_UNQUOTED(VENDOR_RELEASE, [$VENDOR_RELEASE], [Vendor release])
-AC_DEFINE_UNQUOTED(VENDOR_MAN_VERSION, ["$VENDOR_MAN_VERSION"], [Vendor man version])
-
-if test "x$DEBUGGING" = xyes; then
-       AC_DEFINE(DEBUG, 1, [Enable debugging code])
-fi
-AM_CONDITIONAL(DEBUG, [test "x$DEBUGGING" = xyes])
-
-AC_DEFINE(XTEST, 1, [Support XTest extension])
-AC_DEFINE(XSYNC, 1, [Support XSync extension])
-AC_DEFINE(XCMISC, 1, [Support XCMisc extension])
-AC_DEFINE(BIGREQS, 1, [Support BigRequests extension])
-
-if test "x$SPECIAL_DTRACE_OBJECTS" = "xyes" ; then
-  DIX_LIB='$(top_builddir)/dix/dix.O'
-  OS_LIB='$(top_builddir)/os/os.O $(SHA1_LIBS) $(DLOPEN_LIBS) $(LIBUNWIND_LIBS)'
-else
-  DIX_LIB='$(top_builddir)/dix/libdix.la'
-  OS_LIB='$(top_builddir)/os/libos.la'
-fi
-AC_SUBST([DIX_LIB])
-AC_SUBST([OS_LIB])
-
-MAIN_LIB='$(top_builddir)/dix/libmain.la'
-AC_SUBST([MAIN_LIB])
-
-MI_LIB='$(top_builddir)/mi/libmi.la'
-MI_EXT_LIB='$(top_builddir)/mi/libmiext.la'
-MI_INC='-I$(top_srcdir)/mi'
-FB_LIB='$(top_builddir)/fb/libfb.la'
-FB_INC='-I$(top_srcdir)/fb'
-MIEXT_SHADOW_INC='-I$(top_srcdir)/miext/shadow'
-MIEXT_SHADOW_LIB='$(top_builddir)/miext/shadow/libshadow.la'
-MIEXT_SYNC_INC='-I$(top_srcdir)/miext/sync'
-MIEXT_SYNC_LIB='$(top_builddir)/miext/sync/libsync.la'
-CORE_INCS='-I$(top_srcdir)/include -I$(top_builddir)/include'
-
-# SHA1 hashing
-AC_ARG_WITH([sha1],
-            [AS_HELP_STRING([--with-sha1=libc|libmd|libnettle|libgcrypt|libcrypto|libsha1|CommonCrypto|CryptoAPI],
-                            [choose SHA1 implementation])])
-AC_CHECK_FUNC([SHA1Init], [HAVE_SHA1_IN_LIBC=yes])
-if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_LIBC" = xyes; then
-	with_sha1=libc
-fi
-if test "x$with_sha1" = xlibc && test "x$HAVE_SHA1_IN_LIBC" != xyes; then
-	AC_MSG_ERROR([libc requested but not found])
-fi
-if test "x$with_sha1" = xlibc; then
-	AC_DEFINE([HAVE_SHA1_IN_LIBC], [1],
-		[Use libc SHA1 functions])
-	SHA1_LIBS=""
-fi
-AC_CHECK_FUNC([CC_SHA1_Init], [HAVE_SHA1_IN_COMMONCRYPTO=yes])
-if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_COMMONCRYPTO" = xyes; then
-	with_sha1=CommonCrypto
-fi
-if test "x$with_sha1" = xCommonCrypto && test "x$HAVE_SHA1_IN_COMMONCRYPTO" != xyes; then
-	AC_MSG_ERROR([CommonCrypto requested but not found])
-fi
-if test "x$with_sha1" = xCommonCrypto; then
-	AC_DEFINE([HAVE_SHA1_IN_COMMONCRYPTO], [1],
-		[Use CommonCrypto SHA1 functions])
-	SHA1_LIBS=""
-fi
-dnl stdcall functions cannot be tested with AC_CHECK_LIB
-AC_CHECK_HEADER([wincrypt.h], [HAVE_SHA1_IN_CRYPTOAPI=yes], [], [#include <windows.h>])
-if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_CRYPTOAPI" = xyes; then
-	with_sha1=CryptoAPI
-fi
-if test "x$with_sha1" = xCryptoAPI && test "x$HAVE_SHA1_IN_CRYPTOAPI" != xyes; then
-	AC_MSG_ERROR([CryptoAPI requested but not found])
-fi
-if test "x$with_sha1" = xCryptoAPI; then
-	AC_DEFINE([HAVE_SHA1_IN_CRYPTOAPI], [1],
-		[Use CryptoAPI SHA1 functions])
-	SHA1_LIBS=""
-fi
-AC_CHECK_LIB([md], [SHA1Init], [HAVE_LIBMD=yes])
-if test "x$with_sha1" = x && test "x$HAVE_LIBMD" = xyes; then
-	with_sha1=libmd
-fi
-if test "x$with_sha1" = xlibmd && test "x$HAVE_LIBMD" != xyes; then
-	AC_MSG_ERROR([libmd requested but not found])
-fi
-if test "x$with_sha1" = xlibmd; then
-	AC_DEFINE([HAVE_SHA1_IN_LIBMD], [1],
-	          [Use libmd SHA1 functions])
-	SHA1_LIBS=-lmd
-fi
-PKG_CHECK_MODULES([LIBSHA1], [libsha1], [HAVE_LIBSHA1=yes], [HAVE_LIBSHA1=no])
-if test "x$with_sha1" = x && test "x$HAVE_LIBSHA1" = xyes; then
-   with_sha1=libsha1
-fi
-if test "x$with_sha1" = xlibsha1 && test "x$HAVE_LIBSHA1" != xyes; then
-	AC_MSG_ERROR([libsha1 requested but not found])
-fi
-if test "x$with_sha1" = xlibsha1; then
-	AC_DEFINE([HAVE_SHA1_IN_LIBSHA1], [1],
-	          [Use libsha1 for SHA1])
-	SHA1_LIBS=-lsha1
-fi
-AC_CHECK_LIB([nettle], [nettle_sha1_init], [HAVE_LIBNETTLE=yes])
-if test "x$with_sha1" = x && test "x$HAVE_LIBNETTLE" = xyes; then
-	with_sha1=libnettle
-fi
-if test "x$with_sha1" = xlibnettle && test "x$HAVE_LIBNETTLE" != xyes; then
-	AC_MSG_ERROR([libnettle requested but not found])
-fi
-if test "x$with_sha1" = xlibnettle; then
-	AC_DEFINE([HAVE_SHA1_IN_LIBNETTLE], [1],
-	          [Use libnettle SHA1 functions])
-	SHA1_LIBS=-lnettle
-fi
-AC_CHECK_LIB([gcrypt], [gcry_md_open], [HAVE_LIBGCRYPT=yes])
-if test "x$with_sha1" = x && test "x$HAVE_LIBGCRYPT" = xyes; then
-	with_sha1=libgcrypt
-fi
-if test "x$with_sha1" = xlibgcrypt && test "x$HAVE_LIBGCRYPT" != xyes; then
-	AC_MSG_ERROR([libgcrypt requested but not found])
-fi
-if test "x$with_sha1" = xlibgcrypt; then
-	AC_DEFINE([HAVE_SHA1_IN_LIBGCRYPT], [1],
-	          [Use libgcrypt SHA1 functions])
-	SHA1_LIBS=-lgcrypt
-fi
-# We don't need all of the OpenSSL libraries, just libcrypto
-AC_CHECK_LIB([crypto], [SHA1_Init], [HAVE_LIBCRYPTO=yes])
-PKG_CHECK_MODULES([OPENSSL], [openssl], [HAVE_OPENSSL_PKC=yes],
-                  [HAVE_OPENSSL_PKC=no])
-if test "x$HAVE_LIBCRYPTO" = xyes || test "x$HAVE_OPENSSL_PKC" = xyes; then
-	if test "x$with_sha1" = x; then
-		with_sha1=libcrypto
-	fi
-else
-	if test "x$with_sha1" = xlibcrypto; then
-		AC_MSG_ERROR([OpenSSL libcrypto requested but not found])
-	fi
-fi
-if test "x$with_sha1" = xlibcrypto; then
-	if test "x$HAVE_LIBCRYPTO" = xyes; then
-		SHA1_LIBS=-lcrypto
-	else
-		SHA1_LIBS="$OPENSSL_LIBS"
-		SHA1_CFLAGS="$OPENSSL_CFLAGS"
-	fi
-fi
-AC_MSG_CHECKING([for SHA1 implementation])
-if test "x$with_sha1" = x; then
-	AC_MSG_ERROR([No suitable SHA1 implementation found])
-fi
-AC_MSG_RESULT([$with_sha1])
-AC_SUBST(SHA1_LIBS)
-AC_SUBST(SHA1_CFLAGS)
-
-PKG_CHECK_MODULES([XSERVERCFLAGS], [$REQUIRED_MODULES $REQUIRED_LIBS])
-PKG_CHECK_MODULES([XSERVERLIBS], [$REQUIRED_LIBS])
-
-PKG_CHECK_MODULES(LIBUNWIND, libunwind, [HAVE_LIBUNWIND=yes], [HAVE_LIBUNWIND=no])
-if test "x$LIBUNWIND" = "xauto"; then
-    LIBUNWIND="$HAVE_LIBUNWIND"
-fi
-
-if test "x$LIBUNWIND" = "xyes"; then
-    if test "x$HAVE_LIBUNWIND" != "xyes"; then
-        AC_MSG_ERROR([libunwind requested but not installed.])
-    fi
-    AC_DEFINE(HAVE_LIBUNWIND, 1, [Have libunwind support])
-fi
-
-AM_CONDITIONAL(HAVE_LIBUNWIND, [test "x$LIBUNWIND" = xyes])
-
-# Autotools has some unfortunate issues with library handling.  In order to
-# get a server to rebuild when a dependency in the tree is changed, it must
-# be listed in SERVERNAME_DEPENDENCIES.  However, no system libraries may be
-# listed there, or some versions of autotools will break (especially if a -L
-# is required to find the library).  So, we keep two sets of libraries
-# detected: NAMESPACE_LIBS for in-tree libraries to be linked against, which
-# will go into the _DEPENDENCIES and _LDADD of the server, and
-# NAMESPACE_SYS_LIBS which will go into only the _LDADD.  The
-# NAMESPACEMODULES_LIBS detected from pkgconfig should always go in
-# NAMESPACE_SYS_LIBS.
-#
-# XSERVER_LIBS is the set of in-tree libraries which all servers require.
-# XSERVER_SYS_LIBS is the set of out-of-tree libraries which all servers
-# require.
-#
-XSERVER_CFLAGS="${XSERVER_CFLAGS} ${XSERVERCFLAGS_CFLAGS}"
-XSERVER_LIBS="$DIX_LIB $MI_LIB $OS_LIB"
-XSERVER_SYS_LIBS="${XSERVERLIBS_LIBS} ${SYS_LIBS} ${LIBS}"
-AC_SUBST([XSERVER_LIBS])
-AC_SUBST([XSERVER_SYS_LIBS])
-
-UTILS_SYS_LIBS="${SYS_LIBS}"
-AC_SUBST([UTILS_SYS_LIBS])
-
-# The Xorg binary needs to export symbols so that they can be used from modules
-# Some platforms require extra flags to do this.   libtool should set the
-# necessary flags for each platform when -export-dynamic is passed to it.
-LD_EXPORT_SYMBOLS_FLAG="-export-dynamic"
-LD_NO_UNDEFINED_FLAG=
-XORG_DRIVER_LIBS=
-case "$host_os" in
-    cygwin*)
-	LD_EXPORT_SYMBOLS_FLAG="-Wl,--export-all,--out-implib,lib\$@.a"
-	LD_NO_UNDEFINED_FLAG="-no-undefined -Wl,\$(top_builddir)/hw/xfree86/libXorg.exe.a"
-	XORG_DRIVER_LIBS="-lXorg.exe -L\${moduledir} -lshadow -lfb -no-undefined"
-	CYGWIN=yes
-	;;
-    solaris*)
-	# We use AC_LINK_IFELSE to generate a temporary program conftest$EXEEXT
-	# that we can link against for testing if the system linker is new
-	# enough to support -z parent=<program> for verifying loadable modules
-	# are only calling functions defined in either the loading program or
-	# the libraries they're linked with.
-	AC_LINK_IFELSE(
-	    [AC_LANG_SOURCE([int main(int argc, char **argv) { return 0; }])],
-	    [mv conftest$EXEEXT conftest.parent
-	     XORG_CHECK_LINKER_FLAGS([-Wl,-z,parent=conftest.parent -G],
-		[LD_NO_UNDEFINED_FLAG="-Wl,-z,defs -Wl,-z,parent=\$(top_builddir)/hw/xfree86/Xorg"
-# Not set yet, since this gets exported in xorg-server.pc to all the drivers,
-# and they're not all fixed to build correctly with it yet.
-#		 XORG_DRIVER_LIBS="-Wl,-z,defs -Wl,-z,parent=${bindir}/Xorg"
-         ],[],
-		[AC_LANG_SOURCE([extern int main(int argc, char **argv);
-			int call_main(void) { return main(0, (void *)0); }])])
-	     rm -f conftest.parent
-	    ])
-	;;
-esac
-AC_SUBST([LD_EXPORT_SYMBOLS_FLAG])
-AC_SUBST([LD_NO_UNDEFINED_FLAG])
-AC_SUBST([XORG_DRIVER_LIBS])
-AM_CONDITIONAL([CYGWIN], [test x"$CYGWIN" = xyes])
-AM_CONDITIONAL([NO_UNDEFINED], [test x"$LD_NO_UNDEFINED_FLAG" != x])
-
-dnl Imake defines SVR4 on SVR4 systems, and many files check for it, so
-dnl we need to replicate that here until those can all be fixed
-AC_MSG_CHECKING([if SVR4 needs to be defined])
-AC_EGREP_CPP([I_AM_SVR4],[
-#if defined(SVR4) || defined(__svr4__) || defined(__SVR4)
- I_AM_SVR4
-#endif
-],[
-AC_DEFINE([SVR4],1,[Define to 1 on systems derived from System V Release 4])
-AC_MSG_RESULT([yes])], AC_MSG_RESULT([no]))
-
-XSERVER_CFLAGS="$XSERVER_CFLAGS $CORE_INCS $XEXT_INC $COMPOSITE_INC $DAMAGE_INC $FIXES_INC $XI_INC $MI_INC $MIEXT_SYNC_INC $MIEXT_SHADOW_INC $MIEXT_LAYER_INC $MIEXT_DAMAGE_INC $RENDER_INC $RANDR_INC $FB_INC $DBE_INC $PRESENT_INC"
-
-dnl ---------------------------------------------------------------------------
-dnl DDX section.
-dnl ---------------------------------------------------------------------------
-
-dnl Xvfb DDX
-
-AC_MSG_CHECKING([whether to build Xvfb DDX])
-AC_MSG_RESULT([$XVFB])
-AM_CONDITIONAL(XVFB, [test "x$XVFB" = xyes])
-
-if test "x$XVFB" = xyes; then
-	XVFB_LIBS="$FB_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $DRI3_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB"
-	XVFB_SYS_LIBS="$XVFBMODULES_LIBS $GLX_SYS_LIBS"
-	AC_SUBST([XVFB_LIBS])
-	AC_SUBST([XVFB_SYS_LIBS])
-fi
-
-
-dnl Xnest DDX
-
-PKG_CHECK_MODULES(XNESTMODULES, [$LIBXEXT x11 xau $XDMCP_MODULES], [have_xnest=yes], [have_xnest=no])
-AC_MSG_CHECKING([whether to build Xnest DDX])
-if test "x$XNEST" = xauto; then
-	XNEST="$have_xnest"
-fi
-AC_MSG_RESULT([$XNEST])
-AM_CONDITIONAL(XNEST, [test "x$XNEST" = xyes])
-
-if test "x$XNEST" = xyes; then
-	if test "x$have_xnest" = xno; then
-		AC_MSG_ERROR([Xnest build explicitly requested, but required modules not found.])
-	fi
-	XNEST_LIBS="$FB_LIB $FIXES_LIB $MI_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $DAMAGE_LIB  $DRI3_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $RENDER_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $MAIN_LIB $DIX_LIB $OS_LIB"
-	XNEST_SYS_LIBS="$XNESTMODULES_LIBS $GLX_SYS_LIBS"
-	AC_SUBST([XNEST_LIBS])
-	AC_SUBST([XNEST_SYS_LIBS])
-fi
-
-
-dnl Xorg DDX
-
-AC_MSG_CHECKING([whether to build Xorg DDX])
-if test "x$XORG" = xauto; then
-	XORG="yes"
-	case $host_os in
-		cygwin*) XORG="no" ;;
-		mingw*)  XORG="no" ;;
-		darwin*) XORG="no" ;;
-	esac
-fi
-AC_MSG_RESULT([$XORG])
-
-if test "x$XORG" = xyes; then
-	PKG_CHECK_MODULES([LIBXCVT], $LIBXCVT)
-
-	XORG_DDXINCS='-I$(top_srcdir)/hw/xfree86 -I$(top_srcdir)/hw/xfree86/include -I$(top_srcdir)/hw/xfree86/common'
-	XORG_OSINCS='-I$(top_srcdir)/hw/xfree86/os-support -I$(top_srcdir)/hw/xfree86/os-support/bus -I$(top_srcdir)/os'
-	XORG_INCS="$XORG_DDXINCS $XORG_OSINCS"
-	XORG_CFLAGS="$XORGSERVER_CFLAGS $LIBXCVT_CFLAGS -DHAVE_XORG_CONFIG_H"
-	XORG_LIBS="$COMPOSITE_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $DRI3_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $XI_LIB $XKB_LIB"
-	XORG_SYS_LIBS="$XORG_SYS_LIBS $LIBXCVT_LIBS"
-
-	dnl ==================================================================
-	dnl symbol visibility
-	symbol_visibility=
-	have_visibility=disabled
-	if test x$SYMBOL_VISIBILITY != xno; then
-	    AC_MSG_CHECKING(for symbol visibility support)
-	    if test x$GCC = xyes; then
-		VISIBILITY_CFLAGS="-fvisibility=hidden"
-	    else
-		if test x$SUNCC = xyes; then
-		    VISIBILITY_CFLAGS="-xldscope=hidden"
-		else
-		    have_visibility=no
-		fi
-	    fi
-	    if test x$have_visibility != xno; then
-		save_CFLAGS="$CFLAGS"
-		proto_inc=`$PKG_CONFIG --cflags xproto`
-		CFLAGS="$CFLAGS $VISIBILITY_CFLAGS $proto_inc"
-		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
-		    [#include <X11/Xfuncproto.h>
-		     extern _X_HIDDEN int hidden_int;
-		     extern _X_EXPORT int public_int;
-		     extern _X_HIDDEN int hidden_int_func(void);
-		     extern _X_EXPORT int public_int_func(void);]],
-		    [])],
-		    have_visibility=yes,
-		    have_visibility=no)
-		CFLAGS=$save_CFLAGS
-	    fi
-	    AC_MSG_RESULT([$have_visibility])
-	    if test x$have_visibility != xno; then
-		symbol_visibility=$VISIBILITY_CFLAGS
-		XORG_CFLAGS="$XORG_CFLAGS $VISIBILITY_CFLAGS"
-		XSERVER_CFLAGS="$XSERVER_CFLAGS $VISIBILITY_CFLAGS"
-	    fi
-	fi
-	dnl added to xorg-server.pc
-	AC_SUBST([symbol_visibility])
-	dnl ===================================================================
-
-	dnl ===================================================================
-	dnl ================= beginning of PCI configuration ==================
-	dnl ===================================================================
-	xorg_bus_bsdpci=no
-	xorg_bus_sparc=no
-
-	AC_MSG_CHECKING([whether to build Xorg PCI functions])
-	if test "x$PCI" = xyes; then
-		PKG_CHECK_MODULES([PCIACCESS], $LIBPCIACCESS)
-		SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $LIBPCIACCESS"
-		XORG_SYS_LIBS="$XORG_SYS_LIBS $PCIACCESS_LIBS $LIBDRM_LIBS"
-		XORG_CFLAGS="$XORG_CFLAGS $PCIACCESS_CFLAGS $LIBDRM_CFLAGS"
-
-		AC_DEFINE(XSERVER_LIBPCIACCESS, 1, [Use libpciaccess for all pci manipulation])
-		AC_DEFINE_DIR(PCI_TXT_IDS_PATH, PCI_TXT_IDS_DIR, [Default PCI text file ID path])
-		case $host_os in
-		  gnu* | freebsd* | kfreebsd*-gnu | netbsd* | openbsd* | solaris* | dragonfly*)
-			xorg_bus_bsdpci="yes"
-			;;
-		esac
-		case $host_cpu in
-		  sparc*)
-			xorg_bus_sparc="yes"
-			;;
-		esac
-	else
-		if test "x$CONFIG_UDEV_KMS" = xyes; then
-			AC_MSG_ERROR([Platform device enumeration requires libpciaccess])
-		fi
-		if test "x$INT10MODULE" = xyes && test "x$INT10" != xstub; then
-			AC_MSG_ERROR([Cannot build int10 without libpciaccess])
-		fi
-	fi
-	AC_MSG_RESULT([$PCI])
-
-	if test "x$CONFIG_UDEV_KMS" = xyes; then
-		AC_DEFINE(XSERVER_PLATFORM_BUS, 1, [X server supports platform device enumeration])
-	fi
-	AC_MSG_RESULT([$XSERVER_PLATFORM_BUS])
-	dnl ===================================================================
-	dnl ==================== end of PCI configuration =====================
-	dnl ===================================================================
-
-	case $host_os in
-	  linux*)
-		XORG_OS_SUBDIR="linux"
-		linux_acpi="no"
-		case $host_cpu in
-		  i*86|amd64*|x86_64*|ia64*)
-			linux_acpi=$enable_linux_acpi
-			;;
-		  *)
-			;;
-		esac
-		dnl APM header
-		AC_CHECK_HEADERS([linux/apm_bios.h], [linux_apm=$enable_linux_apm])
-		;;
-	  freebsd* | kfreebsd*-gnu | dragonfly*)
-		XORG_OS_SUBDIR="bsd"
-		;;
-	  netbsd*)
-		XORG_OS_SUBDIR="bsd"
-		;;
-	  openbsd*)
-		XORG_OS_SUBDIR="bsd"
-		;;
-	  solaris*)
-		XORG_OS_SUBDIR="solaris"
-		AC_CHECK_HEADERS([sys/kd.h])
-		AC_CHECK_HEADERS([sys/vt.h], [solaris_vt=yes], [solaris_vt=no])
-		# Check for minimum supported release
-		AC_MSG_CHECKING([Solaris version])
-	        OS_MINOR=`echo ${host_os}|$SED -e 's/^.*solaris2\.//' -e s'/\..*$//'`
-		if test "${OS_MINOR}" -ge 7 ; then
-	        	AC_MSG_RESULT(Solaris ${OS_MINOR})
-		else
-			AC_MSG_RESULT(Solaris `echo ${host_os}|$SED -e 's/^.*solaris//`)
-		fi
-		if test "${OS_MINOR}" -lt 8 ; then
-			AC_MSG_ERROR([This release no longer supports Solaris versions older than Solaris 8.])
-		fi
-		AC_CHECK_DECL([_LP64], [SOLARIS_64="yes"], [SOLARIS_64="no"])
-			
-		case $host_cpu in
-		  sparc*)	
-			SOLARIS_INOUT_ARCH="sparcv8plus"
-			;;
-		  i*86|x86_64*)
-			if test x$SOLARIS_64 = xyes ; then
-				SOLARIS_INOUT_ARCH="amd64"
-			else
-				SOLARIS_INOUT_ARCH="ia32"
-			fi
-			;;
-		  *)
-			AC_MSG_ERROR([Unsupported Solaris platform. Only SPARC & x86 \
-			are supported on Solaris in this release.   If you are \
-			interested in porting Xorg to your platform, please email \
-			xorg@lists.freedesktop.org.]) ;;
-		esac
-		AC_SUBST([SOLARIS_INOUT_ARCH])
-		;;
-	  gnu*)
-		XORG_OS_SUBDIR="hurd"
-		;;
-	  cygwin*)
-		XORG_OS_SUBDIR="stub"
-		;;
-	  *)
-		XORG_OS_SUBDIR="stub"
-		AC_MSG_NOTICE([m4_text_wrap(m4_join([ ],
-		[Your OS is unknown.],
-		[If you are interested in porting Xorg to your platform,],
-		[please email xorg@lists.freedesktop.org.]))])
-		;;
-	esac
-
-	if test "x$DGA" = xauto; then
-		PKG_CHECK_MODULES(DGA, $DGAPROTO, [DGA=yes], [DGA=no])
-	fi
-	if test "x$DGA" = xyes; then
-		XORG_MODULES="$XORG_MODULES $DGAPROTO"
-		PKG_CHECK_MODULES(DGA, $DGAPROTO)
-		AC_DEFINE(DGA, 1, [Support DGA extension])
-		AC_DEFINE(XFreeXDGA, 1, [Build XDGA support])
-	fi
-
-	if test "x$XF86VIDMODE" = xyes; then
-		XORG_MODULES="$XORG_MODULES $VIDMODEPROTO"
-	fi
-
-	if test -n "$XORG_MODULES"; then
-	        PKG_CHECK_MODULES(XORG_MODULES, [$XORG_MODULES])
-	        XORG_CFLAGS="$XORG_CFLAGS $XORG_MODULES_CFLAGS"
-	        XORG_SYS_LIBS="$XORG_SYS_LIBS $XORG_MODULES_LIBS"
-	fi
-
-	if test "x$DRM" = xyes -a "x$DRI2" = xyes; then
-		XORG_DRIVER_MODESETTING=yes
-	fi
-
-	AC_SUBST([XORG_LIBS])
-	AC_SUBST([XORG_SYS_LIBS])
-	AC_SUBST([XORG_INCS])
-	AC_SUBST([XORG_OS_SUBDIR])
-	AC_SUBST([XORG_CFLAGS])
-
-	dnl these only go in xorg-config.h
-	XF86CONFIGFILE="xorg.conf"
-	XF86CONFIGDIR="xorg.conf.d"
-	AC_SUBST(XF86CONFIGDIR)
-	LOGPREFIX="Xorg."
-	XDG_DATA_HOME=".local/share"
-	XDG_DATA_HOME_LOGDIR="xorg"
-	AC_DEFINE(XORG_SERVER, 1, [Building Xorg server])
-	AC_DEFINE(XORGSERVER, 1, [Building Xorg server])
-	AC_DEFINE(XFree86Server, 1, [Building XFree86 server])
-	AC_DEFINE_UNQUOTED(XORG_VERSION_CURRENT, [$VENDOR_RELEASE], [Current Xorg version])
-	AC_DEFINE(NEED_XF86_TYPES, 1, [Need XFree86 typedefs])
-	AC_DEFINE(NEED_XF86_PROTOTYPES, 1, [Need XFree86 helper functions])
-	AC_DEFINE(__XSERVERNAME__, "Xorg", [Name of X server])
-	AC_DEFINE_DIR(XCONFIGFILE, XF86CONFIGFILE, [Name of configuration file])
-	AC_DEFINE_DIR(XF86CONFIGFILE, XF86CONFIGFILE, [Name of configuration file])
-	AC_DEFINE_DIR(XCONFIGDIR, XF86CONFIGDIR, [Name of configuration directory])
-	AC_DEFINE_DIR(DEFAULT_MODULE_PATH, moduledir, [Default module search path])
-	AC_DEFINE_DIR(DEFAULT_LIBRARY_PATH, libdir, [Default library install path])
-	AC_DEFINE_DIR(DEFAULT_LOGDIR, logdir, [Default log location])
-	AC_DEFINE_DIR(DEFAULT_LOGPREFIX, LOGPREFIX, [Default logfile prefix])
-	AC_DEFINE_DIR(DEFAULT_XDG_DATA_HOME, XDG_DATA_HOME, [Default XDG_DATA dir under HOME])
-	AC_DEFINE_DIR(DEFAULT_XDG_DATA_HOME_LOGDIR, XDG_DATA_HOME_LOGDIR, [Default log dir under XDG_DATA_HOME])
-	AC_DEFINE_UNQUOTED(__VENDORDWEBSUPPORT__, ["$VENDOR_WEB"], [Vendor web address for support])
-	if test "x$VGAHW" = xyes; then
-		AC_DEFINE(WITH_VGAHW, 1, [Building vgahw module])
-	fi
-
-	driverdir="$moduledir/drivers"
-	AC_SUBST([moduledir])
-	AC_SUBST([driverdir])
-	sdkdir="$includedir/xorg"
-	extdir="$includedir/X11/extensions"
-	sysconfigdir="$datadir/X11/$XF86CONFIGDIR"
-	AC_SUBST([sdkdir])
-	AC_SUBST([extdir])
-	AC_SUBST([sysconfigdir])
-	AC_SUBST([logdir])
-
-	# stuff the ABI versions into the pc file too
-	extract_abi() {
-	    grep ^.define.*${1}_VERSION ${srcdir}/hw/xfree86/common/xf86Module.h | tr '(),' '  .' | awk '{ print $4$5 }'
-	}
-	abi_ansic=`extract_abi ANSIC`
-	abi_videodrv=`extract_abi VIDEODRV`
-	abi_xinput=`extract_abi XINPUT`
-	abi_extension=`extract_abi EXTENSION`
-	AC_SUBST([abi_ansic])
-	AC_SUBST([abi_videodrv])
-	AC_SUBST([abi_xinput])
-	AC_SUBST([abi_extension])
-fi
-AM_CONDITIONAL([XORG], [test "x$XORG" = xyes])
-AM_CONDITIONAL([XORG_BUS_PCI], [test "x$PCI" = xyes])
-AM_CONDITIONAL([XORG_BUS_BSDPCI], [test "x$xorg_bus_bsdpci" = xyes])
-AM_CONDITIONAL([XORG_BUS_SPARC], [test "x$xorg_bus_sparc" = xyes])
-AM_CONDITIONAL([LNXACPI], [test "x$linux_acpi" = xyes])
-AM_CONDITIONAL([LNXAPM], [test "x$linux_apm" = xyes])
-AM_CONDITIONAL([SOLARIS_VT], [test "x$solaris_vt" = xyes])
-AM_CONDITIONAL([DGA], [test "x$DGA" = xyes])
-AM_CONDITIONAL([XORG_BUS_PLATFORM], [test "x$CONFIG_UDEV_KMS" = xyes])
-AM_CONDITIONAL([XORG_DRIVER_MODESETTING], [test "x$XORG_DRIVER_MODESETTING" = xyes])
-AM_CONDITIONAL([XORG_DRIVER_INPUT_INPUTTEST], [test "x$XORG_DRIVER_INPUT_INPUTTEST" = xyes])
-
-dnl glamor
-if test "x$GLAMOR" = xauto; then
-	if echo "$XORG" "$XEPHYR" | grep -q yes ; then
-		GLAMOR=yes
-	fi
-fi
-
-AM_CONDITIONAL([GLAMOR], [test "x$GLAMOR" = xyes])
-
-if test "x$GLAMOR" = xyes; then
-	AC_DEFINE(GLAMOR, 1, [Build glamor])
-	PKG_CHECK_MODULES([GLAMOR], [epoxy])
-
-	PKG_CHECK_EXISTS(epoxy >= 1.4.4,
-			 [AC_DEFINE(GLAMOR_HAS_EGL_QUERY_DMABUF, 1, [Have GLAMOR_HAS_EGL_QUERY_DMABUF])],
-			 [])
-
-	PKG_CHECK_EXISTS(epoxy >= 1.5.4,
-			 [AC_DEFINE(GLAMOR_HAS_EGL_QUERY_DRIVER, 1, [Have GLAMOR_HAS_EGL_QUERY_DRIVER])],
-			 [])
-
-	PKG_CHECK_MODULES(GBM, "$LIBGBM", [GBM=yes], [GBM=no])
-	if test "x$GBM" = xyes; then
-		AC_DEFINE(GLAMOR_HAS_GBM, 1,
-			  [Build glamor with GBM-based EGL support])
-		AC_CHECK_DECL(GBM_BO_USE_LINEAR,
-			[AC_DEFINE(GLAMOR_HAS_GBM_LINEAR, 1, [Have GBM_BO_USE_LINEAR])], [],
-			[#include <stdlib.h>
-			 #include <gbm.h>])
-		dnl 17.1.0 is required for gbm_bo_create_with_modifiers
-		PKG_CHECK_EXISTS(gbm >= 17.1.0,
-				 [AC_DEFINE(GBM_BO_WITH_MODIFIERS, 1, [Have gbm_bo_create_with_modifiers])],
-				 [])
-	else
-		if test "x$XORG" = xyes; then
-			AC_MSG_ERROR([Glamor for Xorg requires $LIBGBM])
-		fi
-	fi
-fi
-AM_CONDITIONAL([GLAMOR_EGL], [test "x$GBM" = xyes])
-
-dnl XWin DDX
-
-AC_MSG_CHECKING([whether to build XWin DDX])
-if test "x$XWIN" = xauto; then
-	case $host_os in
-		cygwin*) XWIN="yes" ;;
-		mingw*) XWIN="yes" ;;
-		*) XWIN="no" ;;
-	esac
-fi
-AC_MSG_RESULT([$XWIN])
-
-if test "x$XWIN" = xyes; then
-	AC_DEFINE_DIR(DEFAULT_LOGDIR, logdir, [Default log location])
-	AC_DEFINE_UNQUOTED(XORG_VERSION_CURRENT, [$VENDOR_RELEASE], [Current Xorg version])
-	AC_DEFINE_UNQUOTED(__VENDORDWEBSUPPORT__, ["$VENDOR_WEB"], [Vendor web address for support])
-	AC_CHECK_TOOL(WINDRES, windres)
-
-	PKG_CHECK_MODULES([XWINMODULES],[xcb-aux xcb-composite xcb-image xcb-ewmh xcb-icccm xcb-xfixes])
-
-	if test "x$WINDOWSDRI" = xauto; then
-		PKG_CHECK_EXISTS([windowsdriproto], [WINDOWSDRI=yes], [WINDOWSDRI=no])
-	fi
-	if test "x$WINDOWSDRI" = xyes ; then
-		PKG_CHECK_MODULES(WINDOWSDRI, [windowsdriproto])
-	fi
-
-	case $host_os in
-		cygwin*)
-			XWIN_SERVER_NAME=XWin
-			AC_DEFINE(HAS_DEVWINDOWS,1,[Cygwin has /dev/windows for signaling new win32 messages])
-			;;
-		mingw*)
-			XWIN_SERVER_NAME=Xming
-			AC_DEFINE(RELOCATE_PROJECTROOT,1,[Make PROJECT_ROOT relative to the xserver location])
-			AC_DEFINE(HAS_WINSOCK,1,[Use Windows sockets])
-			XWIN_SYS_LIBS="-lpthread -lws2_32"
-			;;
-	esac
-
-	XWIN_LIBS="$FB_LIB $MI_LIB $FIXES_LIB $XEXT_LIB $RANDR_LIB $RENDER_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $DAMAGE_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $OS_LIB"
-	XWIN_SYS_LIBS="$XWIN_SYS_LIBS $XWINMODULES_LIBS"
-	AC_SUBST(XWIN_LIBS)
-	AC_SUBST(XWIN_SERVER_NAME)
-	AC_SUBST(XWIN_SYS_LIBS)
-
-	if test "x$DEBUGGING" = xyes; then
-		AC_DEFINE(CYGDEBUG, 1, [Simple debug messages])
-		AC_DEFINE(CYGWINDOWING_DEBUG, 1, [Debug messages for window handling])
-		AC_DEFINE(CYGMULTIWINDOW_DEBUG, 1, [Debug window manager])
-	fi
-
-	AC_DEFINE(DDXOSVERRORF, 1, [Use OsVendorVErrorF])
-	AC_DEFINE(DDXBEFORERESET, 1, [Use ddxBeforeReset ])
-
-dnl XWin requires OpenGL spec files in order to generate wrapper code for native GL functions
-	if [test "x$XWIN" = xyes && test "x$GLX" = xyes] ; then
-           AC_CHECK_PROG(PYTHON3, python3, python3)
-           if test -z "$PYTHON3"; then
-                AC_MSG_ERROR([python3 not found])
-           fi
-           AC_MSG_CHECKING(for python module lxml)
-           $PYTHON3 -c "import lxml;"
-           if test $? -ne 0 ; then
-                AC_MSG_ERROR([not found])
-           fi
-           AC_MSG_RESULT(yes)
-           if test "x$KHRONOS_SPEC_DIR" = "xauto" ; then
-		PKG_CHECK_MODULES([KHRONOS_OPENGL_REGISTRY], [khronos-opengl-registry])
-		KHRONOS_SPEC_DIR=`pkg-config khronos-opengl-registry --variable=specdir`
-           fi
-           AC_SUBST(KHRONOS_SPEC_DIR)
-	fi
-
-fi
-AM_CONDITIONAL(XWIN, [test "x$XWIN" = xyes])
-AM_CONDITIONAL(XWIN_GLX_WINDOWS, [test "x$XWIN" = xyes && test "x$GLX" = xyes])
-AM_CONDITIONAL(XWIN_WINDOWS_DRI, [test "x$XWIN" = xyes && test "x$WINDOWSDRI" = xyes])
-
-dnl Darwin / OS X DDX
-if test "x$XQUARTZ" = xyes; then
-	AC_DEFINE(XQUARTZ,1,[Have Quartz])
-	AC_DEFINE(ROOTLESS,1,[Build Rootless code])
-
-	XQUARTZ_LIBS="$FB_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $XPSTUBS_LIB $PRESENT_LIB"
-	AC_SUBST([XQUARTZ_LIBS])
-
-	AC_CHECK_LIB([Xplugin],[xp_init],[:])
-
-	CFLAGS="${CFLAGS} -DROOTLESS_WORKAROUND -DROOTLESS_SAFEALPHA -DNO_ALLOCA"
-
-	PKG_CHECK_MODULES(XPBPROXY, $APPLEWMPROTO $LIBAPPLEWM xfixes x11)
-
-        if test "x$XQUARTZ_SPARKLE" = xyes ; then
-                AC_DEFINE(XQUARTZ_SPARKLE,1,[Support application updating through sparkle.])
-        fi
-
-	if test "x$STANDALONE_XPBPROXY" = xyes ; then
-		AC_DEFINE(STANDALONE_XPBPROXY,1,[Build a standalone xpbproxy])
-	fi
-fi
-
-AM_CONDITIONAL(PSEUDORAMIX, [test "x$XQUARTZ" = xyes -o "x$XWIN" = xyes ])
-
-# Support for objc in autotools is minimal and not documented.
-OBJC='$(CC)'
-OBJCLD='$(CCLD)'
-OBJCLINK='$(LINK)'
-OBJCFLAGS='$(CFLAGS)'
-AC_SUBST([OBJC])
-AC_SUBST([OBJCCLD])
-AC_SUBST([OBJCLINK])
-AC_SUBST([OBJCFLAGS])
-# internal, undocumented automake func follows :(
-_AM_DEPENDENCIES([OBJC])
-AM_CONDITIONAL(XQUARTZ, [test "x$XQUARTZ" = xyes])
-AM_CONDITIONAL(XQUARTZ_SPARKLE, [test "x$XQUARTZ_SPARKLE" != "xno"])
-AM_CONDITIONAL(STANDALONE_XPBPROXY, [test "x$STANDALONE_XPBPROXY" = xyes])
-
-dnl kdrive DDX
-
-XEPHYR_LIBS=
-XEPHYR_INCS=
-
-AM_CONDITIONAL(KDRIVE, [test x$KDRIVE = xyes])
-
-if test "$KDRIVE" = yes; then
-    XEPHYR_REQUIRED_LIBS="xau xdmcp xcb xcb-shape xcb-render xcb-renderutil xcb-aux xcb-image xcb-icccm xcb-shm >= 1.9.3 xcb-keysyms xcb-randr xcb-xkb"
-    if test "x$XV" = xyes; then
-        XEPHYR_REQUIRED_LIBS="$XEPHYR_REQUIRED_LIBS xcb-xv"
-    fi
-    if test "x$DRI" = xyes && test "x$GLX" = xyes; then
-        XEPHYR_REQUIRED_LIBS="$XEPHYR_REQUIRED_LIBS $LIBDRM xcb-glx xcb-xf86dri > 1.6"
-    fi
-    if test "x$GLAMOR" = xyes; then
-        XEPHYR_REQUIRED_LIBS="$XEPHYR_REQUIRED_LIBS x11-xcb"
-    fi
-
-    if test "x$XEPHYR" = xauto; then
-        PKG_CHECK_MODULES(XEPHYR, $XEPHYR_REQUIRED_LIBS, [XEPHYR="yes"], [XEPHYR="no"])
-    elif test "x$XEPHYR" = xyes ; then
-        PKG_CHECK_MODULES(XEPHYR, $XEPHYR_REQUIRED_LIBS)
-    fi
-
-    # Xephyr needs nanosleep() which is in librt on Solaris
-    AC_CHECK_FUNC([nanosleep], [],
-        AC_CHECK_LIB([rt], [nanosleep], XEPHYR_LIBS="$XEPHYR_LIBS -lrt"))
-    
-    # damage shadow extension glx (NOTYET) fb mi
-    KDRIVE_INC='-I$(top_srcdir)/hw/kdrive/src'
-    KDRIVE_PURE_INCS="$KDRIVE_INC $MIEXT_SYNC_INC $MIEXT_DAMAGE_INC $MIEXT_SHADOW_INC $XEXT_INC $FB_INC $MI_INC"
-    KDRIVE_OS_INC='-I$(top_srcdir)/hw/kdrive/linux'
-    KDRIVE_INCS="$KDRIVE_PURE_INCS $KDRIVE_OS_INC"
-    
-    KDRIVE_CFLAGS="$XSERVER_CFLAGS"
-
-    KDRIVE_PURE_LIBS="$FB_LIB $MI_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $DRI3_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $OS_LIB"
-    KDRIVE_LIB='$(top_builddir)/hw/kdrive/src/libkdrive.la'
-    KDRIVE_MAIN_LIB="$MAIN_LIB"
-    KDRIVE_LOCAL_LIBS="$DIX_LIB $KDRIVE_LIB"
-    KDRIVE_LOCAL_LIBS="$KDRIVE_LOCAL_LIBS $FB_LIB $MI_LIB $KDRIVE_PURE_LIBS"
-    KDRIVE_LOCAL_LIBS="$KDRIVE_LOCAL_LIBS $KDRIVE_OS_LIB"
-    KDRIVE_LIBS="$KDRIVE_LOCAL_LIBS $XSERVER_SYS_LIBS $GLX_SYS_LIBS $DLOPEN_LIBS"
-
-    AC_SUBST([XEPHYR_LIBS])
-    AC_SUBST([XEPHYR_INCS])
-fi
-AC_SUBST([KDRIVE_INCS])
-AC_SUBST([KDRIVE_PURE_INCS])
-AC_SUBST([KDRIVE_CFLAGS])
-AC_SUBST([KDRIVE_PURE_LIBS])
-AC_SUBST([KDRIVE_MAIN_LIB])
-AC_SUBST([KDRIVE_LOCAL_LIBS])
-AC_SUBST([KDRIVE_LIBS])
-AM_CONDITIONAL(XEPHYR, [test "x$KDRIVE" = xyes && test "x$XEPHYR" = xyes])
-
-
-dnl and the rest of these are generic, so they're in config.h
-dnl 
-dnl though, thanks to the passing of some significant amount of time, the
-dnl above is probably a complete fallacy, and you should not rely on it.
-dnl but this is still actually better than imake, honest. -daniels
-
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <features.h>
-#ifndef __GLIBC__
-#error not glibc
-#endif
-]], [])], [AC_DEFINE(_GNU_SOURCE, 1,
-	[ Enable GNU and other extensions to the C environment for glibc])])
-
-AC_DEFINE_DIR(PROJECTROOT, prefix, [Overall prefix])
-AC_DEFINE_DIR(SYSCONFDIR, sysconfdir, [sysconfdir])
-
-AC_SUBST([RELEASE_DATE])
-
-DIX_CFLAGS="-DHAVE_DIX_CONFIG_H $XSERVER_CFLAGS"
-
-AC_SUBST([DIX_CFLAGS])
-
-AC_SUBST([libdir])
-AC_SUBST([exec_prefix])
-AC_SUBST([prefix])
-
-AC_CONFIG_COMMANDS([sdksyms], [touch hw/xfree86/sdksyms.dep])
-
-if test "x$CONFIG_HAL" = xno && test "x$CONFIG_UDEV" = xno; then
-    AC_MSG_WARN([
-             ***********************************************
-             Neither HAL nor udev backend will be enabled.
-             Input device hotplugging will not be available!
-             ***********************************************])
-fi
-
-AC_CONFIG_FILES([
-Makefile
-glx/Makefile
-include/Makefile
-composite/Makefile
-damageext/Makefile
-dbe/Makefile
-dix/Makefile
-doc/Makefile
-doc/dtrace/Makefile
-man/Makefile
-fb/Makefile
-glamor/Makefile
-record/Makefile
-config/Makefile
-mi/Makefile
-miext/Makefile
-miext/sync/Makefile
-miext/damage/Makefile
-miext/shadow/Makefile
-miext/rootless/Makefile
-os/Makefile
-pseudoramiX/Makefile
-randr/Makefile
-render/Makefile
-xkb/Makefile
-Xext/Makefile
-Xi/Makefile
-xfixes/Makefile
-exa/Makefile
-dri3/Makefile
-present/Makefile
-hw/Makefile
-hw/xfree86/Makefile
-hw/xfree86/Xorg.sh
-hw/xfree86/common/Makefile
-hw/xfree86/ddc/Makefile
-hw/xfree86/dixmods/Makefile
-hw/xfree86/doc/Makefile
-hw/xfree86/dri/Makefile
-hw/xfree86/dri2/Makefile
-hw/xfree86/dri2/pci_ids/Makefile
-hw/xfree86/drivers/Makefile
-hw/xfree86/drivers/inputtest/Makefile
-hw/xfree86/drivers/modesetting/Makefile
-hw/xfree86/exa/Makefile
-hw/xfree86/exa/man/Makefile
-hw/xfree86/fbdevhw/Makefile
-hw/xfree86/fbdevhw/man/Makefile
-hw/xfree86/glamor_egl/Makefile
-hw/xfree86/i2c/Makefile
-hw/xfree86/int10/Makefile
-hw/xfree86/loader/Makefile
-hw/xfree86/man/Makefile
-hw/xfree86/modes/Makefile
-hw/xfree86/os-support/Makefile
-hw/xfree86/os-support/bsd/Makefile
-hw/xfree86/os-support/bus/Makefile
-hw/xfree86/os-support/hurd/Makefile
-hw/xfree86/os-support/misc/Makefile
-hw/xfree86/os-support/linux/Makefile
-hw/xfree86/os-support/solaris/Makefile
-hw/xfree86/os-support/stub/Makefile
-hw/xfree86/parser/Makefile
-hw/xfree86/ramdac/Makefile
-hw/xfree86/shadowfb/Makefile
-hw/xfree86/vgahw/Makefile
-hw/xfree86/x86emu/Makefile
-hw/xfree86/xkb/Makefile
-hw/xfree86/utils/Makefile
-hw/xfree86/utils/man/Makefile
-hw/xfree86/utils/gtf/Makefile
-hw/vfb/Makefile
-hw/vfb/man/Makefile
-hw/xnest/Makefile
-hw/xnest/man/Makefile
-hw/xwin/Makefile
-hw/xwin/dri/Makefile
-hw/xwin/glx/Makefile
-hw/xwin/man/Makefile
-hw/xwin/winclipboard/Makefile
-hw/xquartz/Makefile
-hw/xquartz/GL/Makefile
-hw/xquartz/bundle/Makefile
-hw/xquartz/man/Makefile
-hw/xquartz/mach-startup/Makefile
-hw/xquartz/pbproxy/Makefile
-hw/xquartz/xpr/Makefile
-hw/kdrive/Makefile
-hw/kdrive/ephyr/Makefile
-hw/kdrive/ephyr/man/Makefile
-hw/kdrive/src/Makefile
-test/Makefile
-xserver.ent
-xorg-server.pc
-])
-AC_OUTPUT
diff --git a/damageext/Makefile.am b/damageext/Makefile.am
deleted file mode 100644
index 4d4cf4478..000000000
--- a/damageext/Makefile.am
+++ /dev/null
@@ -1,7 +0,0 @@
-noinst_LTLIBRARIES = libdamageext.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-libdamageext_la_SOURCES = 	\
-	damageext.c		\
-	damageextint.h
diff --git a/dbe/Makefile.am b/dbe/Makefile.am
deleted file mode 100644
index 7d034c7f7..000000000
--- a/dbe/Makefile.am
+++ /dev/null
@@ -1,12 +0,0 @@
-noinst_LTLIBRARIES = libdbe.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-if XORG
-sdk_HEADERS = dbestruct.h
-endif
-
-libdbe_la_SOURCES = \
-        dbe.c \
-        midbe.c \
-        midbe.h
diff --git a/devbook.am b/devbook.am
deleted file mode 100644
index edddc863d..000000000
--- a/devbook.am
+++ /dev/null
@@ -1,57 +0,0 @@
-#
-# Generate output formats for a single DocBook/XML with/without chapters
-#
-# Variables set by the calling Makefile:
-# noinst_DATA: developers docs are not installed
-# docbook:  the main DocBook/XML file, no chapters, appendix or image files
-# chapters: all files pulled in by an XInclude statement and images.
-#
-
-#
-# This makefile is intended for Developers Documentation and is not installed.
-# Do not use for Users docs or Specs which need to be installed and require olink support
-# Refer to http://www.x.org/releases/X11R7.6/doc/xorg-docs/ReleaseNotes.html#id2584393
-# for an explanation on documents classification.
-#
-
-# Developers documnetation is not installed
-noinst_DATA =
-
-# DocBook/XML file with chapters, appendix and images it includes
-dist_noinst_DATA = $(docbook) $(chapters)
-
-FILTER_XMLTO=$(SHELL) $(top_srcdir)/doc/filter-xmlto.sh $(XMLTO)
-
-if HAVE_STYLESHEETS
-
-XMLTO_HTML_FLAGS = 					\
-	--searchpath "$(XORG_SGML_PATH)/X11" 		\
-	--searchpath "$(abs_top_builddir)"		\
-	-x $(STYLESHEET_SRCDIR)/xorg-xhtml.xsl
-
-noinst_DATA += $(docbook:.xml=.html)
-%.html: %.xml  $(chapters)
-	$(AM_V_GEN)$(FILTER_XMLTO) $(XMLTO_HTML_FLAGS) xhtml-nochunks $<
-
-if HAVE_XMLTO_TEXT
-noinst_DATA += $(docbook:.xml=.txt)
-%.txt: %.xml $(chapters)
-	$(AM_V_GEN)$(FILTER_XMLTO) $(XMLTO_HTML_FLAGS) txt $<
-endif HAVE_XMLTO_TEXT
-
-if HAVE_FOP
-XMLTO_FO_FLAGS = 					\
-	--searchpath "$(XORG_SGML_PATH)/X11" 		\
-	--searchpath "$(abs_top_builddir)"		\
-	--stringparam img.src.path=$(abs_builddir)/	\
-	-x $(STYLESHEET_SRCDIR)/xorg-fo.xsl
-
-noinst_DATA += $(docbook:.xml=.pdf) $(docbook:.xml=.ps)
-%.pdf: %.xml $(chapters)
-	$(AM_V_GEN)$(FILTER_XMLTO) $(XMLTO_FO_FLAGS) --with-fop pdf $<
-%.ps: %.xml $(chapters)
-	$(AM_V_GEN)$(FILTER_XMLTO) $(XMLTO_FO_FLAGS) --with-fop ps $<
-endif HAVE_FOP
-endif HAVE_STYLESHEETS
-
-CLEANFILES = $(noinst_DATA)
diff --git a/dix/Makefile.am b/dix/Makefile.am
deleted file mode 100644
index e1498cd56..000000000
--- a/dix/Makefile.am
+++ /dev/null
@@ -1,62 +0,0 @@
-noinst_LTLIBRARIES = libdix.la libmain.la
-
-AM_CPPFLAGS = -I$(top_srcdir)/include
-AM_CFLAGS = $(DIX_CFLAGS)
-
-libmain_la_SOURCES =    \
-	stubmain.c
-
-libdix_la_SOURCES = 	\
-	atom.c		\
-	colormap.c	\
-	cursor.c	\
-	devices.c	\
-	dispatch.c	\
-	dispatch.h	\
-	dixfonts.c	\
-	main.c		\
-	dixutils.c	\
-	enterleave.c	\
-	enterleave.h	\
-	events.c	\
-	eventconvert.c  \
-	extension.c	\
-	gc.c		\
-	getevents.c	\
-	gestures.c	\
-	globals.c	\
-	glyphcurs.c	\
-	grabs.c		\
-	initatoms.c	\
-	inpututils.c	\
-	pixmap.c	\
-	privates.c	\
-	property.c	\
-	ptrveloc.c	\
-	region.c	\
-	registry.c	\
-	resource.c	\
-	selection.c	\
-	swaprep.c	\
-	swapreq.c	\
-	tables.c	\
-	touch.c		\
-	window.c
-
-EXTRA_DIST = buildatoms BuiltInAtoms
-
-# Install list of protocol names
-miscconfigdir = $(SERVER_MISC_CONFIG_PATH)
-dist_miscconfig_DATA = protocol.txt
-
-if SPECIAL_DTRACE_OBJECTS
-# Generate dtrace object code for probes in libdix
-dtrace-dix.o: $(top_srcdir)/include/Xserver.d libdix.la
-	$(AM_V_GEN)$(DTRACE) -G -C -o $@ -s $(top_srcdir)/include/Xserver.d $(am_libdix_la_OBJECTS:%.lo=.libs/%.o)
-
-noinst_PROGRAMS = dix.O
-
-dix_O_SOURCES =
-dix.O: dtrace-dix.o libdix.la
-	$(AM_V_GEN)ld -r -o $@ $(am_libdix_la_OBJECTS:%.lo=.libs/%.o)
-endif
diff --git a/dix/devices.c b/dix/devices.c
index 5bf956ead..5f9ce1678 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -520,6 +520,7 @@ DisableDevice(DeviceIntPtr dev, BOOL sendevent)
     }
 
     RecalculateMasterButtons(dev);
+    dev->master = NULL;
 
     return TRUE;
 }
@@ -2622,6 +2623,8 @@ AttachDevice(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr master)
     if (IsFloating(dev) && !master && dev->enabled)
         return Success;
 
+    input_lock();
+
     /* free the existing sprite. */
     if (IsFloating(dev) && dev->spriteInfo->paired == dev) {
         screen = miPointerGetScreen(dev);
@@ -2662,6 +2665,7 @@ AttachDevice(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr master)
         RecalculateMasterButtons(master);
     }
 
+    input_unlock();
     /* XXX: in theory, the MD should change back to its old, original
      * classes when the last SD is detached. Thanks to the XTEST devices,
      * we'll always have an SD attached until the MD is removed.
diff --git a/dix/dispatch.c b/dix/dispatch.c
index 460296197..efcec5c81 100644
--- a/dix/dispatch.c
+++ b/dix/dispatch.c
@@ -101,11 +101,6 @@ Equipment Corporation.
 #include <version-config.h>
 #endif
 
-#ifdef PANORAMIX_DEBUG
-#include <stdio.h>
-int ProcInitialConnection();
-#endif
-
 #include "windowstr.h"
 #include <X11/fonts/fontstruct.h>
 #include <X11/fonts/libxfont2.h>
@@ -492,10 +487,10 @@ Dispatch(void)
         if (!WaitForSomething(clients_are_ready()))
             continue;
 
-       /*****************
-	*  Handle events in round robin fashion, doing input between
-	*  each round
-	*****************/
+        /*****************
+         *  Handle events in round robin fashion, doing input between
+         *  each round
+         *****************/
 
         if (!dispatchException && clients_are_ready()) {
             client = SmartScheduleClient();
@@ -638,11 +633,11 @@ CreateConnectionBlock(void)
     if (!ConnectionInfo)
         return FALSE;
 
-    memmove(ConnectionInfo, (char *) &setup, sizeof(xConnSetup));
+    memcpy(ConnectionInfo, &setup, sizeof(xConnSetup));
     sizesofar = sizeof(xConnSetup);
     pBuf = ConnectionInfo + sizeof(xConnSetup);
 
-    memmove(pBuf, VendorString, (int) setup.nbytesVendor);
+    memcpy(pBuf, VendorString, (size_t) setup.nbytesVendor);
     sizesofar += setup.nbytesVendor;
     pBuf += setup.nbytesVendor;
     i = padding_for_int32(setup.nbytesVendor);
@@ -655,7 +650,7 @@ CreateConnectionBlock(void)
         format.depth = screenInfo.formats[i].depth;
         format.bitsPerPixel = screenInfo.formats[i].bitsPerPixel;
         format.scanLinePad = screenInfo.formats[i].scanlinePad;
-        memmove(pBuf, (char *) &format, sizeof(xPixmapFormat));
+        memcpy(pBuf, &format, sizeof(xPixmapFormat));
         pBuf += sizeof(xPixmapFormat);
         sizesofar += sizeof(xPixmapFormat);
     }
@@ -685,7 +680,7 @@ CreateConnectionBlock(void)
         root.saveUnders = FALSE;
         root.rootDepth = pScreen->rootDepth;
         root.nDepths = pScreen->numDepths;
-        memmove(pBuf, (char *) &root, sizeof(xWindowRoot));
+        memcpy(pBuf, &root, sizeof(xWindowRoot));
         sizesofar += sizeof(xWindowRoot);
         pBuf += sizeof(xWindowRoot);
 
@@ -702,7 +697,7 @@ CreateConnectionBlock(void)
             pBuf += sizesofar;
             depth.depth = pDepth->depth;
             depth.nVisuals = pDepth->numVids;
-            memmove(pBuf, (char *) &depth, sizeof(xDepth));
+            memcpy(pBuf, &depth, sizeof(xDepth));
             pBuf += sizeof(xDepth);
             sizesofar += sizeof(xDepth);
             for (k = 0; k < pDepth->numVids; k++) {
@@ -716,7 +711,7 @@ CreateConnectionBlock(void)
                 visual.redMask = pVisual->redMask;
                 visual.greenMask = pVisual->greenMask;
                 visual.blueMask = pVisual->blueMask;
-                memmove(pBuf, (char *) &visual, sizeof(xVisualType));
+                memcpy(pBuf, &visual, sizeof(xVisualType));
                 pBuf += sizeof(xVisualType);
                 sizesofar += sizeof(xVisualType);
             }
@@ -2187,7 +2182,7 @@ DoGetImage(ClientPtr client, int format, Drawable drawable,
             PixmapPtr pPix = (*pDraw->pScreen->GetWindowPixmap) (pWin);
 
             pBoundingDraw = &pPix->drawable;
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
             relx -= pPix->screen_x;
             rely -= pPix->screen_y;
 #endif
@@ -3657,11 +3652,11 @@ ProcInitialConnection(ClientPtr client)
     prefix = (xConnClientPrefix *) ((char *)stuff + sz_xReq);
     order = prefix->byteOrder;
     if (order != 'l' && order != 'B' && order != 'r' && order != 'R')
-	return client->noClientException = -1;
+        return client->noClientException = -1;
     if (((*(char *) &whichbyte) && (order == 'B' || order == 'R')) ||
-	(!(*(char *) &whichbyte) && (order == 'l' || order == 'r'))) {
-	client->swapped = TRUE;
-	SwapConnClientPrefix(prefix);
+        (!(*(char *) &whichbyte) && (order == 'l' || order == 'r'))) {
+        client->swapped = TRUE;
+        SwapConnClientPrefix(prefix);
     }
     stuff->reqType = 2;
     stuff->length += bytes_to_int32(prefix->nbytesAuthProto) +
@@ -3670,7 +3665,7 @@ ProcInitialConnection(ClientPtr client)
         swaps(&stuff->length);
     }
     if (order == 'r' || order == 'R') {
-	client->local = FALSE;
+        client->local = FALSE;
     }
     ResetCurrentRequest(client);
     return Success;
@@ -3771,28 +3766,30 @@ int
 ProcEstablishConnection(ClientPtr client)
 {
     const char *reason;
-    char *auth_proto, *auth_string;
     xConnClientPrefix *prefix;
 
     REQUEST(xReq);
 
     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
-    auth_proto = (char *) prefix + sz_xConnClientPrefix;
-    auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
 
-    if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +
-	pad_to_int32(prefix->nbytesAuthProto) +
-	pad_to_int32(prefix->nbytesAuthString))
+    if (client->swapped && !AllowByteSwappedClients) {
+        reason = "Prohibited client endianess, see the Xserver man page ";
+    } else if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +
+            pad_to_int32(prefix->nbytesAuthProto) +
+            pad_to_int32(prefix->nbytesAuthString))
         reason = "Bad length";
     else if ((prefix->majorVersion != X_PROTOCOL) ||
         (prefix->minorVersion != X_PROTOCOL_REVISION))
         reason = "Protocol version mismatch";
-    else
+    else {
+        char *auth_proto = (char *) prefix + sz_xConnClientPrefix;
+        char *auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
         reason = ClientAuthorized(client,
                                   (unsigned short) prefix->nbytesAuthProto,
                                   auth_proto,
                                   (unsigned short) prefix->nbytesAuthString,
                                   auth_string);
+    }
 
     return (SendConnSetup(client, reason));
 }
diff --git a/dix/dixfonts.c b/dix/dixfonts.c
index 58a385f71..9608e4b1f 100644
--- a/dix/dixfonts.c
+++ b/dix/dixfonts.c
@@ -293,7 +293,7 @@ doOpenFont(ClientPtr client, OFclosurePtr c)
                 err = AllocError;
                 break;
             }
-            memmove(newname, alias, newlen);
+            memcpy(newname, alias, newlen);
             c->fontname = newname;
             c->fnamelen = newlen;
             c->current_fpe = 0;
@@ -427,7 +427,7 @@ OpenFont(ClientPtr client, XID fid, Mask flags, unsigned lenfname,
         free(c);
         return BadAlloc;
     }
-    memmove(c->fontname, pfontname, lenfname);
+    memcpy(c->fontname, pfontname, lenfname);
     for (i = 0; i < num_fpes; i++) {
         c->fpe_list[i] = font_path_elements[i];
         UseFPE(c->fpe_list[i]);
@@ -641,7 +641,7 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
                     free(resolved);
                     resolved = malloc(resolvedlen + 1);
                     if (resolved)
-                        memmove(resolved, tmpname, resolvedlen + 1);
+                        memcpy(resolved, tmpname, resolvedlen + 1);
                 }
             }
 
@@ -671,7 +671,7 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
                  * is BadFontName, indicating the alias resolution
                  * is complete.
                  */
-                memmove(tmp_pattern, resolved, resolvedlen);
+                memcpy(tmp_pattern, resolved, resolvedlen);
                 if (c->haveSaved) {
                     char *tmpname;
                     int tmpnamelen;
@@ -691,11 +691,11 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
                     free(c->savedName);
                     c->savedName = malloc(namelen + 1);
                     if (c->savedName)
-                        memmove(c->savedName, name, namelen + 1);
+                        memcpy(c->savedName, name, namelen + 1);
                     c->savedNameLen = namelen;
                     aliascount = 20;
                 }
-                memmove(c->current.pattern, tmp_pattern, resolvedlen);
+                memcpy(c->current.pattern, tmp_pattern, resolvedlen);
                 c->current.patlen = resolvedlen;
                 c->current.max_names = c->names->nnames + 1;
                 c->current.current_fpe = -1;
@@ -766,7 +766,7 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
             reply.nFonts--;
         else {
             *bufptr++ = names->length[i];
-            memmove(bufptr, names->names[i], names->length[i]);
+            memcpy(bufptr, names->names[i], names->length[i]);
             bufptr += names->length[i];
         }
     }
@@ -931,7 +931,7 @@ doListFontsWithInfo(ClientPtr client, LFWIclosurePtr c)
                 free(c->savedName);
                 c->savedName = malloc(namelen + 1);
                 if (c->savedName)
-                    memmove(c->savedName, name, namelen + 1);
+                    memcpy(c->savedName, name, namelen + 1);
                 aliascount = 20;
             }
             memmove(c->current.pattern, name, namelen);
@@ -1242,7 +1242,7 @@ doPolyText(ClientPtr client, PTclosurePtr c)
                         err = BadAlloc;
                         goto bail;
                     }
-                    memmove(new_closure->data, new_closure->pElt, len);
+                    memcpy(new_closure->data, new_closure->pElt, len);
                     new_closure->pElt = new_closure->data;
                     new_closure->endReq = new_closure->pElt + len;
 
@@ -1430,7 +1430,7 @@ doImageText(ClientPtr client, ITclosurePtr c)
                 err = BadAlloc;
                 goto bail;
             }
-            memmove(data, c->data, c->nChars * itemSize);
+            memcpy(data, c->data, c->nChars * itemSize);
             c->data = data;
 
             pGC = GetScratchGC(c->pGC->depth, c->pGC->pScreen);
@@ -1784,7 +1784,7 @@ GetFontPath(ClientPtr client, int *count, int *length, unsigned char **result)
         fpe = font_path_elements[i];
         *c = fpe->name_length;
         *length += *c++;
-        memmove(c, fpe->name, fpe->name_length);
+        memcpy(c, fpe->name, fpe->name_length);
         c += fpe->name_length;
     }
     *count = num_fpes;
diff --git a/dix/enterleave.c b/dix/enterleave.c
index 033ddc212..867ec7436 100644
--- a/dix/enterleave.c
+++ b/dix/enterleave.c
@@ -365,7 +365,7 @@ CoreEnterLeaveNonLinear(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
        Case 3C: Otherwise:
        The pointer window moves from W to a window above W.
        The detail may need to be changed from Ancestor to Nonlinear or
-       vice versa depending on the the new P(W)
+       vice versa depending on the new P(W)
      */
 
     if (!HasPointer(dev, A)) {
@@ -447,7 +447,7 @@ CoreEnterLeaveToAncestor(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
        Case 3C: Otherwise:
        The pointer window moves from W to a window above W.
        The detail may need to be changed from Ancestor to Nonlinear or
-       vice versa depending on the the new P(W)
+       vice versa depending on the new P(W)
      */
     if (!HasPointer(dev, A)) {
         WindowPtr child = FirstPointerChild(A);
@@ -1053,7 +1053,7 @@ CoreFocusNonLinear(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
        Case 3C: Otherwise:
        The focus window moves from W to a window above W.
        The detail may need to be changed from Ancestor to Nonlinear or
-       vice versa depending on the the new F(W)
+       vice versa depending on the new F(W)
      */
 
     if (!HasFocus(A)) {
@@ -1141,7 +1141,7 @@ CoreFocusToAncestor(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
        Case 3C: Otherwise:
        The focus window moves from W to a window above W.
        The detail may need to be changed from Ancestor to Nonlinear or
-       vice versa depending on the the new F(W)
+       vice versa depending on the new F(W)
      */
     if (!HasFocus(A)) {
         WindowPtr child = FirstFocusChild(A);
diff --git a/dix/events.c b/dix/events.c
index 782ed35dc..86f5357e8 100644
--- a/dix/events.c
+++ b/dix/events.c
@@ -1215,7 +1215,7 @@ EnqueueEvent(InternalEvent *ev, DeviceIntPtr device)
     qe->pScreen = pSprite->hotPhys.pScreen;
     qe->months = currentTime.months;
     qe->event = (InternalEvent *) (qe + 1);
-    memcpy(qe->event, event, eventlen);
+    CopyPartialInternalEvent(qe->event, (InternalEvent *)event);
     xorg_list_append(&qe->next, &syncEvents.pending);
 }
 
diff --git a/dix/extension.c b/dix/extension.c
index 9c158ba93..dce6a91da 100644
--- a/dix/extension.c
+++ b/dix/extension.c
@@ -293,7 +293,7 @@ ProcListExtensions(ClientPtr client)
                 continue;
 
             *bufptr++ = len = strlen(extensions[i]->name);
-            memmove(bufptr, extensions[i]->name, len);
+            memcpy(bufptr, extensions[i]->name, len);
             bufptr += len;
         }
     }
diff --git a/dix/main.c b/dix/main.c
index bfc8addbe..5964120c6 100644
--- a/dix/main.c
+++ b/dix/main.c
@@ -195,8 +195,8 @@ dix_main(int argc, char *argv[], char *envp[])
 
         for (i = 0; i < screenInfo.numGPUScreens; i++) {
             ScreenPtr pScreen = screenInfo.gpuscreens[i];
-            if (!CreateScratchPixmapsForScreen(pScreen))
-                FatalError("failed to create scratch pixmaps");
+            if (!PixmapScreenInit(pScreen))
+                FatalError("failed to create screen pixmap properties");
             if (pScreen->CreateScreenResources &&
                 !(*pScreen->CreateScreenResources) (pScreen))
                 FatalError("failed to create screen resources");
@@ -205,8 +205,8 @@ dix_main(int argc, char *argv[], char *envp[])
         for (i = 0; i < screenInfo.numScreens; i++) {
             ScreenPtr pScreen = screenInfo.screens[i];
 
-            if (!CreateScratchPixmapsForScreen(pScreen))
-                FatalError("failed to create scratch pixmaps");
+            if (!PixmapScreenInit(pScreen))
+                FatalError("failed to create screen pixmap properties");
             if (pScreen->CreateScreenResources &&
                 !(*pScreen->CreateScreenResources) (pScreen))
                 FatalError("failed to create screen resources");
@@ -305,7 +305,6 @@ dix_main(int argc, char *argv[], char *envp[])
 
         for (i = screenInfo.numGPUScreens - 1; i >= 0; i--) {
             ScreenPtr pScreen = screenInfo.gpuscreens[i];
-            FreeScratchPixmapsForScreen(pScreen);
             dixFreeScreenSpecificPrivates(pScreen);
             (*pScreen->CloseScreen) (pScreen);
             dixFreePrivates(pScreen->devPrivates, PRIVATE_SCREEN);
@@ -314,7 +313,6 @@ dix_main(int argc, char *argv[], char *envp[])
         }
 
         for (i = screenInfo.numScreens - 1; i >= 0; i--) {
-            FreeScratchPixmapsForScreen(screenInfo.screens[i]);
             FreeGCperDepth(i);
             FreeDefaultStipple(i);
             dixFreeScreenSpecificPrivates(screenInfo.screens[i]);
diff --git a/dix/pixmap.c b/dix/pixmap.c
index 5a0146bbb..a58795c78 100644
--- a/dix/pixmap.c
+++ b/dix/pixmap.c
@@ -44,8 +44,13 @@ from The Open Group.
 #include "picturestr.h"
 #include "randrstr.h"
 /*
- *  Scratch pixmap management and device independent pixmap allocation
- *  function.
+ * Scratch pixmap APIs are provided for source and binary compatability.  In
+ * older versions, DIX would store a freed scratch pixmap for future use.  This
+ * optimization is not really that impactful on modern systems with decent
+ * system heap management and modern CPUs, and it interferes with memory
+ * analysis tools such as ASan, malloc history, etc.
+ *
+ * Now, these entry points just allocte/free pixmaps.
  */
 
 /* callable by ddx */
@@ -53,14 +58,7 @@ PixmapPtr
 GetScratchPixmapHeader(ScreenPtr pScreen, int width, int height, int depth,
                        int bitsPerPixel, int devKind, void *pPixData)
 {
-    PixmapPtr pPixmap = pScreen->pScratchPixmap;
-
-    if (pPixmap)
-        pScreen->pScratchPixmap = NULL;
-    else
-        /* width and height of 0 means don't allocate any pixmap data */
-        pPixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, 0);
-
+    PixmapPtr pPixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, 0);
     if (pPixmap) {
         if ((*pScreen->ModifyPixmapHeader) (pPixmap, width, height, depth,
                                             bitsPerPixel, devKind, pPixData))
@@ -76,17 +74,13 @@ FreeScratchPixmapHeader(PixmapPtr pPixmap)
 {
     if (pPixmap) {
         ScreenPtr pScreen = pPixmap->drawable.pScreen;
-
-        pPixmap->devPrivate.ptr = NULL; /* lest ddx chases bad ptr */
-        if (pScreen->pScratchPixmap)
-            (*pScreen->DestroyPixmap) (pPixmap);
-        else
-            pScreen->pScratchPixmap = pPixmap;
+        pPixmap->devPrivate.ptr = NULL; /* help catch/avoid heap-use-after-free */
+        (*pScreen->DestroyPixmap)(pPixmap);
     }
 }
 
 Bool
-CreateScratchPixmapsForScreen(ScreenPtr pScreen)
+PixmapScreenInit(ScreenPtr pScreen)
 {
     unsigned int pixmap_size;
 
@@ -94,17 +88,9 @@ CreateScratchPixmapsForScreen(ScreenPtr pScreen)
     pScreen->totalPixmapSize =
         BitmapBytePad(pixmap_size * 8);
 
-    /* let it be created on first use */
-    pScreen->pScratchPixmap = NULL;
     return TRUE;
 }
 
-void
-FreeScratchPixmapsForScreen(ScreenPtr pScreen)
-{
-    FreeScratchPixmapHeader(pScreen->pScratchPixmap);
-}
-
 /* callable by ddx */
 PixmapPtr
 AllocatePixmap(ScreenPtr pScreen, int pixDataSize)
@@ -262,12 +248,11 @@ PixmapStopDirtyTracking(DrawablePtr src, PixmapPtr secondary_dst)
     return TRUE;
 }
 
-static void
-PixmapDirtyCopyArea(PixmapPtr dst,
-                    PixmapDirtyUpdatePtr dirty,
+void
+PixmapDirtyCopyArea(PixmapPtr dst, DrawablePtr src,
+                    int x, int y, int dst_x, int dst_y,
                     RegionPtr dirty_region)
 {
-    DrawablePtr src = dirty->src;
     ScreenPtr pScreen = src->pScreen;
     int n;
     BoxPtr b;
@@ -294,9 +279,8 @@ PixmapDirtyCopyArea(PixmapPtr dst,
         h = dst_box.y2 - dst_box.y1;
 
         pGC->ops->CopyArea(src, &dst->drawable, pGC,
-                           dirty->x + dst_box.x1, dirty->y + dst_box.y1, w, h,
-                           dirty->dst_x + dst_box.x1,
-                           dirty->dst_y + dst_box.y1);
+                           x + dst_box.x1, y + dst_box.y1, w, h,
+                           dst_x + dst_box.x1, dst_y + dst_box.y1);
         b++;
     }
     FreeScratchGC(pGC);
@@ -408,7 +392,8 @@ Bool PixmapSyncDirtyHelper(PixmapDirtyUpdatePtr dirty)
     RegionTranslate(&pixregion, -dirty->x, -dirty->y);
 
     if (!pScreen->root || dirty->rotation == RR_Rotate_0)
-        PixmapDirtyCopyArea(dst, dirty, &pixregion);
+        PixmapDirtyCopyArea(dst, dirty->src, dirty->x, dirty->y,
+                            dirty->dst_x, dirty->dst_y, &pixregion);
     else
         PixmapDirtyCompositeRotate(dst, dirty, &pixregion);
     pScreen->SourceValidate = SourceValidate;
diff --git a/dix/resource.c b/dix/resource.c
index 6c0be2e04..055e6934e 100644
--- a/dix/resource.c
+++ b/dix/resource.c
@@ -620,12 +620,15 @@ ilog2(int val)
 unsigned int
 ResourceClientBits(void)
 {
-    static unsigned int cached = 0;
+    static unsigned int cache_ilog2 = 0;
+    static unsigned int cache_limit = 0;
 
-    if (cached == 0)
-      cached = ilog2(LimitClients);
+    if (LimitClients != cache_limit) {
+        cache_limit = LimitClients;
+        cache_ilog2 = ilog2(LimitClients);
+    }
 
-    return cached;
+    return cache_ilog2;
 }
 
 /*****************
diff --git a/dix/window.c b/dix/window.c
index cd917f006..284aa6dd7 100644
--- a/dix/window.c
+++ b/dix/window.c
@@ -3642,7 +3642,7 @@ SetRootClip(ScreenPtr pScreen, int enable)
     if (!pWin)
         return;
     WasViewable = (Bool) (pWin->viewable);
-    if (WasViewable) {
+    if (WasViewable && mode != ROOT_CLIP_INPUT_ONLY) {
         for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
             (void) (*pScreen->MarkOverlappedWindows) (pChild,
                                                       pChild, &pLayerWin);
@@ -3696,7 +3696,7 @@ SetRootClip(ScreenPtr pScreen, int enable)
 
     ResizeChildrenWinSize(pWin, 0, 0, 0, 0);
 
-    if (WasViewable) {
+    if (WasViewable && mode != ROOT_CLIP_INPUT_ONLY) {
         if (pWin->firstChild) {
             anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin->firstChild,
                                                             pWin->firstChild,
diff --git a/doc/Makefile.am b/doc/Makefile.am
deleted file mode 100644
index b305f4db7..000000000
--- a/doc/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-SUBDIRS = dtrace
-
-if ENABLE_DEVEL_DOCS
-if HAVE_XMLTO
-
-# Main DocBook/XML files (DOCTYPE book)
-docbook = Xserver-spec.xml Xinput.xml
-
-# Generate DocBook/XML output formats with or without stylesheets
-include $(top_srcdir)/devbook.am
-
-endif HAVE_XMLTO
-endif ENABLE_DEVEL_DOCS
-
-EXTRA_DIST = smartsched filter-xmlto.sh
diff --git a/doc/dtrace/Makefile.am b/doc/dtrace/Makefile.am
deleted file mode 100644
index df26d2b9e..000000000
--- a/doc/dtrace/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-
-if ENABLE_DOCS
-if XSERVER_DTRACE
-
-# Main DocBook/XML files (DOCTYPE book)
-docbook = Xserver-DTrace.xml
-
-# The location where the DocBook/XML files and their generated formats are installed
-shelfdir = $(docdir)
-
-# Generate DocBook/XML output formats with or without stylesheets
-include $(top_srcdir)/docbook.am
-
-endif XSERVER_DTRACE
-endif ENABLE_DOCS
diff --git a/docbook.am b/docbook.am
deleted file mode 100644
index bba4d5453..000000000
--- a/docbook.am
+++ /dev/null
@@ -1,105 +0,0 @@
-#
-# Generate output formats for a single DocBook/XML with/without chapters
-#
-# Variables set by the calling Makefile:
-# shelfdir: the location where the docs/specs are installed. Typically $(docdir)
-# docbook:  the main DocBook/XML file, no chapters, appendix or image files
-# chapters: all files pulled in by an XInclude statement and images.
-#
-
-#
-# This makefile is intended for Users Documentation and Functional Specifications.
-# Do not use for Developer Documentation which is not installed and does not require olink.
-# Refer to http://www.x.org/releases/X11R7.6/doc/xorg-docs/ReleaseNotes.html#id2584393
-# for an explanation on documents classification.
-#
-
-# DocBook/XML generated output formats to be installed
-shelf_DATA =
-
-# DocBook/XML file with chapters, appendix and images it includes
-dist_shelf_DATA = $(docbook) $(chapters)
-
-if HAVE_XMLTO
-if HAVE_STYLESHEETS
-
-XMLTO_SEARCHPATH_FLAGS = 				\
-	--searchpath "$(XORG_SGML_PATH)/X11" 		\
-	--searchpath "$(abs_top_builddir)"
-XMLTO_HTML_OLINK_FLAGS = \
-	--stringparam target.database.document=$(XORG_SGML_PATH)/X11/dbs/masterdb.html.xml \
-	--stringparam current.docid="$(<:.xml=)"
-XMLTO_HTML_STYLESHEET_FLAGS = -x $(STYLESHEET_SRCDIR)/xorg-xhtml.xsl
-XMLTO_HTML_FLAGS = 					\
-	$(XMLTO_SEARCHPATH_FLAGS)			\
-	$(XMLTO_HTML_STYLESHEET_FLAGS)			\
-	$(XMLTO_HTML_OLINK_FLAGS)
-
-shelf_DATA += $(docbook:.xml=.html)
-%.html: %.xml $(chapters)
-	$(AM_V_GEN)$(XMLTO) $(XMLTO_HTML_FLAGS) xhtml-nochunks $<
-
-if HAVE_XMLTO_TEXT
-
-shelf_DATA += $(docbook:.xml=.txt)
-%.txt: %.xml $(chapters)
-	$(AM_V_GEN)$(XMLTO) $(XMLTO_HTML_FLAGS) txt $<
-endif HAVE_XMLTO_TEXT
-
-if HAVE_FOP
-XMLTO_FO_IMAGEPATH_FLAGS = --stringparam img.src.path=$(abs_builddir)/
-XMLTO_PDF_OLINK_FLAGS = \
-	--stringparam target.database.document=$(XORG_SGML_PATH)/X11/dbs/masterdb.pdf.xml \
-	--stringparam current.docid="$(<:.xml=)"
-XMLTO_FO_STYLESHEET_FLAGS = -x $(STYLESHEET_SRCDIR)/xorg-fo.xsl
-
-XMLTO_FO_FLAGS = 					\
-	$(XMLTO_SEARCHPATH_FLAGS)			\
-	$(XMLTO_FO_STYLESHEET_FLAGS)			\
-	$(XMLTO_FO_IMAGEPATH_FLAGS)			\
-	$(XMLTO_PDF_OLINK_FLAGS)
-
-shelf_DATA += $(docbook:.xml=.pdf)
-%.pdf: %.xml $(chapters)
-	$(AM_V_GEN)$(XMLTO) $(XMLTO_FO_FLAGS) --with-fop pdf $<
-
-shelf_DATA += $(docbook:.xml=.ps)
-%.ps: %.xml $(chapters)
-	$(AM_V_GEN)$(XMLTO) $(XMLTO_FO_FLAGS) --with-fop ps $<
-endif HAVE_FOP
-
-# Generate documents cross-reference target databases
-if HAVE_XSLTPROC
-
-XSLT_SEARCHPATH_FLAGS = 				\
-	--path "$(XORG_SGML_PATH)/X11"			\
-	--path "$(abs_top_builddir)"
-XSLT_OLINK_FLAGS = 					\
-	--stringparam targets.filename "$@" 		\
-	--stringparam collect.xref.targets "only" 	\
-	--stringparam olink.base.uri "$(@:.db=)"
-
-XSLT_HTML_FLAGS =					\
-	$(XSLT_SEARCHPATH_FLAGS) 			\
-	$(XSLT_OLINK_FLAGS)				\
-	--nonet --xinclude				\
-	$(STYLESHEET_SRCDIR)/xorg-xhtml.xsl
-XSLT_PDF_FLAGS = 					\
-	$(XSLT_SEARCHPATH_FLAGS) 			\
-	$(XSLT_OLINK_FLAGS)				\
-	--nonet --xinclude				\
-	$(STYLESHEET_SRCDIR)/xorg-fo.xsl
-
-shelf_DATA += $(docbook:.xml=.html.db)
-%.html.db: %.xml  $(chapters)
-	$(AM_V_GEN)$(XSLTPROC) $(XSLT_HTML_FLAGS) $<
-
-shelf_DATA += $(docbook:.xml=.pdf.db)
-%.pdf.db: %.xml $(chapters)
-	$(AM_V_GEN)$(XSLTPROC) $(XSLT_PDF_FLAGS) $<
-
-endif HAVE_XSLTPROC
-endif HAVE_STYLESHEETS
-endif HAVE_XMLTO
-
-CLEANFILES = $(shelf_DATA)
diff --git a/dri3/Makefile.am b/dri3/Makefile.am
deleted file mode 100644
index 32b694f68..000000000
--- a/dri3/Makefile.am
+++ /dev/null
@@ -1,13 +0,0 @@
-noinst_LTLIBRARIES = libdri3.la
-AM_CFLAGS = \
-	@DIX_CFLAGS@ \
-	@LIBDRM_CFLAGS@
-
-libdri3_la_SOURCES = \
-	dri3.h \
-	dri3_priv.h \
-	dri3.c \
-	dri3_request.c \
-	dri3_screen.c
-
-sdk_HEADERS = dri3.h
diff --git a/dri3/dri3_screen.c b/dri3/dri3_screen.c
index 3c7e5bf60..bc96e5339 100644
--- a/dri3/dri3_screen.c
+++ b/dri3/dri3_screen.c
@@ -211,18 +211,17 @@ cache_formats_and_modifiers(ScreenPtr screen)
 int
 dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
                              CARD8 depth, CARD8 bpp,
-                             CARD32 *num_intersect_modifiers,
-                             CARD64 **intersect_modifiers,
+                             CARD32 *num_drawable_modifiers,
+                             CARD64 **drawable_modifiers,
                              CARD32 *num_screen_modifiers,
                              CARD64 **screen_modifiers)
 {
     dri3_screen_priv_ptr        ds = dri3_screen_priv(screen);
     const dri3_screen_info_rec *info = ds->info;
-    int                         i, j;
+    int                         i;
     int                         ret;
     uint32_t                    num_drawable_mods;
     uint64_t                   *drawable_mods;
-    CARD64                     *intersect_mods = NULL;
     CARD64                     *screen_mods = NULL;
     CARD32                      format;
     dri3_dmabuf_format_ptr      screen_format = NULL;
@@ -248,10 +247,15 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
 
     if (screen_format->num_modifiers == 0) {
         *num_screen_modifiers = 0;
-        *num_intersect_modifiers = 0;
+        *num_drawable_modifiers = 0;
         return Success;
     }
 
+    /* copy the screen mods so we can return an owned allocation */
+    screen_mods = xnfalloc(screen_format->num_modifiers * sizeof(CARD64));
+    memcpy(screen_mods, screen_format->modifiers,
+           screen_format->num_modifiers * sizeof(CARD64));
+
     if (!info->get_drawable_modifiers ||
         !info->get_drawable_modifiers(drawable, format,
                                       &num_drawable_mods,
@@ -260,47 +264,11 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
         drawable_mods = NULL;
     }
 
-    /* We're allocating slightly more memory than necessary but it reduces
-     * the complexity of finding the intersection set.
-     */
-    screen_mods = malloc(screen_format->num_modifiers * sizeof(CARD64));
-    if (!screen_mods)
-        return BadAlloc;
-    if (num_drawable_mods > 0) {
-        intersect_mods = malloc(screen_format->num_modifiers * sizeof(CARD64));
-        if (!intersect_mods) {
-            free(screen_mods);
-            return BadAlloc;
-        }
-    }
-
-    *num_screen_modifiers = 0;
-    *num_intersect_modifiers = 0;
-    for (i = 0; i < screen_format->num_modifiers; i++) {
-        CARD64 modifier = screen_format->modifiers[i];
-        Bool intersect = FALSE;
-
-        for (j = 0; j < num_drawable_mods; j++) {
-            if (drawable_mods[j] == modifier) {
-                intersect = TRUE;
-                break;
-            }
-        }
-
-        if (intersect) {
-            intersect_mods[*num_intersect_modifiers] = modifier;
-            *num_intersect_modifiers += 1;
-        } else {
-            screen_mods[*num_screen_modifiers] = modifier;
-            *num_screen_modifiers += 1;
-        }
-    }
-
-    assert(*num_intersect_modifiers + *num_screen_modifiers == screen_format->num_modifiers);
+    *num_drawable_modifiers = num_drawable_mods;
+    *drawable_modifiers = drawable_mods;
 
-    *intersect_modifiers = intersect_mods;
+    *num_screen_modifiers = screen_format->num_modifiers;
     *screen_modifiers = screen_mods;
-    free(drawable_mods);
 
     return Success;
 }
diff --git a/exa/Makefile.am b/exa/Makefile.am
deleted file mode 100644
index 00b28b1e4..000000000
--- a/exa/Makefile.am
+++ /dev/null
@@ -1,24 +0,0 @@
-noinst_LTLIBRARIES = libexa.la
-
-if XORG
-sdk_HEADERS = exa.h
-endif
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-libexa_la_SOURCES = \
-	exa.c \
-	exa.h \
-	exa_classic.c \
-	exa_migration_classic.c \
-	exa_driver.c \
-	exa_mixed.c \
-	exa_migration_mixed.c \
-	exa_accel.c \
-	exa_glyphs.c \
-	exa_offscreen.c \
-	exa_render.c \
-	exa_priv.h \
-	exa_unaccel.c
diff --git a/exa/exa.c b/exa/exa.c
index b16875845..42047fa2d 100644
--- a/exa/exa.c
+++ b/exa/exa.c
@@ -125,7 +125,7 @@ exaGetDrawablePixmap(DrawablePtr pDrawable)
 void
 exaGetDrawableDeltas(DrawablePtr pDrawable, PixmapPtr pPixmap, int *xp, int *yp)
 {
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (pDrawable->type == DRAWABLE_WINDOW) {
         *xp = -pPixmap->screen_x;
         *yp = -pPixmap->screen_y;
diff --git a/exa/exa_accel.c b/exa/exa_accel.c
index e632331da..2a31bd3c7 100644
--- a/exa/exa_accel.c
+++ b/exa/exa_accel.c
@@ -963,7 +963,7 @@ exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     RegionInit(&rgnDst, NullBox, 0);
 
     RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (pPixmap->screen_x || pPixmap->screen_y)
         RegionTranslate(&rgnDst, -pPixmap->screen_x, -pPixmap->screen_y);
 #endif
diff --git a/exa/exa_driver.c b/exa/exa_driver.c
index 8799a798e..45acf152c 100644
--- a/exa/exa_driver.c
+++ b/exa/exa_driver.c
@@ -87,7 +87,7 @@ exaCreatePixmap_driver(ScreenPtr pScreen, int w, int h, int depth,
     }
     else {
         paddedWidth = ((w * bpp + FB_MASK) >> FB_SHIFT) * sizeof(FbBits);
-        if (paddedWidth / 4 > 32767 || h > 32767)
+        if (paddedWidth / 4 > 32767)
             return NullPixmap;
 
         exaSetFbPitch(pExaScr, pExaPixmap, w, h, bpp);
diff --git a/exa/exa_mixed.c b/exa/exa_mixed.c
index 1e67ec23a..d926f8033 100644
--- a/exa/exa_mixed.c
+++ b/exa/exa_mixed.c
@@ -72,7 +72,7 @@ exaCreatePixmap_mixed(ScreenPtr pScreen, int w, int h, int depth,
     bpp = pPixmap->drawable.bitsPerPixel;
 
     paddedWidth = ((w * bpp + FB_MASK) >> FB_SHIFT) * sizeof(FbBits);
-    if (paddedWidth / 4 > 32767 || h > 32767)
+    if (paddedWidth / 4 > 32767)
         return NullPixmap;
 
     /* We will allocate the system pixmap later if needed. */
@@ -326,5 +326,3 @@ exaSetSharedPixmapBacking_mixed(PixmapPtr pPixmap, void *handle)
 
     return ret;
 }
-
-
diff --git a/fb/Makefile.am b/fb/Makefile.am
deleted file mode 100644
index 333aa06a9..000000000
--- a/fb/Makefile.am
+++ /dev/null
@@ -1,49 +0,0 @@
-noinst_LTLIBRARIES = libfb.la libwfb.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-if XORG
-sdk_HEADERS = fb.h fbrop.h fboverlay.h wfbrename.h fbpict.h
-endif
-
-libfb_la_CFLAGS = $(AM_CFLAGS)
-libfb_la_LIBADD = $(PIXMAN_LIBS)
-
-libwfb_la_CFLAGS = $(AM_CFLAGS) -DFB_ACCESS_WRAPPER
-libwfb_la_LIBADD = $(PIXMAN_LIBS)
-
-libfb_la_SOURCES = 	\
-	fb.h		\
-	fballpriv.c	\
-	fbarc.c		\
-	fbbits.c	\
-	fbbits.h	\
-	fbblt.c		\
-	fbbltone.c	\
-	fbcmap_mi.c     \
-	fbcopy.c	\
-	fbfill.c	\
-	fbfillrect.c	\
-	fbfillsp.c	\
-	fbgc.c		\
-	fbgetsp.c	\
-	fbglyph.c	\
-	fbimage.c	\
-	fbline.c	\
-	fboverlay.c	\
-	fboverlay.h	\
-	fbpict.c	\
-	fbpict.h	\
-	fbpixmap.c	\
-	fbpoint.c	\
-	fbpush.c	\
-	fbrop.h		\
-	fbscreen.c	\
-	fbseg.c		\
-	fbsetsp.c	\
-	fbsolid.c	\
-	fbtrap.c	\
-	fbutil.c	\
-	fbwindow.c
-
-libwfb_la_SOURCES = $(libfb_la_SOURCES)
diff --git a/fb/fb.h b/fb/fb.h
index 8ab050d0f..08143a0d4 100644
--- a/fb/fb.h
+++ b/fb/fb.h
@@ -441,7 +441,7 @@ typedef struct {
 #define __fbPixDrawableX(pPix)	((pPix)->drawable.x)
 #define __fbPixDrawableY(pPix)	((pPix)->drawable.y)
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
 #define __fbPixOffXWin(pPix)	(__fbPixDrawableX(pPix) - (pPix)->screen_x)
 #define __fbPixOffYWin(pPix)	(__fbPixDrawableY(pPix) - (pPix)->screen_y)
 #else
diff --git a/fb/fbpixmap.c b/fb/fbpixmap.c
index af5d7bec0..89e3370a6 100644
--- a/fb/fbpixmap.c
+++ b/fb/fbpixmap.c
@@ -76,7 +76,7 @@ fbCreatePixmap(ScreenPtr pScreen, int width, int height, int depth,
     fbInitializeDrawable(&pPixmap->drawable);
 #endif
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     pPixmap->screen_x = 0;
     pPixmap->screen_y = 0;
 #endif
diff --git a/fb/fbwindow.c b/fb/fbwindow.c
index fca871d62..df33af948 100644
--- a/fb/fbwindow.c
+++ b/fb/fbwindow.c
@@ -116,7 +116,7 @@ fbCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 
     RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (pPixmap->screen_x || pPixmap->screen_y)
         RegionTranslate(&rgnDst, -pPixmap->screen_x, -pPixmap->screen_y);
 #endif
diff --git a/glamor/Makefile.am b/glamor/Makefile.am
deleted file mode 100644
index aaf0aab17..000000000
--- a/glamor/Makefile.am
+++ /dev/null
@@ -1,62 +0,0 @@
-noinst_LTLIBRARIES = libglamor.la libglamor_egl_stubs.la
-
-libglamor_la_LIBADD = $(GLAMOR_LIBS)
-
-AM_CFLAGS = $(CWARNFLAGS) $(DIX_CFLAGS) $(GLAMOR_CFLAGS)
-
-libglamor_la_SOURCES = \
-	glamor.c \
-	glamor_context.h \
-	glamor_copy.c \
-	glamor_core.c \
-	glamor_dash.c \
-	glamor_debug.h \
-	glamor_font.c \
-	glamor_font.h \
-	glamor_glx.c \
-	glamor_composite_glyphs.c \
-	glamor_image.c \
-	glamor_lines.c \
-	glamor_segs.c \
-	glamor_render.c \
-	glamor_gradient.c \
-	glamor_prepare.c \
-	glamor_prepare.h \
-	glamor_program.c \
-	glamor_program.h \
-	glamor_rects.c \
-	glamor_spans.c \
-	glamor_text.c \
-	glamor_transfer.c \
-	glamor_transfer.h \
-	glamor_transform.c \
-	glamor_transform.h \
-	glamor_trapezoid.c \
-	glamor_triangles.c\
-	glamor_addtraps.c\
-	glamor_glyphblt.c\
-	glamor_points.c\
-	glamor_priv.h\
-	glamor_pixmap.c\
-	glamor_largepixmap.c\
-	glamor_picture.c\
-	glamor_vbo.c \
-	glamor_window.c\
-	glamor_fbo.c\
-	glamor_compositerects.c\
-	glamor_utils.c\
-	glamor_utils.h\
-	glamor_sync.c \
-	glamor.h
-
-if XV
-libglamor_la_SOURCES += \
-	glamor_xv.c
-endif
-
-libglamor_egl_stubs_la_SOURCES = \
-	glamor_egl_stubs.c \
-	glamor_egl_ext.h \
-	glamor_egl.h
-
-sdk_HEADERS = glamor.h
diff --git a/glamor/glamor.c b/glamor/glamor.c
index da2ea94ba..f15b5a18a 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -223,7 +223,7 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 
     pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-    pixmap_priv->is_cbcr = (usage == GLAMOR_CREATE_FORMAT_CBCR);
+    pixmap_priv->is_cbcr = (GLAMOR_CREATE_FORMAT_CBCR & usage) == GLAMOR_CREATE_FORMAT_CBCR;
 
     pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
     screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
@@ -550,9 +550,10 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
     /* Prefer r8 textures since they're required by GLES3 and core,
-     * only falling back to a8 if we can't do them.
+     * only falling back to a8 if we can't do them. We cannot do them
+     * on GLES2 due to lack of texture swizzle.
      */
-    if (glamor_priv->is_gles || epoxy_has_gl_extension("GL_ARB_texture_rg")) {
+    if (glamor_priv->has_rg && glamor_priv->has_texture_swizzle) {
         glamor_add_format(screen, 1, PICT_a1,
                           GL_R8, GL_RED, GL_UNSIGNED_BYTE, FALSE);
         glamor_add_format(screen, 8, PICT_a8,
@@ -586,10 +587,10 @@ glamor_setup_formats(ScreenPtr screen)
 
     if (glamor_priv->is_gles) {
         assert(X_BYTE_ORDER == X_LITTLE_ENDIAN);
-        glamor_add_format(screen, 24, PICT_x8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
-        glamor_add_format(screen, 32, PICT_a8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 24, PICT_x8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 32, PICT_a8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
     } else {
         glamor_add_format(screen, 24, PICT_x8r8g8b8,
                           GL_RGBA, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, TRUE);
@@ -606,8 +607,13 @@ glamor_setup_formats(ScreenPtr screen)
     }
 
     glamor_priv->cbcr_format.depth = 16;
-    glamor_priv->cbcr_format.internalformat = GL_RG8;
+    if (glamor_priv->is_gles && glamor_priv->has_rg) {
+        glamor_priv->cbcr_format.internalformat = GL_RG;
+    } else {
+        glamor_priv->cbcr_format.internalformat = GL_RG8;
+    }
     glamor_priv->cbcr_format.format = GL_RG;
+    glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
 }
@@ -618,10 +624,7 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 {
     glamor_screen_private *glamor_priv;
     int gl_version;
-    int glsl_major, glsl_minor;
     int max_viewport_size[2];
-    const char *shading_version_string;
-    int shading_version_offset;
 
     PictureScreenPtr ps = GetPictureScreenIfSet(screen);
 
@@ -670,9 +673,6 @@ glamor_init(ScreenPtr screen, unsigned int flags)
      * register correct close screen function. */
     if (flags & GLAMOR_USE_EGL_SCREEN) {
         glamor_egl_screen_init(screen, &glamor_priv->ctx);
-    } else {
-        if (!glamor_glx_screen_init(&glamor_priv->ctx))
-            goto fail;
     }
 
     glamor_make_current(glamor_priv);
@@ -686,29 +686,7 @@ glamor_init(ScreenPtr screen, unsigned int flags)
     glamor_priv->is_core_profile =
         gl_version >= 31 && !epoxy_has_gl_extension("GL_ARB_compatibility");
 
-    shading_version_string = (char *) glGetString(GL_SHADING_LANGUAGE_VERSION);
-
-    if (!shading_version_string) {
-        LogMessage(X_WARNING,
-                   "glamor%d: Failed to get GLSL version\n",
-                   screen->myNum);
-        goto fail;
-    }
-
-    shading_version_offset = 0;
-    if (strncmp("OpenGL ES GLSL ES ", shading_version_string, 18) == 0)
-        shading_version_offset = 18;
-
-    if (sscanf(shading_version_string + shading_version_offset,
-               "%i.%i",
-               &glsl_major,
-               &glsl_minor) != 2) {
-        LogMessage(X_WARNING,
-                   "glamor%d: Failed to parse GLSL version string %s\n",
-                   screen->myNum, shading_version_string);
-        goto fail;
-    }
-    glamor_priv->glsl_version = glsl_major * 100 + glsl_minor;
+    glamor_priv->glsl_version = epoxy_glsl_version();
 
     if (glamor_priv->is_gles) {
         /* Force us back to the base version of our programs on an ES
@@ -810,11 +788,18 @@ glamor_init(ScreenPtr screen, unsigned int flags)
         epoxy_gl_version() >= 30 ||
         epoxy_has_gl_extension("GL_NV_pack_subimage");
     glamor_priv->has_dual_blend =
-        glamor_glsl_has_ints(glamor_priv) &&
-        epoxy_has_gl_extension("GL_ARB_blend_func_extended");
+        (epoxy_has_gl_extension("GL_ARB_blend_func_extended") &&
+        (glamor_glsl_has_ints(glamor_priv) ||
+        epoxy_has_gl_extension("GL_ARB_ES2_compatibility"))) ||
+        epoxy_has_gl_extension("GL_EXT_blend_func_extended");
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
+    /* GL_EXT_texture_rg is part of GLES3 core */
+    glamor_priv->has_rg =
+        (glamor_priv->is_gles && epoxy_gl_version() >= 30) ||
+        epoxy_has_gl_extension("GL_EXT_texture_rg") ||
+        epoxy_has_gl_extension("GL_ARB_texture_rg");
 
     glamor_priv->can_copyplane = (gl_version >= 30);
 
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index 147e3bb31..c69b940d4 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -208,6 +208,22 @@ static const glamor_facet glamor_facet_composite_glyphs_120 = {
     .locations = glamor_program_location_atlas,
 };
 
+static const glamor_facet glamor_facet_composite_glyphs_gles2 = {
+    .name = "composite_glyphs",
+    .version = 100,
+    .fs_extensions = ("#extension GL_EXT_blend_func_extended : enable\n"),
+    .vs_vars = ("attribute vec2 primitive;\n"
+                "attribute vec2 source;\n"
+                "varying vec2 glyph_pos;\n"),
+    .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_POS(gl_Position, primitive.xy)
+                "       glyph_pos = source.xy * ATLAS_DIM_INV;\n"),
+    .fs_vars = ("varying vec2 glyph_pos;\n"),
+    .fs_exec = ("       vec4 mask = texture2D(atlas, glyph_pos);\n"),
+    .source_name = "source",
+    .locations = glamor_program_location_atlas,
+};
+
 static Bool
 glamor_glyphs_init_facet(ScreenPtr screen)
 {
@@ -442,7 +458,9 @@ glamor_composite_glyphs(CARD8 op,
                         else
                             prog = glamor_setup_program_render(op, src, glyph_pict, dst,
                                                                glyphs_program,
-                                                               &glamor_facet_composite_glyphs_120,
+                                                               glamor_priv->has_dual_blend ?
+                                                                   &glamor_facet_composite_glyphs_gles2 :
+                                                                   &glamor_facet_composite_glyphs_120,
                                                                glamor_priv->glyph_defines);
                         if (!prog)
                             goto bail_one;
diff --git a/glamor/glamor_context.h b/glamor/glamor_context.h
index 47b87e620..50986971c 100644
--- a/glamor/glamor_context.h
+++ b/glamor/glamor_context.h
@@ -21,29 +21,26 @@
  * IN THE SOFTWARE.
  */
 
+#ifndef GLAMOR_CONTEXT_H
+#define GLAMOR_CONTEXT_H
+
+#include <epoxy/egl.h>
+
 /**
  * @file glamor_context.h
  *
  * This is the struct of state required for context switching in
- * glamor.  It has to use types that don't require including either
- * server headers or Xlib headers, since it will be included by both
- * the server and the GLX (xlib) code.
+ * glamor. Initially this was abstracted away from EGL, and
+ * presumably it would need to be again if someone wanted to use
+ * glamor with WGL/CGL.
  */
 
 struct glamor_context {
-    /** Either an EGLDisplay or an Xlib Display */
-    void *display;
-
-    /** Either a GLXContext or an EGLContext. */
-    void *ctx;
-
-    /** The EGLSurface we should MakeCurrent to */
-    void *drawable;
-
-    /** The GLXDrawable we should MakeCurrent to */
-    uint32_t drawable_xid;
+    EGLDisplay display;
+    EGLContext ctx;
+    EGLSurface surface;
 
     void (*make_current)(struct glamor_context *glamor_ctx);
 };
 
-Bool glamor_glx_screen_init(struct glamor_context *glamor_ctx);
+#endif
diff --git a/glamor/glamor_copy.c b/glamor/glamor_copy.c
index 1ab2be6c0..fa2d783a1 100644
--- a/glamor/glamor_copy.c
+++ b/glamor/glamor_copy.c
@@ -781,7 +781,7 @@ glamor_copy_window(WindowPtr window, DDXPointRec old_origin, RegionPtr src_regio
 
     RegionIntersect(&dst_region, &window->borderClip, src_region);
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (pixmap->screen_x || pixmap->screen_y)
         RegionTranslate(&dst_region, -pixmap->screen_x, -pixmap->screen_y);
 #endif
diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 6e0fc6596..c35b10d83 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -403,6 +403,9 @@ glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
     struct gbm_bo *bo;
     int num_fds;
 #ifdef GBM_BO_WITH_MODIFIERS
+#ifndef GBM_BO_FD_FOR_PLANE
+    int32_t first_handle;
+#endif
     int i;
 #endif
 
@@ -416,7 +419,29 @@ glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
 #ifdef GBM_BO_WITH_MODIFIERS
     num_fds = gbm_bo_get_plane_count(bo);
     for (i = 0; i < num_fds; i++) {
-        fds[i] = gbm_bo_get_fd(bo);
+#ifdef GBM_BO_FD_FOR_PLANE
+        fds[i] = gbm_bo_get_fd_for_plane(bo, i);
+#else
+        union gbm_bo_handle plane_handle = gbm_bo_get_handle_for_plane(bo, i);
+
+        if (i == 0)
+            first_handle = plane_handle.s32;
+
+        /* If all planes point to the same object as the first plane, i.e. they
+         * all have the same handle, we can fall back to the non-planar
+         * gbm_bo_get_fd without losing information. If they point to different
+         * objects we are out of luck and need to give up.
+         */
+	if (first_handle == plane_handle.s32)
+            fds[i] = gbm_bo_get_fd(bo);
+        else
+            fds[i] = -1;
+#endif
+        if (fds[i] == -1) {
+            while (--i >= 0)
+                close(fds[i]);
+            return 0;
+        }
         strides[i] = gbm_bo_get_stride_for_plane(bo, i);
         offsets[i] = gbm_bo_get_offset(bo, i);
     }
@@ -424,6 +449,8 @@ glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
 #else
     num_fds = 1;
     fds[0] = gbm_bo_get_fd(bo);
+    if (fds[0] == -1)
+        return 0;
     strides[0] = gbm_bo_get_stride(bo);
     offsets[0] = 0;
     *modifier = DRM_FORMAT_MOD_INVALID;
@@ -933,8 +960,6 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
 {
     struct glamor_egl_screen_private *glamor_egl;
     const GLubyte *renderer;
-    EGLConfig egl_config;
-    int n;
 
     glamor_egl = calloc(sizeof(*glamor_egl), 1);
     if (glamor_egl == NULL)
@@ -977,6 +1002,7 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
 	}
 
     GLAMOR_CHECK_EGL_EXTENSION(KHR_surfaceless_context);
+    GLAMOR_CHECK_EGL_EXTENSION(KHR_no_config_context);
 
     if (eglBindAPI(EGL_OPENGL_API)) {
         static const EGLint config_attribs_core[] = {
@@ -993,12 +1019,13 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
         };
 
         glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                               NULL, EGL_NO_CONTEXT,
+                                               EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
                                                config_attribs_core);
 
         if (glamor_egl->context == EGL_NO_CONTEXT)
             glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                                   NULL, EGL_NO_CONTEXT,
+                                                   EGL_NO_CONFIG_KHR,
+                                                   EGL_NO_CONTEXT,
                                                    config_attribs);
     }
 
@@ -1029,14 +1056,8 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
             goto error;
         }
 
-        if (!eglChooseConfig(glamor_egl->display, NULL, &egl_config, 1, &n)) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "glamor: No acceptable EGL configs found\n");
-            goto error;
-        }
-
         glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                               egl_config, EGL_NO_CONTEXT,
+                                               EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
                                                config_attribs);
 
         if (glamor_egl->context == EGL_NO_CONTEXT) {
@@ -1059,7 +1080,12 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
                    "glGetString() returned NULL, your GL is broken\n");
         goto error;
     }
-    if (strstr((const char *)renderer, "llvmpipe")) {
+    if (strstr((const char *)renderer, "softpipe")) {
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                   "Refusing to try glamor on softpipe\n");
+        goto error;
+    }
+    if (!strncmp("llvmpipe", (const char *)renderer, strlen("llvmpipe"))) {
         if (scrn->confScreen->num_gpu_devices)
             xf86DrvMsg(scrn->scrnIndex, X_INFO,
                        "Allowing glamor on llvmpipe for PRIME\n");
diff --git a/glamor/glamor_glx.c b/glamor/glamor_glx.c
deleted file mode 100644
index 7107c7c17..000000000
--- a/glamor/glamor_glx.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright © 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <epoxy/glx.h>
-#include "glamor_context.h"
-
-/**
- * @file glamor_glx.c
- *
- * GLX context management for glamor.
- *
- * This has to be kept separate from the server sources because of
- * Xlib's conflicting definition of CARD32 and similar typedefs.
- */
-
-static void
-glamor_glx_make_current(struct glamor_context *glamor_ctx)
-{
-    /* There's only a single global dispatch table in Mesa.  EGL, GLX,
-     * and AIGLX's direct dispatch table manipulation don't talk to
-     * each other.  We need to set the context to NULL first to avoid
-     * GLX's no-op context change fast path when switching back to
-     * GLX.
-     */
-    glXMakeCurrent(glamor_ctx->display, None, None);
-
-    glXMakeCurrent(glamor_ctx->display, glamor_ctx->drawable_xid,
-                   glamor_ctx->ctx);
-}
-
-
-Bool
-glamor_glx_screen_init(struct glamor_context *glamor_ctx)
-{
-    glamor_ctx->ctx = glXGetCurrentContext();
-    if (!glamor_ctx->ctx)
-        return False;
-
-    glamor_ctx->display = glXGetCurrentDisplay();
-    if (!glamor_ctx->display)
-        return False;
-
-    glamor_ctx->drawable_xid = glXGetCurrentDrawable();
-
-    glamor_ctx->make_current = glamor_glx_make_current;
-
-    return True;
-}
diff --git a/glamor/glamor_gradient.c b/glamor/glamor_gradient.c
index 7e5d5cca9..4c7ae4d77 100644
--- a/glamor/glamor_gradient.c
+++ b/glamor/glamor_gradient.c
@@ -605,27 +605,35 @@ _glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
      * T_s = | w*t21/h  t22      t23/h|
      *       | w*t31    h*t32    t33  |
      *       --                      --
+     *
+     * Because GLES2 cannot do trasposed mat by spec, we did transposing inside this function
+     * already, and matrix becoming look like this:
+     *       --                      --
+     *       | t11      w*t21/h  t31*w|
+     * T_s = | h*t12/w  t22      t32*h|
+     *       | t13/w    t23/h    t33  |
+     *       --                      --
      */
 
     to[0][0] = (float) pixman_fixed_to_double(from->matrix[0][0]);
-    to[0][1] = (float) pixman_fixed_to_double(from->matrix[0][1])
+    to[1][0] = (float) pixman_fixed_to_double(from->matrix[0][1])
         * (normalize ? (((float) height) / ((float) width)) : 1.0);
-    to[0][2] = (float) pixman_fixed_to_double(from->matrix[0][2])
+    to[2][0] = (float) pixman_fixed_to_double(from->matrix[0][2])
         / (normalize ? ((float) width) : 1.0);
 
-    to[1][0] = (float) pixman_fixed_to_double(from->matrix[1][0])
+    to[0][1] = (float) pixman_fixed_to_double(from->matrix[1][0])
         * (normalize ? (((float) width) / ((float) height)) : 1.0);
     to[1][1] = (float) pixman_fixed_to_double(from->matrix[1][1]);
-    to[1][2] = (float) pixman_fixed_to_double(from->matrix[1][2])
+    to[2][1] = (float) pixman_fixed_to_double(from->matrix[1][2])
         / (normalize ? ((float) height) : 1.0);
 
-    to[2][0] = (float) pixman_fixed_to_double(from->matrix[2][0])
+    to[0][2] = (float) pixman_fixed_to_double(from->matrix[2][0])
         * (normalize ? ((float) width) : 1.0);
-    to[2][1] = (float) pixman_fixed_to_double(from->matrix[2][1])
+    to[1][2] = (float) pixman_fixed_to_double(from->matrix[2][1])
         * (normalize ? ((float) height) : 1.0);
     to[2][2] = (float) pixman_fixed_to_double(from->matrix[2][2]);
 
-    DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
+    DEBUGF("the transposed transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
            to[0][0], to[0][1], to[0][2],
            to[1][0], to[1][1], to[1][2], to[2][0], to[2][1], to[2][2]);
 }
@@ -950,11 +958,12 @@ glamor_generate_radial_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 0);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
@@ -1266,11 +1275,12 @@ glamor_generate_linear_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 1);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
diff --git a/glamor/glamor_picture.c b/glamor/glamor_picture.c
index 33b3bebd9..2152b85e1 100644
--- a/glamor/glamor_picture.c
+++ b/glamor/glamor_picture.c
@@ -94,7 +94,7 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
             swizzle[0] = GL_GREEN;
@@ -113,12 +113,9 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8_REV;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
-            swizzle[0] = GL_BLUE;
-            swizzle[2] = GL_RED;
-
             if (!is_little_endian)
                 byte_swap_swizzle(swizzle);
             break;
diff --git a/glamor/glamor_pixmap.c b/glamor/glamor_pixmap.c
index 9aa169cdc..2c8cc3ba0 100644
--- a/glamor/glamor_pixmap.c
+++ b/glamor/glamor_pixmap.c
@@ -39,7 +39,7 @@ void
 glamor_get_drawable_deltas(DrawablePtr drawable, PixmapPtr pixmap,
                            int *x, int *y)
 {
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (drawable->type == DRAWABLE_WINDOW) {
         *x = -pixmap->screen_x;
         *y = -pixmap->screen_y;
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 028a6d374..da20bc5aa 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -216,6 +216,7 @@ typedef struct glamor_screen_private {
     Bool has_dual_blend;
     Bool has_clear_texture;
     Bool has_texture_swizzle;
+    Bool has_rg;
     Bool is_core_profile;
     Bool can_copyplane;
     Bool use_gpu_shader4;
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index d8ddb4c77..f361b726e 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -201,6 +201,8 @@ static const char vs_template[] =
 static const char fs_template[] =
     "%s"                                /* version */
     "%s"                                /* exts */
+    "%s"                                /* prim fs_extensions */
+    "%s"                                /* fill fs_extensions */
     GLAMOR_DEFAULT_PRECISION
     "%s"                                /* defines */
     "%s"                                /* prim fs_vars */
@@ -281,6 +283,11 @@ glamor_build_program(ScreenPtr          screen,
             gpu_shader4 = TRUE;
         }
     }
+    /* For now, fix shader version to GLES as 100. We will fall with 130 shaders
+     * in previous check due to forcibly set 120 glsl for GLES. But this patch
+     * makes xv shaders to work */
+    if(version && glamor_priv->is_gles)
+        version = 100;
 
     vs_vars = vs_location_vars(locations);
     fs_vars = fs_location_vars(locations);
@@ -312,6 +319,8 @@ glamor_build_program(ScreenPtr          screen,
     if (asprintf(&fs_prog_string,
                  fs_template,
                  str(version_string),
+                 str(prim->fs_extensions),
+                 str(fill->fs_extensions),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n#define texelFetch texelFetch2D\n#define uint unsigned int\n" : "",
                  str(defines),
                  str(prim->fs_vars),
@@ -494,7 +503,8 @@ glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
     }
 
     /* Set up the source alpha value for blending in component alpha mode. */
-    if (alpha == glamor_program_alpha_dual_blend) {
+    if (alpha == glamor_program_alpha_dual_blend ||
+        alpha == glamor_program_alpha_dual_blend_gles2) {
         switch (dst_blend) {
         case GL_SRC_ALPHA:
             dst_blend = GL_SRC1_COLOR;
@@ -581,11 +591,13 @@ static const glamor_facet *glamor_facet_source[glamor_program_source_count] = {
 };
 
 static const char *glamor_combine[] = {
-    [glamor_program_alpha_normal]    = "       gl_FragColor = source * mask.a;\n",
-    [glamor_program_alpha_ca_first]  = "       gl_FragColor = source.a * mask;\n",
-    [glamor_program_alpha_ca_second] = "       gl_FragColor = source * mask;\n",
-    [glamor_program_alpha_dual_blend] = "      color0 = source * mask;\n"
-                                        "      color1 = source.a * mask;\n"
+    [glamor_program_alpha_normal]    = "        gl_FragColor = source * mask.a;\n",
+    [glamor_program_alpha_ca_first]  = "        gl_FragColor = source.a * mask;\n",
+    [glamor_program_alpha_ca_second] = "        gl_FragColor = source * mask;\n",
+    [glamor_program_alpha_dual_blend] = "       color0 = source * mask;\n"
+                                        "       color1 = source.a * mask;\n",
+    [glamor_program_alpha_dual_blend_gles2] = " gl_FragColor = source * mask;\n"
+                                              " gl_SecondaryFragColorEXT = source.a * mask;\n"
 };
 
 static Bool
@@ -633,7 +645,9 @@ glamor_setup_program_render(CARD8                 op,
 
     if (glamor_is_component_alpha(mask)) {
         if (glamor_priv->has_dual_blend) {
-            alpha = glamor_program_alpha_dual_blend;
+            alpha = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
         } else {
             /* This only works for PictOpOver */
             if (op != PictOpOver)
diff --git a/glamor/glamor_program.h b/glamor/glamor_program.h
index ab6e46f7b..0bd918fff 100644
--- a/glamor/glamor_program.h
+++ b/glamor/glamor_program.h
@@ -44,6 +44,7 @@ typedef enum {
     glamor_program_alpha_ca_first,
     glamor_program_alpha_ca_second,
     glamor_program_alpha_dual_blend,
+    glamor_program_alpha_dual_blend_gles2,
     glamor_program_alpha_count
 } glamor_program_alpha;
 
@@ -56,8 +57,8 @@ typedef Bool (*glamor_use_render) (CARD8 op, PicturePtr src, PicturePtr dst, gla
 typedef struct {
     const char                          *name;
     const int                           version;
-    char                                *vs_defines;
-    char                                *fs_defines;
+    char                                *vs_extensions;
+    const char                          *fs_extensions;
     const char                          *vs_vars;
     const char                          *vs_exec;
     const char                          *fs_vars;
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index 2af65bf93..c9a125ef9 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -223,6 +223,15 @@ glamor_create_composite_fs(struct shader_key *key)
         "}\n";
     const char *header_ca_dual_blend =
         "#version 130\n";
+    const char *in_ca_dual_blend_gles2 =
+        "void main()\n"
+        "{\n"
+        "	gl_FragColor = dest_swizzle(get_source() * get_mask());\n"
+        "	gl_SecondaryFragColorEXT = dest_swizzle(get_source().a * get_mask());\n"
+        "}\n";
+    const char *header_ca_dual_blend_gles2 =
+        "#version 100\n"
+        "#extension GL_EXT_blend_func_extended : require\n";
 
     char *source;
     const char *source_fetch;
@@ -294,6 +303,10 @@ glamor_create_composite_fs(struct shader_key *key)
         in = in_ca_dual_blend;
         header = header_ca_dual_blend;
         break;
+    case glamor_program_alpha_dual_blend_gles2:
+        in = in_ca_dual_blend_gles2;
+        header = header_ca_dual_blend_gles2;
+        break;
     default:
         FatalError("Bad composite IN type");
     }
@@ -327,6 +340,8 @@ glamor_create_composite_vs(struct shader_key *key)
     const char *main_closing = "}\n";
     const char *source_coords_setup = "";
     const char *mask_coords_setup = "";
+    const char *version_gles2 = "#version 100\n";
+    const char *version = "";
     char *source;
     GLuint prog;
 
@@ -336,10 +351,15 @@ glamor_create_composite_vs(struct shader_key *key)
     if (key->mask != SHADER_MASK_NONE && key->mask != SHADER_MASK_SOLID)
         mask_coords_setup = mask_coords;
 
+    if (key->in == glamor_program_alpha_dual_blend_gles2)
+        version = version_gles2;
+
     XNFasprintf(&source,
+                "%s"
+                GLAMOR_DEFAULT_PRECISION
                 "%s%s%s%s",
-                main_opening,
-                source_coords_setup, mask_coords_setup, main_closing);
+                version, main_opening, source_coords_setup,
+                mask_coords_setup, main_closing);
 
     prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, source);
     free(source);
@@ -701,6 +721,7 @@ combine_pict_format(PictFormatShort * des, const PictFormatShort src,
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
     case glamor_program_alpha_dual_blend:
+    case glamor_program_alpha_dual_blend_gles2:
         src_type = PICT_FORMAT_TYPE(src);
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
@@ -886,8 +907,11 @@ glamor_composite_choose_shader(CARD8 op,
         else {
             if (op == PictOpClear)
                 key.mask = SHADER_MASK_NONE;
-            else if (glamor_priv->has_dual_blend)
-                key.in = glamor_program_alpha_dual_blend;
+            else if (glamor_priv->has_dual_blend) {
+                key.in = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
+            }
             else if (op == PictOpSrc || op == PictOpAdd
                      || op == PictOpIn || op == PictOpOut
                      || op == PictOpOverReverse)
diff --git a/glamor/meson.build b/glamor/meson.build
index 268af593e..4a3f6241a 100644
--- a/glamor/meson.build
+++ b/glamor/meson.build
@@ -4,7 +4,6 @@ srcs_glamor = [
     'glamor_core.c',
     'glamor_dash.c',
     'glamor_font.c',
-    'glamor_glx.c',
     'glamor_composite_glyphs.c',
     'glamor_image.c',
     'glamor_lines.c',
diff --git a/glx/Makefile.am b/glx/Makefile.am
deleted file mode 100644
index 8f19e9dc7..000000000
--- a/glx/Makefile.am
+++ /dev/null
@@ -1,95 +0,0 @@
-if DRI2
-GLXDRI_LIBRARY = libglxdri.la
-endif
-
-noinst_LTLIBRARIES = libglx.la $(GLXDRI_LIBRARY) libglxvnd.la
-
-AM_CFLAGS = \
-	@DIX_CFLAGS@ \
-	@GL_CFLAGS@ \
-	@XLIB_CFLAGS@ \
-	@LIBDRM_CFLAGS@ \
-	@GLX_DEFINES@ \
-	@GLX_ARCH_DEFINES@
-
-sdk_HEADERS = vndserver.h
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/hw/xfree86/os-support \
-	-I$(top_srcdir)/hw/xfree86/os-support/bus \
-	-I$(top_srcdir)/hw/xfree86/common \
-	-I$(top_srcdir)/hw/xfree86/dri \
-	-I$(top_srcdir)/hw/xfree86/dri2 \
-	-I$(top_srcdir)/mi \
-	-I$(top_srcdir)/present
-
-indirect_sources =				\
-	indirect_dispatch.c			\
-	indirect_dispatch.h			\
-	indirect_dispatch_swap.c		\
-	indirect_reqsize.c			\
-	indirect_reqsize.h			\
-	indirect_size.h				\
-	indirect_size_get.c			\
-	indirect_size_get.h			\
-	indirect_table.c
-
-libglxdri_la_SOURCES =
-if DRI2
-libglxdri_la_SOURCES += glxdri2.c
-endif
-
-libglxdri_la_LIBADD = $(DLOPEN_LIBS)
-
-libglx_la_SOURCES = \
-	$(indirect_sources) \
-	clientinfo.c \
-	createcontext.c \
-	extension_string.c \
-	extension_string.h \
-	indirect_util.c \
-	indirect_util.h \
-	indirect_program.c \
-	indirect_table.h \
-	indirect_texture_compression.c \
-        glxbyteorder.h \
-        glxcmds.c \
-        glxcmdsswap.c \
-        glxcontext.h \
-        glxdrawable.h \
-        glxext.c \
-        glxext.h \
-	glxdriswrast.c \
-	glxdricommon.c \
-	glxdricommon.h \
-        glxscreens.c \
-        glxscreens.h \
-        glxserver.h \
-        glxutil.h \
-        render2.c \
-        render2swap.c \
-        renderpix.c \
-        renderpixswap.c \
-        rensize.c \
-        single2.c \
-        single2swap.c \
-        singlepix.c \
-        singlepixswap.c \
-        singlesize.c \
-        singlesize.h \
-        swap_interval.c \
-        unpack.h \
-        xfont.c
-
-libglx_la_LIBADD = $(DLOPEN_LIBS) $(top_builddir)/Xext/libhashtable.la
-
-libglxvnd_la_SOURCES = \
-	vndcmds.c \
-	vndext.c \
-	vndservermapping.c \
-	vndservervendor.h \
-	vndservervendor.c
-
-libglxvnd_la_LIBADD = $(top_builddir)/Xext/libhashtable.la
-
-EXTRA_DIST = vnd_dispatch_stubs.c
diff --git a/glx/vndcmds.c b/glx/vndcmds.c
index d6d8719e1..d1e088973 100644
--- a/glx/vndcmds.c
+++ b/glx/vndcmds.c
@@ -165,9 +165,6 @@ static int CommonLoseCurrent(ClientPtr client, GlxContextTagInfo *tagInfo)
             tagInfo->tag, // No old context tag,
             None, None, None, 0);
 
-    if (ret == Success) {
-        GlxFreeContextTag(tagInfo);
-    }
     return ret;
 }
 
@@ -259,7 +256,6 @@ static int CommonMakeCurrent(ClientPtr client,
             if (ret != Success) {
                 return ret;
             }
-            oldTag = NULL;
         }
 
         if (newVendor != NULL) {
@@ -270,6 +266,9 @@ static int CommonMakeCurrent(ClientPtr client,
         } else {
             reply.contextTag = 0;
         }
+
+        GlxFreeContextTag(oldTag);
+        oldTag = NULL;
     }
 
     reply.contextTag = GlxCheckSwap(client, reply.contextTag);
diff --git a/glx/vndservermapping.c b/glx/vndservermapping.c
index 04788ffbd..e5b9e6b2a 100644
--- a/glx/vndservermapping.c
+++ b/glx/vndservermapping.c
@@ -131,7 +131,6 @@ GlxContextTagInfo *GlxAllocContextTag(ClientPtr client, GlxServerVendor *vendor)
         cl->contextTagCount = newSize;
     }
 
-    assert(index >= 0);
     assert(index < cl->contextTagCount);
     memset(&cl->contextTags[index], 0, sizeof(GlxContextTagInfo));
     cl->contextTags[index].tag = (GLXContextTag) (index + 1);
diff --git a/hw/Makefile.am b/hw/Makefile.am
deleted file mode 100644
index 1749018fa..000000000
--- a/hw/Makefile.am
+++ /dev/null
@@ -1,36 +0,0 @@
-if XORG
-XORG_SUBDIRS = xfree86
-endif
-
-if XVFB
-XVFB_SUBDIRS = vfb
-endif
-
-if XNEST
-XNEST_SUBDIRS = xnest
-endif
-
-if XWIN
-XWIN_SUBDIRS = xwin
-endif
-
-if KDRIVE
-KDRIVE_SUBDIRS = kdrive
-endif
-
-if XQUARTZ
-XQUARTZ_SUBDIRS = xquartz
-endif
-
-SUBDIRS =			\
-	$(XORG_SUBDIRS)		\
-	$(XWIN_SUBDIRS)		\
-	$(XVFB_SUBDIRS)		\
-	$(XNEST_SUBDIRS)	\
-	$(KDRIVE_SUBDIRS)	\
-	$(XQUARTZ_SUBDIRS)
-
-DIST_SUBDIRS = xfree86 vfb xnest xwin xquartz kdrive
-
-relink:
-	$(AM_V_at)for i in $(SUBDIRS) ; do $(MAKE) -C $$i relink || exit 1 ; done
diff --git a/hw/kdrive/Makefile.am b/hw/kdrive/Makefile.am
deleted file mode 100644
index dc71dbd81..000000000
--- a/hw/kdrive/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-if XEPHYR
-XEPHYR_SUBDIRS = ephyr
-endif
-
-SERVER_SUBDIRS = 		\
-	$(XEPHYR_SUBDIRS)
-
-SUBDIRS =			\
-	src			\
-	$(SERVER_SUBDIRS)
-
-DIST_SUBDIRS = ephyr src
-
-relink:
-	$(AM_V_at)for i in $(SERVER_SUBDIRS) ; do $(MAKE) -C $$i relink || exit 1 ; done
diff --git a/hw/kdrive/ephyr/Makefile.am b/hw/kdrive/ephyr/Makefile.am
deleted file mode 100644
index d12559b39..000000000
--- a/hw/kdrive/ephyr/Makefile.am
+++ /dev/null
@@ -1,84 +0,0 @@
-# Copyright © 2013 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-SUBDIRS = man
-
-AM_CPPFLAGS = 			\
-	@KDRIVE_INCS@		\
-	@KDRIVE_CFLAGS@		\
-	@XEPHYR_INCS@		\
-	@XEPHYR_CFLAGS@		\
-	-DHAVE_DIX_CONFIG_H	\
-	-I$(top_srcdir)		\
-	-I$(top_srcdir)/glamor	\
-	-I$(top_srcdir)/exa
-
-if XV
-XV_SRCS = ephyrvideo.c
-endif
-
-if GLAMOR
-if XV
-GLAMOR_XV_SRCS = ephyr_glamor_xv.c
-endif
-
-GLAMOR_SRCS = \
-	ephyr_glamor_glx.c \
-	ephyr_glamor_glx.h \
-	$(GLAMOR_XV_SRCS)  \
-	$()
-endif
-
-bin_PROGRAMS = Xephyr
-
-Xephyr_SOURCES = \
-	ephyr.c \
-	ephyr.h \
-	ephyrlog.h \
-	ephyr_draw.c \
-	ephyrinit.c \
-	ephyrcursor.c \
-	hostx.c \
-	hostx.h \
-	$(XV_SRCS) \
-	$(GLAMOR_SRCS) \
-	$()
-
-if GLAMOR
-AM_CPPFLAGS += $(XLIB_CFLAGS)
-XEPHYR_GLAMOR_LIB = \
-	$(top_builddir)/glamor/libglamor.la \
-	$(top_builddir)/glamor/libglamor_egl_stubs.la \
-	$()
-endif
-
-Xephyr_LDADD = 						\
-	$(top_builddir)/exa/libexa.la			\
-	$(XEPHYR_GLAMOR_LIB)				\
-	@KDRIVE_LIBS@					\
-	@XEPHYR_LIBS@
-
-Xephyr_DEPENDENCIES = @KDRIVE_LOCAL_LIBS@ $(XEPHYR_GLAMOR_LIB)
-
-Xephyr_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
-
-relink:
-	$(AM_V_at)rm -f $(bin_PROGRAMS) && $(MAKE) $(bin_PROGRAMS)
diff --git a/hw/kdrive/ephyr/ephyr.c b/hw/kdrive/ephyr/ephyr.c
index c503ad6a6..8b90584be 100644
--- a/hw/kdrive/ephyr/ephyr.c
+++ b/hw/kdrive/ephyr/ephyr.c
@@ -39,7 +39,7 @@
 #ifdef GLAMOR
 #include "glamor.h"
 #endif
-#include "ephyr_glamor_glx.h"
+#include "ephyr_glamor.h"
 #include "glx_extinit.h"
 #include "xkbsrv.h"
 
@@ -298,7 +298,7 @@ ephyrShadowUpdate(ScreenPtr pScreen, shadowBufPtr pBuf)
      * pBuf->pDamage  regions
      */
     shadowUpdateRotatePacked(pScreen, pBuf);
-    hostx_paint_rect(screen, 0, 0, 0, 0, screen->width, screen->height);
+    hostx_paint_rect(screen, 0, 0, 0, 0, screen->width, screen->height, TRUE);
 }
 
 static void
@@ -328,7 +328,8 @@ ephyrInternalDamageRedisplay(ScreenPtr pScreen)
                 hostx_paint_rect(screen,
                                  pbox->x1, pbox->y1,
                                  pbox->x1, pbox->y1,
-                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                 nbox == 0);
                 pbox++;
             }
         }
@@ -889,7 +890,8 @@ ephyrProcessExpose(xcb_generic_event_t *xev)
     if (scrpriv) {
         hostx_paint_rect(scrpriv->screen, 0, 0, 0, 0,
                          scrpriv->win_width,
-                         scrpriv->win_height);
+                         scrpriv->win_height,
+                         TRUE);
     } else {
         EPHYR_LOG_ERROR("failed to get host screen\n");
     }
@@ -1171,9 +1173,6 @@ ephyrXcbProcessEvents(Bool queued_only)
         }
 
         if (xev) {
-            if (ephyr_glamor)
-                ephyr_glamor_process_event(xev);
-
             free(xev);
         }
     }
diff --git a/hw/kdrive/ephyr/ephyr.h b/hw/kdrive/ephyr/ephyr.h
index 587a48dc7..8833de8a9 100644
--- a/hw/kdrive/ephyr/ephyr.h
+++ b/hw/kdrive/ephyr/ephyr.h
@@ -71,6 +71,7 @@ typedef struct _ephyrScrPriv {
     xcb_window_t win;
     xcb_window_t win_pre_existing;    /* Set via -parent option like xnest */
     xcb_window_t peer_win;            /* Used for GL; should be at most one */
+    xcb_visualid_t vid;
     xcb_image_t *ximg;
     Bool win_explicit_position;
     int win_x, win_y;
@@ -87,10 +88,6 @@ typedef struct _ephyrScrPriv {
 
     ScreenBlockHandlerProcPtr   BlockHandler;
 
-    /**
-     * Per-screen Xlib-using state for glamor (private to
-     * ephyr_glamor_glx.c)
-     */
     struct ephyr_glamor *glamor;
 } EphyrScrPriv;
 
diff --git a/hw/kdrive/ephyr/ephyr_glamor.c b/hw/kdrive/ephyr/ephyr_glamor.c
new file mode 100644
index 000000000..724611d69
--- /dev/null
+++ b/hw/kdrive/ephyr/ephyr_glamor.c
@@ -0,0 +1,378 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/** @file ephyr_glamor.c
+ *
+ * Glamor support and EGL setup.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <xcb/xcb.h>
+#include <xcb/xcb_aux.h>
+#include <pixman.h>
+#include "glamor_egl.h"
+#include "glamor_priv.h"
+#include "ephyr_glamor.h"
+#include "os.h"
+
+/* until we need geometry shaders GL3.1 should suffice. */
+/* Xephyr has its own copy of this for build reasons */
+#define GLAMOR_GL_CORE_VER_MAJOR 3
+#define GLAMOR_GL_CORE_VER_MINOR 1
+/** @{
+ *
+ * global state for Xephyr with glamor, all of which is arguably a bug.
+ */
+Bool ephyr_glamor_gles2;
+Bool ephyr_glamor_skip_present;
+/** @} */
+
+/**
+ * Per-screen state for Xephyr with glamor.
+ */
+struct ephyr_glamor {
+    EGLDisplay dpy;
+    EGLContext ctx;
+    xcb_window_t win;
+    EGLSurface egl_win;
+
+    GLuint tex;
+
+    GLuint texture_shader;
+    GLuint texture_shader_position_loc;
+    GLuint texture_shader_texcoord_loc;
+
+    /* Size of the window that we're rendering to. */
+    unsigned width, height;
+
+    GLuint vao, vbo;
+};
+
+static GLuint
+ephyr_glamor_build_glsl_prog(GLuint vs, GLuint fs)
+{
+    GLint ok;
+    GLuint prog;
+
+    prog = glCreateProgram();
+    glAttachShader(prog, vs);
+    glAttachShader(prog, fs);
+
+    glLinkProgram(prog);
+    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
+    if (!ok) {
+        GLchar *info;
+        GLint size;
+
+        glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &size);
+        info = malloc(size);
+
+        glGetProgramInfoLog(prog, size, NULL, info);
+        ErrorF("Failed to link: %s\n", info);
+        FatalError("GLSL link failure\n");
+    }
+
+    return prog;
+}
+
+static void
+ephyr_glamor_setup_texturing_shader(struct ephyr_glamor *glamor)
+{
+    const char *vs_source =
+        "attribute vec2 texcoord;\n"
+        "attribute vec2 position;\n"
+        "varying vec2 t;\n"
+        "\n"
+        "void main()\n"
+        "{\n"
+        "    t = texcoord;\n"
+        "    gl_Position = vec4(position, 0, 1);\n"
+        "}\n";
+
+    const char *fs_source =
+        "#ifdef GL_ES\n"
+        "precision mediump float;\n"
+        "#endif\n"
+        "\n"
+        "varying vec2 t;\n"
+        "uniform sampler2D s; /* initially 0 */\n"
+        "\n"
+        "void main()\n"
+        "{\n"
+        "    gl_FragColor = texture2D(s, t);\n"
+        "}\n";
+
+    GLuint fs, vs, prog;
+
+    vs = glamor_compile_glsl_prog(GL_VERTEX_SHADER, vs_source);
+    fs = glamor_compile_glsl_prog(GL_FRAGMENT_SHADER, fs_source);
+    prog = ephyr_glamor_build_glsl_prog(vs, fs);
+
+    glamor->texture_shader = prog;
+    glamor->texture_shader_position_loc = glGetAttribLocation(prog, "position");
+    assert(glamor->texture_shader_position_loc != -1);
+    glamor->texture_shader_texcoord_loc = glGetAttribLocation(prog, "texcoord");
+    assert(glamor->texture_shader_texcoord_loc != -1);
+}
+
+#ifndef EGL_PLATFORM_XCB_EXT
+#define EGL_PLATFORM_XCB_EXT 0x31DC
+#endif
+
+#include <dlfcn.h>
+#ifndef RTLD_DEFAULT
+#define RTLD_DEFAULT NULL
+#endif
+
+/* (loud booing)
+ *
+ * keeping this as a static variable is bad form, we _could_ have zaphod heads
+ * on different displays (for example). but other bits of Xephyr are already
+ * broken for that case, and fixing that would entail fixing the rest of the
+ * contortions with hostx.c anyway, so this works for now.
+ */
+static EGLDisplay edpy = EGL_NO_DISPLAY;
+
+xcb_connection_t *
+ephyr_glamor_connect(void)
+{
+    int major = 0, minor = 0;
+
+    /*
+     * Try pure xcb first. If that doesn't work but we can find XOpenDisplay,
+     * fall back to xlib. This lets us potentially not load libX11 at all, if
+     * the EGL is also pure xcb.
+     */
+
+    if (epoxy_has_egl_extension(EGL_NO_DISPLAY, "EGL_EXT_platform_xcb")) {
+        xcb_connection_t *conn = xcb_connect(NULL, NULL);
+        EGLDisplay dpy = glamor_egl_get_display(EGL_PLATFORM_XCB_EXT, conn);
+
+        if (dpy == EGL_NO_DISPLAY) {
+            xcb_disconnect(conn);
+            return NULL;
+        }
+
+        edpy = dpy;
+        eglInitialize(dpy, &major, &minor);
+        return conn;
+    }
+
+    if (epoxy_has_egl_extension(EGL_NO_DISPLAY, "EGL_EXT_platform_x11") ||
+        epoxy_has_egl_extension(EGL_NO_DISPLAY, "EGL_KHR_platform_x11)")) {
+        void *lib = NULL;
+        xcb_connection_t *ret = NULL;
+        void *(*x_open_display)(void *) =
+            (void *) dlsym(RTLD_DEFAULT, "XOpenDisplay");
+        xcb_connection_t *(*x_get_xcb_connection)(void *) =
+            (void *) dlsym(RTLD_DEFAULT, "XGetXCBConnection");
+
+        if (x_open_display == NULL)
+            return NULL;
+
+        if (x_get_xcb_connection == NULL) {
+            lib = dlopen("libX11-xcb.so.1", RTLD_LOCAL | RTLD_LAZY);
+            x_get_xcb_connection =
+                (void *) dlsym(lib, "XGetXCBConnection");
+        }
+
+        if (x_get_xcb_connection == NULL)
+            goto out;
+
+        void *xdpy = x_open_display(NULL);
+        EGLDisplay dpy = glamor_egl_get_display(EGL_PLATFORM_X11_KHR, xdpy);
+        if (dpy == EGL_NO_DISPLAY)
+            goto out;
+
+        edpy = dpy;
+        eglInitialize(dpy, &major, &minor);
+        ret = x_get_xcb_connection(xdpy);
+out:
+        if (lib)
+            dlclose(lib);
+
+        return ret;
+    }
+
+    return NULL;
+}
+
+void
+ephyr_glamor_set_texture(struct ephyr_glamor *glamor, uint32_t tex)
+{
+    glamor->tex = tex;
+}
+
+static void
+ephyr_glamor_set_vertices(struct ephyr_glamor *glamor)
+{
+    glVertexAttribPointer(glamor->texture_shader_position_loc,
+                          2, GL_FLOAT, FALSE, 0, (void *) 0);
+    glVertexAttribPointer(glamor->texture_shader_texcoord_loc,
+                          2, GL_FLOAT, FALSE, 0, (void *) (sizeof (float) * 8));
+
+    glEnableVertexAttribArray(glamor->texture_shader_position_loc);
+    glEnableVertexAttribArray(glamor->texture_shader_texcoord_loc);
+}
+
+void
+ephyr_glamor_damage_redisplay(struct ephyr_glamor *glamor,
+                              struct pixman_region16 *damage)
+{
+    GLint old_vao;
+
+    /* Skip presenting the output in this mode.  Presentation is
+     * expensive, and if we're just running the X Test suite headless,
+     * nobody's watching.
+     */
+    if (ephyr_glamor_skip_present)
+        return;
+
+    eglMakeCurrent(glamor->dpy, glamor->egl_win, glamor->egl_win, glamor->ctx);
+
+    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);
+    glBindVertexArray(glamor->vao);
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    glUseProgram(glamor->texture_shader);
+    glViewport(0, 0, glamor->width, glamor->height);
+    if (!ephyr_glamor_gles2)
+        glDisable(GL_COLOR_LOGIC_OP);
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, glamor->tex);
+    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+    glBindVertexArray(old_vao);
+
+    eglSwapBuffers(glamor->dpy, glamor->egl_win);
+}
+
+struct ephyr_glamor *
+ephyr_glamor_screen_init(xcb_window_t win, xcb_visualid_t vid)
+{
+    static const float position[] = {
+        -1, -1,
+         1, -1,
+         1,  1,
+        -1,  1,
+        0, 1,
+        1, 1,
+        1, 0,
+        0, 0,
+    };
+    GLint old_vao;
+
+    EGLContext ctx;
+    struct ephyr_glamor *glamor;
+    EGLSurface egl_win;
+
+    glamor = calloc(1, sizeof(struct ephyr_glamor));
+    if (!glamor) {
+        FatalError("malloc");
+        return NULL;
+    }
+
+    const EGLint config_attribs[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_NATIVE_VISUAL_ID, vid,
+        EGL_NONE,
+    };
+    EGLConfig config = EGL_NO_CONFIG_KHR;
+    int num_configs = 0;
+
+    /* (loud booing (see above)) */
+    glamor->dpy = edpy;
+
+    eglChooseConfig(glamor->dpy, config_attribs, &config, 1, &num_configs);
+    if (num_configs != 1)
+        FatalError("Unable to find an EGLConfig for vid %#x\n", vid);
+
+    egl_win = eglCreatePlatformWindowSurfaceEXT(glamor->dpy, config,
+                                                &win, NULL);
+
+    if (ephyr_glamor_gles2)
+        eglBindAPI(EGL_OPENGL_ES_API);
+    else
+        eglBindAPI(EGL_OPENGL_API);
+
+    EGLint context_attribs[5];
+    int i = 0;
+    context_attribs[i++] = EGL_CONTEXT_MAJOR_VERSION;
+    context_attribs[i++] = ephyr_glamor_gles2 ? 2 : 3;
+    context_attribs[i++] = EGL_CONTEXT_MINOR_VERSION;
+    context_attribs[i++] = ephyr_glamor_gles2 ? 0 : 1;
+    context_attribs[i++] = EGL_NONE;
+
+    ctx = eglCreateContext(glamor->dpy, EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
+                           context_attribs);
+
+    if (ctx == NULL)
+        FatalError("eglCreateContext failed\n");
+
+    if (!eglMakeCurrent(glamor->dpy, egl_win, egl_win, ctx))
+        FatalError("eglMakeCurrent failed\n");
+
+    glamor->ctx = ctx;
+    glamor->win = win;
+    glamor->egl_win = egl_win;
+    ephyr_glamor_setup_texturing_shader(glamor);
+
+    glGenVertexArrays(1, &glamor->vao);
+    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);
+    glBindVertexArray(glamor->vao);
+
+    glGenBuffers(1, &glamor->vbo);
+
+    glBindBuffer(GL_ARRAY_BUFFER, glamor->vbo);
+    glBufferData(GL_ARRAY_BUFFER, sizeof (position), position, GL_STATIC_DRAW);
+
+    ephyr_glamor_set_vertices(glamor);
+    glBindVertexArray(old_vao);
+
+    return glamor;
+}
+
+void
+ephyr_glamor_screen_fini(struct ephyr_glamor *glamor)
+{
+    eglMakeCurrent(glamor->dpy,
+                   EGL_NO_SURFACE, EGL_NO_SURFACE,
+                   EGL_NO_CONTEXT);
+    eglDestroyContext(glamor->dpy, glamor->ctx);
+    eglDestroySurface(glamor->dpy, glamor->egl_win);
+
+    free(glamor);
+}
+
+void
+ephyr_glamor_set_window_size(struct ephyr_glamor *glamor,
+                             unsigned width, unsigned height)
+{
+    if (!glamor)
+        return;
+
+    glamor->width = width;
+    glamor->height = height;
+}
diff --git a/hw/kdrive/ephyr/ephyr_glamor_glx.h b/hw/kdrive/ephyr/ephyr_glamor.h
similarity index 82%
rename from hw/kdrive/ephyr/ephyr_glamor_glx.h
rename to hw/kdrive/ephyr/ephyr_glamor.h
index 0c238cf5b..fc4a80d9f 100644
--- a/hw/kdrive/ephyr/ephyr_glamor_glx.h
+++ b/hw/kdrive/ephyr/ephyr_glamor.h
@@ -21,13 +21,6 @@
  * IN THE SOFTWARE.
  */
 
-/**
- * ephyr_glamor_glx.h
- *
- * Prototypes exposed by ephyr_glamor_glx.c, without including any
- * server headers.
- */
-
 #include <xcb/xcb.h>
 #include "dix-config.h"
 
@@ -40,14 +33,11 @@ ephyr_glamor_connect(void);
 void
 ephyr_glamor_set_texture(struct ephyr_glamor *ephyr_glamor, uint32_t tex);
 
-xcb_visualtype_t *
-ephyr_glamor_get_visual(void);
-
 struct ephyr_glamor *
-ephyr_glamor_glx_screen_init(xcb_window_t win);
+ephyr_glamor_screen_init(xcb_window_t win, xcb_visualid_t vid);
 
 void
-ephyr_glamor_glx_screen_fini(struct ephyr_glamor *glamor);
+ephyr_glamor_screen_fini(struct ephyr_glamor *glamor);
 
 #ifdef GLAMOR
 void
@@ -58,9 +48,6 @@ void
 ephyr_glamor_damage_redisplay(struct ephyr_glamor *glamor,
                               struct pixman_region16 *damage);
 
-void
-ephyr_glamor_process_event(xcb_generic_event_t *xev);
-
 #else /* !GLAMOR */
 
 static inline void
@@ -75,9 +62,4 @@ ephyr_glamor_damage_redisplay(struct ephyr_glamor *glamor,
 {
 }
 
-static inline void
-ephyr_glamor_process_event(xcb_generic_event_t *xev)
-{
-}
-
 #endif /* !GLAMOR */
diff --git a/hw/kdrive/ephyr/ephyr_glamor_glx.c b/hw/kdrive/ephyr/ephyr_glamor_glx.c
deleted file mode 100644
index 40b80cbe7..000000000
--- a/hw/kdrive/ephyr/ephyr_glamor_glx.c
+++ /dev/null
@@ -1,429 +0,0 @@
-/*
- * Copyright © 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/** @file ephyr_glamor_glx.c
- *
- * Separate file for hiding Xlib and GLX-using parts of xephyr from
- * the rest of the server-struct-aware build.
- */
-
-#include <stdlib.h>
-#include <X11/Xlib.h>
-#include <X11/Xlibint.h>
-#undef Xcalloc
-#undef Xrealloc
-#undef Xfree
-#include <X11/Xlib-xcb.h>
-#include <xcb/xcb_aux.h>
-#include <pixman.h>
-#include <epoxy/glx.h>
-#include "ephyr_glamor_glx.h"
-#include "os.h"
-#include <X11/Xproto.h>
-
-/* until we need geometry shaders GL3.1 should suffice. */
-/* Xephyr has its own copy of this for build reasons */
-#define GLAMOR_GL_CORE_VER_MAJOR 3
-#define GLAMOR_GL_CORE_VER_MINOR 1
-/** @{
- *
- * global state for Xephyr with glamor.
- *
- * Xephyr can render with multiple windows, but all the windows have
- * to be on the same X connection and all have to have the same
- * visual.
- */
-static Display *dpy;
-static XVisualInfo *visual_info;
-static GLXFBConfig fb_config;
-Bool ephyr_glamor_gles2;
-Bool ephyr_glamor_skip_present;
-/** @} */
-
-/**
- * Per-screen state for Xephyr with glamor.
- */
-struct ephyr_glamor {
-    GLXContext ctx;
-    Window win;
-    GLXWindow glx_win;
-
-    GLuint tex;
-
-    GLuint texture_shader;
-    GLuint texture_shader_position_loc;
-    GLuint texture_shader_texcoord_loc;
-
-    /* Size of the window that we're rendering to. */
-    unsigned width, height;
-
-    GLuint vao, vbo;
-};
-
-static GLint
-ephyr_glamor_compile_glsl_prog(GLenum type, const char *source)
-{
-    GLint ok;
-    GLint prog;
-
-    prog = glCreateShader(type);
-    glShaderSource(prog, 1, (const GLchar **) &source, NULL);
-    glCompileShader(prog);
-    glGetShaderiv(prog, GL_COMPILE_STATUS, &ok);
-    if (!ok) {
-        GLchar *info;
-        GLint size;
-
-        glGetShaderiv(prog, GL_INFO_LOG_LENGTH, &size);
-        info = malloc(size);
-        if (info) {
-            glGetShaderInfoLog(prog, size, NULL, info);
-            ErrorF("Failed to compile %s: %s\n",
-                   type == GL_FRAGMENT_SHADER ? "FS" : "VS", info);
-            ErrorF("Program source:\n%s", source);
-            free(info);
-        }
-        else
-            ErrorF("Failed to get shader compilation info.\n");
-        FatalError("GLSL compile failure\n");
-    }
-
-    return prog;
-}
-
-static GLuint
-ephyr_glamor_build_glsl_prog(GLuint vs, GLuint fs)
-{
-    GLint ok;
-    GLuint prog;
-
-    prog = glCreateProgram();
-    glAttachShader(prog, vs);
-    glAttachShader(prog, fs);
-
-    glLinkProgram(prog);
-    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
-    if (!ok) {
-        GLchar *info;
-        GLint size;
-
-        glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &size);
-        info = malloc(size);
-
-        glGetProgramInfoLog(prog, size, NULL, info);
-        ErrorF("Failed to link: %s\n", info);
-        FatalError("GLSL link failure\n");
-    }
-
-    return prog;
-}
-
-static void
-ephyr_glamor_setup_texturing_shader(struct ephyr_glamor *glamor)
-{
-    const char *vs_source =
-        "attribute vec2 texcoord;\n"
-        "attribute vec2 position;\n"
-        "varying vec2 t;\n"
-        "\n"
-        "void main()\n"
-        "{\n"
-        "    t = texcoord;\n"
-        "    gl_Position = vec4(position, 0, 1);\n"
-        "}\n";
-
-    const char *fs_source =
-        "#ifdef GL_ES\n"
-        "precision mediump float;\n"
-        "#endif\n"
-        "\n"
-        "varying vec2 t;\n"
-        "uniform sampler2D s; /* initially 0 */\n"
-        "\n"
-        "void main()\n"
-        "{\n"
-        "    gl_FragColor = texture2D(s, t);\n"
-        "}\n";
-
-    GLuint fs, vs, prog;
-
-    vs = ephyr_glamor_compile_glsl_prog(GL_VERTEX_SHADER, vs_source);
-    fs = ephyr_glamor_compile_glsl_prog(GL_FRAGMENT_SHADER, fs_source);
-    prog = ephyr_glamor_build_glsl_prog(vs, fs);
-
-    glamor->texture_shader = prog;
-    glamor->texture_shader_position_loc = glGetAttribLocation(prog, "position");
-    assert(glamor->texture_shader_position_loc != -1);
-    glamor->texture_shader_texcoord_loc = glGetAttribLocation(prog, "texcoord");
-    assert(glamor->texture_shader_texcoord_loc != -1);
-}
-
-xcb_connection_t *
-ephyr_glamor_connect(void)
-{
-    dpy = XOpenDisplay(NULL);
-    if (!dpy)
-        return NULL;
-
-    XSetEventQueueOwner(dpy, XCBOwnsEventQueue);
-
-    return XGetXCBConnection(dpy);
-}
-
-void
-ephyr_glamor_set_texture(struct ephyr_glamor *glamor, uint32_t tex)
-{
-    glamor->tex = tex;
-}
-
-static void
-ephyr_glamor_set_vertices(struct ephyr_glamor *glamor)
-{
-    glVertexAttribPointer(glamor->texture_shader_position_loc,
-                          2, GL_FLOAT, FALSE, 0, (void *) 0);
-    glVertexAttribPointer(glamor->texture_shader_texcoord_loc,
-                          2, GL_FLOAT, FALSE, 0, (void *) (sizeof (float) * 8));
-
-    glEnableVertexAttribArray(glamor->texture_shader_position_loc);
-    glEnableVertexAttribArray(glamor->texture_shader_texcoord_loc);
-}
-
-void
-ephyr_glamor_damage_redisplay(struct ephyr_glamor *glamor,
-                              struct pixman_region16 *damage)
-{
-    GLint old_vao;
-
-    /* Skip presenting the output in this mode.  Presentation is
-     * expensive, and if we're just running the X Test suite headless,
-     * nobody's watching.
-     */
-    if (ephyr_glamor_skip_present)
-        return;
-
-    glXMakeCurrent(dpy, glamor->glx_win, glamor->ctx);
-
-    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);
-    glBindVertexArray(glamor->vao);
-
-    glBindFramebuffer(GL_FRAMEBUFFER, 0);
-    glUseProgram(glamor->texture_shader);
-    glViewport(0, 0, glamor->width, glamor->height);
-    if (!ephyr_glamor_gles2)
-        glDisable(GL_COLOR_LOGIC_OP);
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, glamor->tex);
-    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-
-    glBindVertexArray(old_vao);
-
-    glXSwapBuffers(dpy, glamor->glx_win);
-}
-
-/**
- * Xlib-based handling of xcb events for glamor.
- *
- * We need to let the Xlib event filtering run on the event so that
- * Mesa's dri2_glx.c userspace event mangling gets run, and we
- * correctly get our invalidate events propagated into the driver.
- */
-void
-ephyr_glamor_process_event(xcb_generic_event_t *xev)
-{
-
-    uint32_t response_type = xev->response_type & 0x7f;
-    /* Note the types on wire_to_event: there's an Xlib XEvent (with
-     * the broken types) that it returns, and a protocol xEvent that
-     * it inspects.
-     */
-    Bool (*wire_to_event)(Display *dpy, XEvent *ret, xEvent *event);
-
-    XLockDisplay(dpy);
-    /* Set the event handler to NULL to get access to the current one. */
-    wire_to_event = XESetWireToEvent(dpy, response_type, NULL);
-    if (wire_to_event) {
-        XEvent processed_event;
-
-        /* OK they had an event handler.  Plug it back in, and call
-         * through to it.
-         */
-        XESetWireToEvent(dpy, response_type, wire_to_event);
-        xev->sequence = LastKnownRequestProcessed(dpy);
-        wire_to_event(dpy, &processed_event, (xEvent *)xev);
-    }
-    XUnlockDisplay(dpy);
-}
-
-static int
-ephyr_glx_error_handler(Display * _dpy, XErrorEvent * ev)
-{
-    return 0;
-}
-
-struct ephyr_glamor *
-ephyr_glamor_glx_screen_init(xcb_window_t win)
-{
-    int (*oldErrorHandler) (Display *, XErrorEvent *);
-    static const float position[] = {
-        -1, -1,
-         1, -1,
-         1,  1,
-        -1,  1,
-        0, 1,
-        1, 1,
-        1, 0,
-        0, 0,
-    };
-    GLint old_vao;
-
-    GLXContext ctx;
-    struct ephyr_glamor *glamor;
-    GLXWindow glx_win;
-
-    glamor = calloc(1, sizeof(struct ephyr_glamor));
-    if (!glamor) {
-        FatalError("malloc");
-        return NULL;
-    }
-
-    glx_win = glXCreateWindow(dpy, fb_config, win, NULL);
-
-    if (ephyr_glamor_gles2) {
-        static const int context_attribs[] = {
-            GLX_CONTEXT_MAJOR_VERSION_ARB, 2,
-            GLX_CONTEXT_MINOR_VERSION_ARB, 0,
-            GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_ES_PROFILE_BIT_EXT,
-            0,
-        };
-        if (epoxy_has_glx_extension(dpy, DefaultScreen(dpy),
-                                    "GLX_EXT_create_context_es2_profile")) {
-            ctx = glXCreateContextAttribsARB(dpy, fb_config, NULL, True,
-                                             context_attribs);
-        } else {
-            FatalError("Xephyr -glamor_gles2 requires "
-                       "GLX_EXT_create_context_es2_profile\n");
-        }
-    } else {
-        if (epoxy_has_glx_extension(dpy, DefaultScreen(dpy),
-                                    "GLX_ARB_create_context")) {
-            static const int context_attribs[] = {
-                GLX_CONTEXT_PROFILE_MASK_ARB,
-                GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
-                GLX_CONTEXT_MAJOR_VERSION_ARB,
-                GLAMOR_GL_CORE_VER_MAJOR,
-                GLX_CONTEXT_MINOR_VERSION_ARB,
-                GLAMOR_GL_CORE_VER_MINOR,
-                0,
-            };
-            oldErrorHandler = XSetErrorHandler(ephyr_glx_error_handler);
-            ctx = glXCreateContextAttribsARB(dpy, fb_config, NULL, True,
-                                             context_attribs);
-            XSync(dpy, False);
-            XSetErrorHandler(oldErrorHandler);
-        } else {
-            ctx = NULL;
-        }
-
-        if (!ctx)
-            ctx = glXCreateContext(dpy, visual_info, NULL, True);
-    }
-    if (ctx == NULL)
-        FatalError("glXCreateContext failed\n");
-
-    if (!glXMakeCurrent(dpy, glx_win, ctx))
-        FatalError("glXMakeCurrent failed\n");
-
-    glamor->ctx = ctx;
-    glamor->win = win;
-    glamor->glx_win = glx_win;
-    ephyr_glamor_setup_texturing_shader(glamor);
-
-    glGenVertexArrays(1, &glamor->vao);
-    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);
-    glBindVertexArray(glamor->vao);
-
-    glGenBuffers(1, &glamor->vbo);
-
-    glBindBuffer(GL_ARRAY_BUFFER, glamor->vbo);
-    glBufferData(GL_ARRAY_BUFFER, sizeof (position), position, GL_STATIC_DRAW);
-
-    ephyr_glamor_set_vertices(glamor);
-    glBindVertexArray(old_vao);
-
-    return glamor;
-}
-
-void
-ephyr_glamor_glx_screen_fini(struct ephyr_glamor *glamor)
-{
-    glXMakeCurrent(dpy, None, NULL);
-    glXDestroyContext(dpy, glamor->ctx);
-    glXDestroyWindow(dpy, glamor->glx_win);
-
-    free(glamor);
-}
-
-xcb_visualtype_t *
-ephyr_glamor_get_visual(void)
-{
-    xcb_screen_t *xscreen =
-        xcb_aux_get_screen(XGetXCBConnection(dpy), DefaultScreen(dpy));
-    int attribs[] = {
-        GLX_RENDER_TYPE, GLX_RGBA_BIT,
-        GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
-        GLX_RED_SIZE, 1,
-        GLX_GREEN_SIZE, 1,
-        GLX_BLUE_SIZE, 1,
-        GLX_DOUBLEBUFFER, 1,
-        None
-    };
-    int event_base = 0, error_base = 0, nelements;
-    GLXFBConfig *fbconfigs;
-
-    if (!glXQueryExtension (dpy, &error_base, &event_base))
-        FatalError("Couldn't find GLX extension\n");
-
-    fbconfigs = glXChooseFBConfig(dpy, DefaultScreen(dpy), attribs, &nelements);
-    if (!nelements)
-        FatalError("Couldn't choose an FBConfig\n");
-    fb_config = fbconfigs[0];
-    free(fbconfigs);
-
-    visual_info = glXGetVisualFromFBConfig(dpy, fb_config);
-    if (visual_info == NULL)
-        FatalError("Couldn't get RGB visual\n");
-
-    return xcb_aux_find_visual_by_id(xscreen, visual_info->visualid);
-}
-
-void
-ephyr_glamor_set_window_size(struct ephyr_glamor *glamor,
-                             unsigned width, unsigned height)
-{
-    if (!glamor)
-        return;
-
-    glamor->width = width;
-    glamor->height = height;
-}
diff --git a/hw/kdrive/ephyr/ephyrinit.c b/hw/kdrive/ephyr/ephyrinit.c
index 020461db2..09cd28cb3 100644
--- a/hw/kdrive/ephyr/ephyrinit.c
+++ b/hw/kdrive/ephyr/ephyrinit.c
@@ -70,25 +70,23 @@ InitInput(int argc, char **argv)
     KdKeyboardInfo *ki;
     KdPointerInfo *pi;
 
-    if (!SeatId) {
-        KdAddKeyboardDriver(&EphyrKeyboardDriver);
-        KdAddPointerDriver(&EphyrMouseDriver);
-
-        if (!kdHasKbd) {
-            ki = KdNewKeyboard();
-            if (!ki)
-                FatalError("Couldn't create Xephyr keyboard\n");
-            ki->driver = &EphyrKeyboardDriver;
-            KdAddKeyboard(ki);
-        }
+    KdAddKeyboardDriver(&EphyrKeyboardDriver);
+    KdAddPointerDriver(&EphyrMouseDriver);
+
+    if (!kdHasKbd) {
+        ki = KdNewKeyboard();
+        if (!ki)
+            FatalError("Couldn't create Xephyr keyboard\n");
+        ki->driver = &EphyrKeyboardDriver;
+        KdAddKeyboard(ki);
+    }
 
-        if (!kdHasPointer) {
-            pi = KdNewPointer();
-            if (!pi)
-                FatalError("Couldn't create Xephyr pointer\n");
-            pi->driver = &EphyrMouseDriver;
-            KdAddPointer(pi);
-        }
+    if (!kdHasPointer) {
+        pi = KdNewPointer();
+        if (!pi)
+            FatalError("Couldn't create Xephyr pointer\n");
+        pi->driver = &EphyrMouseDriver;
+        KdAddPointer(pi);
     }
 
     KdInitInput();
diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index a5b2e344e..1dc14be38 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -57,7 +57,7 @@
 #ifdef GLAMOR
 #include <epoxy/gl.h>
 #include "glamor.h"
-#include "ephyr_glamor_glx.h"
+#include "ephyr_glamor.h"
 #endif
 #include "ephyrlog.h"
 #include "ephyr.h"
@@ -556,21 +556,7 @@ hostx_init(void)
     HostX.winroot = xscreen->root;
     HostX.gc = xcb_generate_id(HostX.conn);
     HostX.depth = xscreen->root_depth;
-#ifdef GLAMOR
-    if (ephyr_glamor) {
-        HostX.visual = ephyr_glamor_get_visual();
-        if (HostX.visual->visual_id != xscreen->root_visual) {
-            attrs[1] = xcb_generate_id(HostX.conn);
-            attr_mask |= XCB_CW_COLORMAP;
-            xcb_create_colormap(HostX.conn,
-                                XCB_COLORMAP_ALLOC_NONE,
-                                attrs[1],
-                                HostX.winroot,
-                                HostX.visual->visual_id);
-        }
-    } else
-#endif
-        HostX.visual = xcb_aux_find_visual_by_id(xscreen,xscreen->root_visual);
+    HostX.visual = xcb_aux_find_visual_by_id(xscreen, xscreen->root_visual);
 
     xcb_create_gc(HostX.conn, HostX.gc, HostX.winroot, 0, NULL);
     cookie_WINDOW_STATE = xcb_intern_atom(HostX.conn, FALSE,
@@ -586,6 +572,7 @@ hostx_init(void)
         EphyrScrPriv *scrpriv = screen->driver;
 
         scrpriv->win = xcb_generate_id(HostX.conn);
+        scrpriv->vid = xscreen->root_visual;
         scrpriv->server_depth = HostX.depth;
         scrpriv->ximg = NULL;
         scrpriv->win_x = 0;
@@ -1024,7 +1011,8 @@ static void hostx_paint_debug_rect(KdScreenInfo *screen,
 
 void
 hostx_paint_rect(KdScreenInfo *screen,
-                 int sx, int sy, int dx, int dy, int width, int height)
+                 int sx, int sy, int dx, int dy, int width, int height,
+                 Bool sync)
 {
     EphyrScrPriv *scrpriv = screen->driver;
 
@@ -1113,6 +1101,8 @@ hostx_paint_rect(KdScreenInfo *screen,
                           HostX.gc, scrpriv->ximg,
                           scrpriv->shminfo,
                           sx, sy, dx, dy, width, height, FALSE);
+        if (sync)
+            xcb_aux_sync(HostX.conn);
     }
     else {
         xcb_image_t *subimg = xcb_image_subimage(scrpriv->ximg, sx, sy,
@@ -1123,8 +1113,6 @@ hostx_paint_rect(KdScreenInfo *screen,
             xcb_image_destroy(img);
         xcb_image_destroy(subimg);
     }
-
-    xcb_aux_sync(HostX.conn);
 }
 
 static void
@@ -1570,11 +1558,11 @@ ephyr_glamor_init(ScreenPtr screen)
     KdScreenInfo *kd_screen = pScreenPriv->screen;
     EphyrScrPriv *scrpriv = kd_screen->driver;
 
-    scrpriv->glamor = ephyr_glamor_glx_screen_init(scrpriv->win);
+    scrpriv->glamor = ephyr_glamor_screen_init(scrpriv->win, scrpriv->vid);
     ephyr_glamor_set_window_size(scrpriv->glamor,
                                  scrpriv->win_width, scrpriv->win_height);
 
-    if (!glamor_init(screen, 0)) {
+    if (!glamor_init(screen, GLAMOR_USE_EGL_SCREEN)) {
         FatalError("Failed to initialize glamor\n");
         return FALSE;
     }
@@ -1660,7 +1648,7 @@ ephyr_glamor_fini(ScreenPtr screen)
     EphyrScrPriv *scrpriv = kd_screen->driver;
 
     glamor_fini(screen);
-    ephyr_glamor_glx_screen_fini(scrpriv->glamor);
+    ephyr_glamor_screen_fini(scrpriv->glamor);
     scrpriv->glamor = NULL;
 }
 #endif
diff --git a/hw/kdrive/ephyr/hostx.h b/hw/kdrive/ephyr/hostx.h
index 4b2678e58..8b3caf245 100644
--- a/hw/kdrive/ephyr/hostx.h
+++ b/hw/kdrive/ephyr/hostx.h
@@ -146,7 +146,8 @@ void *hostx_screen_init(KdScreenInfo *screen,
 
 void
 hostx_paint_rect(KdScreenInfo *screen,
-                 int sx, int sy, int dx, int dy, int width, int height);
+                 int sx, int sy, int dx, int dy, int width, int height,
+                 Bool sync);
 
 Bool
 hostx_load_keymap(KeySymsPtr keySyms, CARD8 *modmap, XkbControlsPtr controls);
diff --git a/hw/kdrive/ephyr/man/Makefile.am b/hw/kdrive/ephyr/man/Makefile.am
deleted file mode 100644
index e8a372143..000000000
--- a/hw/kdrive/ephyr/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = Xephyr.man
diff --git a/hw/kdrive/ephyr/meson.build b/hw/kdrive/ephyr/meson.build
index 9e329ba67..dff1dfb68 100644
--- a/hw/kdrive/ephyr/meson.build
+++ b/hw/kdrive/ephyr/meson.build
@@ -23,13 +23,12 @@ xephyr_dep = [
 
 xephyr_glamor = []
 if build_glamor
-    srcs += 'ephyr_glamor_glx.c'
+    srcs += 'ephyr_glamor.c'
     if build_xv
         srcs += 'ephyr_glamor_xv.c'
     endif
     xephyr_glamor += glamor
     xephyr_glamor += glamor_egl_stubs
-    xephyr_dep += dependency('x11-xcb')
     xephyr_dep += epoxy_dep
 endif
 
diff --git a/hw/kdrive/src/Makefile.am b/hw/kdrive/src/Makefile.am
deleted file mode 100644
index b1331dae6..000000000
--- a/hw/kdrive/src/Makefile.am
+++ /dev/null
@@ -1,32 +0,0 @@
-AM_CPPFLAGS = 					\
-	@KDRIVE_INCS@				\
-	@KDRIVE_CFLAGS@
-
-AM_CFLAGS =	-DHAVE_DIX_CONFIG_H
-
-noinst_LTLIBRARIES = libkdrive.la
-
-if XV
-KDRIVE_XV_SOURCES =	\
-	kxv.c		\
-	kxv.h
-endif
-
-libkdrive_la_SOURCES =	\
-	kcmap.c		\
-	kdrive.c	\
-	kdrive.h	\
-	kinfo.c		\
-	kinput.c	\
-	kshadow.c	\
-	$(KDRIVE_XV_SOURCES) \
-	$(top_srcdir)/mi/miinitext.c	\
-	$(top_srcdir)/mi/miinitext.h
-
-if CONFIG_UDEV
-libkdrive_la_LIBADD = $(top_builddir)/config/libconfig.la
-else
-if CONFIG_HAL
-libkdrive_la_LIBADD = $(top_builddir)/config/libconfig.la
-endif
-endif
diff --git a/hw/kdrive/src/kdrive.c b/hw/kdrive/src/kdrive.c
index 8de01ccfa..8ee41f908 100644
--- a/hw/kdrive/src/kdrive.c
+++ b/hw/kdrive/src/kdrive.c
@@ -352,7 +352,7 @@ KdUseMsg(void)
     ErrorF
         ("-rgba rgb/bgr/vrgb/vbgr/none   Specify subpixel ordering for LCD panels\n");
     ErrorF
-        ("-mouse driver [,n,,options]    Specify the pointer driver and its options (n is the number of buttons)\n");
+        ("-mouse driver [,n,options]    Specify the pointer driver and its options (n is the number of buttons)\n");
     ErrorF
         ("-keybd driver [,,options]      Specify the keyboard driver and its options\n");
     ErrorF("-xkb-rules       Set default XkbRules value (can be overridden by -keybd options)\n");
@@ -369,7 +369,7 @@ KdUseMsg(void)
     ErrorF("-softCursor      Force software cursor\n");
     ErrorF("-videoTest       Start the server, pause momentarily and exit\n");
     ErrorF
-        ("-origin X,Y      Locates the next screen in the the virtual screen (Xinerama)\n");
+        ("-origin X,Y      Locates the next screen in the virtual screen (Xinerama)\n");
     ErrorF("-switchCmd       Command to execute on vt switch\n");
     ErrorF
         ("vtxx             Use virtual terminal xx instead of the next available\n");
diff --git a/hw/meson.build b/hw/meson.build
index f8bd28a25..0f43ab6e2 100644
--- a/hw/meson.build
+++ b/hw/meson.build
@@ -18,6 +18,10 @@ if build_xquartz
     subdir('xquartz')
 endif
 
+if build_xwayland
+    subdir('xwayland')
+endif
+
 if build_xwin
     subdir('xwin')
 endif
diff --git a/hw/vfb/Makefile.am b/hw/vfb/Makefile.am
deleted file mode 100644
index a4b45264f..000000000
--- a/hw/vfb/Makefile.am
+++ /dev/null
@@ -1,27 +0,0 @@
-SUBDIRS = man
-
-bin_PROGRAMS = Xvfb
-
-AM_CFLAGS = -DHAVE_DIX_CONFIG_H \
-            $(XVFBMODULES_CFLAGS) \
-	    $(DIX_CFLAGS)
-
-SRCS =	InitInput.c \
-	InitOutput.c \
-	$(top_srcdir)/mi/miinitext.c \
-	$(top_srcdir)/mi/miinitext.h
-
-Xvfb_SOURCES = $(SRCS)
-
-XVFB_LIBS = \
-        @XVFB_LIBS@ \
-	$(MAIN_LIB) \
-	$(XSERVER_LIBS) \
-	$(top_builddir)/Xi/libXistubs.la
-
-Xvfb_LDADD = $(XVFB_LIBS) $(XVFB_SYS_LIBS) $(XSERVER_SYS_LIBS)
-Xvfb_DEPENDENCIES = $(XVFB_LIBS)
-Xvfb_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
-
-relink:
-	$(AM_V_at)rm -f Xvfb$(EXEEXT) && $(MAKE) Xvfb$(EXEEXT)
diff --git a/hw/vfb/man/Makefile.am b/hw/vfb/man/Makefile.am
deleted file mode 100644
index 93941882a..000000000
--- a/hw/vfb/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = Xvfb.man
diff --git a/hw/xfree86/Makefile.am b/hw/xfree86/Makefile.am
deleted file mode 100644
index baf380d4d..000000000
--- a/hw/xfree86/Makefile.am
+++ /dev/null
@@ -1,154 +0,0 @@
-
-if DRI
-DRI_SUBDIR = dri
-DRI_LIB = dri/libdri.la
-endif
-
-if DRI2
-DRI2_SUBDIR = dri2
-DRI2_LIB = dri2/libdri2.la
-endif
-
-if DRI3
-DRI3_BUILDDIR = $(top_builddir)/dri3
-DRI3_LIB = $(DRI3_BUILDDIR)/libdri3.la
-endif
-
-if GLX
-GLXVND_LIB = $(top_builddir)/glx/libglxvnd.la
-endif
-
-if GLAMOR_EGL
-GLAMOR_EGL_SUBDIR = glamor_egl
-endif
-
-if XF86UTILS
-XF86UTILS_SUBDIR = utils
-endif
-
-if VGAHW
-VGAHW_SUBDIR = vgahw
-endif
-
-if INT10MODULE
-INT10_SUBDIR = int10
-endif
-
-SUBDIRS = common ddc x86emu $(INT10_SUBDIR) os-support parser \
-	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
-	  $(DRI2_SUBDIR) . i2c dixmods xkb \
-	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man \
-	  $(GLAMOR_EGL_SUBDIR) drivers
-
-DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
-               parser ramdac shadowfb vgahw \
-               loader dixmods xkb dri dri2 exa modes \
-	       utils doc man glamor_egl drivers
-
-bin_PROGRAMS = Xorg
-nodist_Xorg_SOURCES = sdksyms.c
-
-AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/parser \
-	-I$(srcdir)/ddc -I$(srcdir)/i2c -I$(srcdir)/modes -I$(srcdir)/ramdac \
-	-I$(srcdir)/dri -I$(srcdir)/dri2 -I$(top_srcdir)/dri3
-
-LOCAL_LIBS = \
-            $(MAIN_LIB) \
-            $(XSERVER_LIBS) \
-            loader/libloader.la \
-            common/libcommon.la \
-            os-support/libxorgos.la \
-            parser/libxf86config.la \
-            dixmods/libdixmods.la \
-            modes/libxf86modes.la \
-            ramdac/libramdac.la \
-            ddc/libddc.la \
-            i2c/libi2c.la \
-            $(XORG_LIBS) \
-            xkb/libxorgxkb.la \
-            $(DRI_LIB) \
-            $(DRI2_LIB) \
-	    $(DRI3_LIB) \
-	    $(GLXVND_LIB) \
-	    $(top_builddir)/fb/libfb.la \
-	    $(top_builddir)/miext/sync/libsync.la \
-            $(top_builddir)/mi/libmi.la \
-            $(top_builddir)/os/libos.la \
-	    $(top_builddir)/Xext/libXvidmode.la
-
-Xorg_LDADD = \
-            $(LOCAL_LIBS) \
-            $(XORG_SYS_LIBS) \
-            $(XSERVER_SYS_LIBS)
-Xorg_DEPENDENCIES = $(LOCAL_LIBS)
-
-Xorg_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
-
-if SUID_WRAPPER
-wrapexecdir = $(SUID_WRAPPER_DIR)
-wrapexec_PROGRAMS = Xorg.wrap
-Xorg_wrap_SOURCES = xorg-wrapper.c
-endif
-
-BUILT_SOURCES = xorg.conf.example
-DISTCLEANFILES = xorg.conf.example
-EXTRA_DIST = xorgconf.cpp
-
-# Without logdir, X will post an error on the terminal and will not start
-install-data-local:
-	$(AM_V_GEN)$(MKDIR_P) $(DESTDIR)$(logdir)
-if CYGWIN
-	$(INSTALL_DATA) libXorg.exe.a $(DESTDIR)$(libdir)/libXorg.exe.a
-endif
-
-install-exec-hook:
-	(cd $(DESTDIR)$(bindir) && rm -f X && $(LN_S) Xorg$(EXEEXT) X)
-if INSTALL_SETUID
-	chown 0 $(DESTDIR)$(bindir)/Xorg
-	chmod u+s $(DESTDIR)$(bindir)/Xorg
-endif
-if SUID_WRAPPER
-	$(MKDIR_P) $(DESTDIR)$(SUID_WRAPPER_DIR)
-	mv $(DESTDIR)$(bindir)/Xorg $(DESTDIR)$(SUID_WRAPPER_DIR)/Xorg
-	${INSTALL} -m 755 Xorg.sh $(DESTDIR)$(bindir)/Xorg
-	-chown 0 $(DESTDIR)$(SUID_WRAPPER_DIR)/Xorg.wrap && chmod u+s $(DESTDIR)$(SUID_WRAPPER_DIR)/Xorg.wrap
-endif
-
-uninstall-local:
-if CYGWIN
-	$(AM_V_at)rm -f $(DESTDIR)$(libdir)/libXorg.exe.a
-endif
-
-uninstall-hook:
-	$(AM_V_at)rm -f $(DESTDIR)$(bindir)/X
-
-# Use variables from XORG_MANPAGE_SECTIONS and X Server configuration
-# Do not include manpages.am as values are not appropriate for rc files
-CONF_SUBSTS =	-e 's|__filemansuffix__|$(FILE_MAN_SUFFIX)|g' \
-		-e 's|MODULEPATH|$(DEFAULT_MODULE_PATH)|g' \
-		-e 's|DEFAULTFONTPATH|$(COMPILEDDEFAULTFONTPATH)|g'
-
-xorg.conf.example: xorgconf.cpp
-	$(AM_V_GEN)$(SED) $(CONF_SUBSTS) < $(srcdir)/xorgconf.cpp > $@
-
-relink:
-	$(AM_V_at)rm -f Xorg$(EXEEXT) && $(MAKE) Xorg$(EXEEXT)
-
-CLEANFILES = sdksyms.c sdksyms.dep Xorg.sh
-EXTRA_DIST += sdksyms.sh
-
-sdksyms.dep sdksyms.c: sdksyms.sh
-	$(AM_V_GEN)CPP='$(CPP)' AWK='$(AWK)' $(SHELL) $(srcdir)/sdksyms.sh $(top_srcdir) $(CFLAGS) $(AM_CFLAGS) $(AM_CPPFLAGS)
-
-SDKSYMS_DEP = sdksyms.dep
--include $(SDKSYMS_DEP)
-
-i2c/libi2c.la:
-	$(AM_V_at)cd i2c && $(MAKE) libi2c.la
-
-dixmods/libdixmods.la:
-	$(AM_V_at)cd dixmods && $(MAKE) libdixmods.la
-
-xkb/libxorgxkb.la:
-	$(AM_V_at)cd xkb && $(MAKE) libxorgxkb.la
diff --git a/hw/xfree86/common/Makefile.am b/hw/xfree86/common/Makefile.am
deleted file mode 100644
index 39c1e90f0..000000000
--- a/hw/xfree86/common/Makefile.am
+++ /dev/null
@@ -1,104 +0,0 @@
-noinst_LTLIBRARIES = libcommon.la
-
-if XORG_BUS_PCI
-PCI_SOURCES = xf86pciBus.c xf86VGAarbiter.c xf86VGAarbiter.h \
-              xf86VGAarbiterPriv.h
-endif
-
-if XORG_BUS_SPARC
-SBUS_SOURCES = xf86sbusBus.c
-endif
-
-if XV
-XVSOURCES = xf86xv.c xf86xvmc.c
-XVSDKINCS = xf86xv.h xf86xvmc.h xf86xvpriv.h
-endif
-
-if DGA
-DGASOURCES = xf86DGA.c
-DGA_SDK = dgaproc.h
-endif
-
-if XORG_BUS_PLATFORM
-PLATSOURCES = xf86platformBus.c
-endif
-
-RANDRSOURCES = xf86RandR.c
-
-BUSSOURCES = xf86fbBus.c xf86noBus.c $(PCI_SOURCES) $(SBUS_SOURCES) $(PLATSOURCES)
-
-MODEDEFSOURCES = $(srcdir)/vesamodes $(srcdir)/extramodes
-
-xf86DefModeSet.c: $(srcdir)/modeline2c.awk $(MODEDEFSOURCES)
-	$(AM_V_GEN)cat $(MODEDEFSOURCES) | LC_ALL=C $(AWK) -f $(srcdir)/modeline2c.awk > $@
-	$(AM_V_GEN)echo >> $@
-
-BUILT_SOURCES = xf86DefModeSet.c
-
-AM_LDFLAGS = -r
-libcommon_la_SOURCES = xf86Configure.c xf86Bus.c xf86Config.c \
-                      xf86Cursor.c $(DGASOURCES) xf86DPMS.c \
-                      xf86Events.c xf86Globals.c xf86AutoConfig.c \
-                      xf86Option.c xf86Init.c \
-                      xf86VidMode.c xf86fbman.c xf86cmap.c \
-                      xf86Helper.c xf86PM.c xf86Xinput.c xisb.c \
-                      xf86Mode.c xorgHelper.c xf86Extensions.h \
-		      xf86Extensions.c $(XF86VMODESOURCES) \
-                      $(XVSOURCES) $(BUSSOURCES) $(RANDRSOURCES)
-nodist_libcommon_la_SOURCES = xf86DefModeSet.c
-libcommon_la_LIBADD = $(top_builddir)/config/libconfig.la
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../ddc -I$(srcdir)/../i2c \
-	   -I$(srcdir)/../loader -I$(srcdir)/../parser \
-           -I$(srcdir)/../vbe -I$(srcdir)/../int10 \
-	   -I$(srcdir)/../vgahw -I$(srcdir)/../dixmods/extmod \
-	   -I$(srcdir)/../modes -I$(srcdir)/../ramdac -I$(srcdir)/../dri2 \
-	   -I$(top_builddir)
-
-sdk_HEADERS = compiler.h xf86.h xf86Module.h xf86Opt.h \
-              xf86PciInfo.h xf86Priv.h xf86Privstr.h \
-              xf86cmap.h xf86fbman.h xf86str.h xf86Xinput.h xisb.h \
-              $(XVSDKINCS) $(XF86VMODE_SDK) $(DGA_SDK) xorgVersion.h \
-              xf86sbusBus.h xf86VGAarbiter.h xf86Optionstr.h \
-	      xf86platformBus.h xf86MatchDrivers.h \
-	      xaarop.h
-
-CLEANFILES = $(BUILT_SOURCES)
-
-EXTRA_DIST = \
-	compiler.h \
-	xf86.h \
-	xf86Bus.h \
-	xf86Config.h \
-	xf86InPriv.h \
-	xf86Module.h \
-	xf86Opt.h \
-	xf86PciInfo.h \
-	xf86Priv.h \
-	xf86Privstr.h \
-	xf86Xinput.h \
-	xf86cmap.h \
-	xf86fbman.h \
-	xf86pciBus.h \
-	xf86str.h \
-	xf86xv.h \
-	xf86xvmc.h \
-	xf86xvpriv.h \
-	xisb.h \
-	xorgVersion.h \
-	$(MODEDEFSOURCES) \
-	modeline2c.awk \
-	xf86VGAarbiter.h \
-	xf86VGAarbiterPriv.h \
-        $(DISTKBDSOURCES) \
-	xaarop.h
-
-if LNXACPI
-XORG_CFLAGS += -DHAVE_ACPI
-endif
-
-if NEED_DBUS
-XORG_CFLAGS += $(DBUS_CFLAGS)
-endif
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
diff --git a/hw/xfree86/common/xf86AutoConfig.c b/hw/xfree86/common/xf86AutoConfig.c
index 0f4f05de9..ee5587d93 100644
--- a/hw/xfree86/common/xf86AutoConfig.c
+++ b/hw/xfree86/common/xf86AutoConfig.c
@@ -294,18 +294,14 @@ listPossibleVideoDrivers(XF86MatchedDrivers *md)
     xf86PciMatchDriver(md);
 #endif
 
-#if defined(__linux__)
+#if defined(HAVE_MODESETTING_DRIVER)
     xf86AddMatchedDriver(md, "modesetting");
 #endif
 
-#if !defined(__sun)
     /* Fallback to platform default frame buffer driver */
-#if !defined(__linux__) && defined(__sparc__)
-    xf86AddMatchedDriver(md, "wsfb");
-#else
+#if defined(__linux__)
     xf86AddMatchedDriver(md, "fbdev");
 #endif
-#endif                          /* !__sun */
 
     /* Fallback to platform default hardware */
 #if defined(__i386__) || defined(__amd64__) || defined(__hurd__)
@@ -313,6 +309,10 @@ listPossibleVideoDrivers(XF86MatchedDrivers *md)
 #elif defined(__sparc__) && !defined(__sun)
     xf86AddMatchedDriver(md, "sunffb");
 #endif
+
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+    xf86AddMatchedDriver(md, "wsfb");
+#endif
 }
 
 /* copy a screen section and enter the desired driver
diff --git a/hw/xfree86/common/xf86Config.c b/hw/xfree86/common/xf86Config.c
index 5d814c148..41acb25aa 100644
--- a/hw/xfree86/common/xf86Config.c
+++ b/hw/xfree86/common/xf86Config.c
@@ -646,6 +646,7 @@ typedef enum {
     FLAG_MAX_CLIENTS,
     FLAG_IGLX,
     FLAG_DEBUG,
+    FLAG_ALLOW_BYTE_SWAPPED_CLIENTS,
 } FlagValues;
 
 /**
@@ -705,6 +706,8 @@ static OptionInfoRec FlagOptions[] = {
      {0}, FALSE},
     {FLAG_DEBUG, "Debug", OPTV_STRING,
      {0}, FALSE},
+    {FLAG_ALLOW_BYTE_SWAPPED_CLIENTS, "AllowByteSwappedClients", OPTV_BOOLEAN,
+     {0}, FALSE},
     {-1, NULL, OPTV_NONE,
      {0}, FALSE},
 };
@@ -746,6 +749,11 @@ configServerFlags(XF86ConfFlagsPtr flagsconf, XF86OptionPtr layoutopts)
         xf86Msg(X_CONFIG, "Ignoring ABI Version\n");
     }
 
+    xf86GetOptValBool(FlagOptions, FLAG_ALLOW_BYTE_SWAPPED_CLIENTS, &AllowByteSwappedClients);
+    if (AllowByteSwappedClients) {
+        xf86Msg(X_CONFIG, "Allowing byte-swapped clients\n");
+    }
+
     if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ADD_DEVICES)) {
         xf86GetOptValBool(FlagOptions, FLAG_AUTO_ADD_DEVICES,
                           &xf86Info.autoAddDevices);
diff --git a/hw/xfree86/common/xf86Mode.c b/hw/xfree86/common/xf86Mode.c
index eb0885571..16dd529e3 100644
--- a/hw/xfree86/common/xf86Mode.c
+++ b/hw/xfree86/common/xf86Mode.c
@@ -1352,9 +1352,6 @@ xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
     int saveType;
     PixmapFormatRec *BankFormat;
     ClockRangePtr cp;
-    int numTimings = 0;
-    range hsync[MAX_HSYNC];
-    range vrefresh[MAX_VREFRESH];
     Bool inferred_virtual = FALSE;
 
     DebugF
@@ -1394,18 +1391,9 @@ xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
         Bool specified = FALSE;
 
         if (scrp->monitor->nHsync <= 0) {
-            if (numTimings > 0) {
-                scrp->monitor->nHsync = numTimings;
-                for (i = 0; i < numTimings; i++) {
-                    scrp->monitor->hsync[i].lo = hsync[i].lo;
-                    scrp->monitor->hsync[i].hi = hsync[i].hi;
-                }
-            }
-            else {
-                scrp->monitor->hsync[0].lo = 31.5;
-                scrp->monitor->hsync[0].hi = 48.0;
-                scrp->monitor->nHsync = 1;
-            }
+            scrp->monitor->hsync[0].lo = 31.5;
+            scrp->monitor->hsync[0].hi = 48.0;
+            scrp->monitor->nHsync = 1;
             type = "default ";
         }
         else {
@@ -1426,18 +1414,9 @@ xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
 
         type = "";
         if (scrp->monitor->nVrefresh <= 0) {
-            if (numTimings > 0) {
-                scrp->monitor->nVrefresh = numTimings;
-                for (i = 0; i < numTimings; i++) {
-                    scrp->monitor->vrefresh[i].lo = vrefresh[i].lo;
-                    scrp->monitor->vrefresh[i].hi = vrefresh[i].hi;
-                }
-            }
-            else {
-                scrp->monitor->vrefresh[0].lo = 50;
-                scrp->monitor->vrefresh[0].hi = 70;
-                scrp->monitor->nVrefresh = 1;
-            }
+            scrp->monitor->vrefresh[0].lo = 50;
+            scrp->monitor->vrefresh[0].hi = 70;
+            scrp->monitor->nVrefresh = 1;
             type = "default ";
         }
         else {
diff --git a/hw/xfree86/common/xf86Module.h b/hw/xfree86/common/xf86Module.h
index 1eb09bca3..6166e8559 100644
--- a/hw/xfree86/common/xf86Module.h
+++ b/hw/xfree86/common/xf86Module.h
@@ -74,7 +74,7 @@
  * mask is 0xFFFF0000.
  */
 #define ABI_ANSIC_VERSION	SET_ABI_VERSION(0, 4)
-#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(25, 2)
+#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(26, 1)
 #define ABI_XINPUT_VERSION	SET_ABI_VERSION(24, 4)
 #define ABI_EXTENSION_VERSION	SET_ABI_VERSION(10, 0)
 
diff --git a/hw/xfree86/common/xf86platformBus.c b/hw/xfree86/common/xf86platformBus.c
index 45028f7a6..abd09054d 100644
--- a/hw/xfree86/common/xf86platformBus.c
+++ b/hw/xfree86/common/xf86platformBus.c
@@ -272,6 +272,22 @@ xf86PlatformMatchDriver(XF86MatchedDrivers *md)
     }
 }
 
+void xf86PlatformScanPciDev(void)
+{
+    int i;
+
+    if (!xf86scanpci())
+        return;
+
+    xf86Msg(X_CONFIG, "Scanning the platform PCI devices\n");
+    for (i = 0; i < xf86_num_platform_devices; i++) {
+        char *busid = xf86_platform_odev_attributes(i)->busid;
+
+        if (strncmp(busid, "pci:", 4) == 0)
+            platform_find_pci_info(&xf86_platform_devices[i], busid);
+    }
+}
+
 int
 xf86platformProbe(void)
 {
@@ -560,6 +576,9 @@ xf86platformProbeDev(DriverPtr drvp)
                 if (ServerIsNotSeat0()) {
                     break;
                 } else {
+                    /* Accept the device if the driver is hyperv_drm */
+                    if (strcmp(xf86_platform_devices[j].attribs->driver, "hyperv_drm") == 0)
+                        break;
                     /* Accept the device if the driver is simpledrm */
                     if (strcmp(xf86_platform_devices[j].attribs->driver, "simpledrm") == 0)
                         break;
@@ -610,31 +629,58 @@ xf86platformAddGPUDevices(DriverPtr drvp)
     return foundScreen;
 }
 
+const char *
+xf86PlatformFindHotplugDriver(int dev_index)
+{
+    XF86ConfOutputClassPtr cl;
+    const char *hp_driver = NULL;
+    struct xf86_platform_device *dev = &xf86_platform_devices[dev_index];
+
+    for (cl = xf86configptr->conf_outputclass_lst; cl; cl = cl->list.next) {
+        if (!OutputClassMatches(cl, dev) || !cl->option_lst)
+	    continue;
+
+        hp_driver = xf86FindOptionValue(cl->option_lst, "HotplugDriver");
+        if (hp_driver)
+            xf86MarkOptionUsed(cl->option_lst);
+    }
+
+    /* Return the first driver from the match list */
+    xf86Msg(X_INFO, "matching hotplug-driver is %s\n",
+            hp_driver ? hp_driver : "none");
+    return hp_driver;
+}
+
 int
-xf86platformAddDevice(int index)
+xf86platformAddDevice(const char *driver_name, int index)
 {
     int i, old_screens, scr_index, scrnum;
     DriverPtr drvp = NULL;
     screenLayoutPtr layout;
-    static const char *hotplug_driver_name = "modesetting";
 
     if (!xf86Info.autoAddGPU)
         return -1;
 
-    /* force load the driver for now */
-    xf86LoadOneModule(hotplug_driver_name, NULL);
+    /* Load modesetting driver if no driver given, or driver open failed */
+    if (!driver_name || !xf86LoadOneModule(driver_name, NULL)) {
+        driver_name = "modesetting";
+        xf86LoadOneModule(driver_name, NULL);
+    }
 
     for (i = 0; i < xf86NumDrivers; i++) {
         if (!xf86DriverList[i])
             continue;
 
-        if (!strcmp(xf86DriverList[i]->driverName, hotplug_driver_name)) {
+        if (!strcmp(xf86DriverList[i]->driverName, driver_name)) {
             drvp = xf86DriverList[i];
             break;
         }
     }
-    if (i == xf86NumDrivers)
+
+    if (i == xf86NumDrivers) {
+        ErrorF("can't find driver %s for hotplugged device\n", driver_name);
         return -1;
+    }
 
     old_screens = xf86NumGPUScreens;
     doPlatformProbe(&xf86_platform_devices[index], drvp, NULL,
@@ -669,7 +715,7 @@ xf86platformAddDevice(int index)
    dixSetPrivate(&xf86GPUScreens[i]->pScreen->devPrivates,
                  xf86ScreenKey, xf86GPUScreens[i]);
 
-   CreateScratchPixmapsForScreen(xf86GPUScreens[i]->pScreen);
+   PixmapScreenInit(xf86GPUScreens[i]->pScreen);
 
    if (xf86GPUScreens[i]->pScreen->CreateScreenResources &&
        !(*xf86GPUScreens[i]->pScreen->CreateScreenResources) (xf86GPUScreens[i]->pScreen)) {
diff --git a/hw/xfree86/common/xf86platformBus.h b/hw/xfree86/common/xf86platformBus.h
index 1e75e6352..9979106a1 100644
--- a/hw/xfree86/common/xf86platformBus.h
+++ b/hw/xfree86/common/xf86platformBus.h
@@ -44,6 +44,8 @@ int xf86platformProbe(void);
 int xf86platformProbeDev(DriverPtr drvp);
 int xf86platformAddGPUDevices(DriverPtr drvp);
 void xf86MergeOutputClassOptions(int entityIndex, void **options);
+void xf86PlatformScanPciDev(void);
+const char *xf86PlatformFindHotplugDriver(int dev_index);
 
 extern int xf86_num_platform_devices;
 extern struct xf86_platform_device *xf86_platform_devices;
@@ -56,7 +58,7 @@ extern Bool
 xf86_get_platform_device_unowned(int index);
 
 extern int
-xf86platformAddDevice(int index);
+xf86platformAddDevice(const char *driver_name, int index);
 extern void
 xf86platformRemoveDevice(int index);
 
diff --git a/hw/xfree86/ddc/Makefile.am b/hw/xfree86/ddc/Makefile.am
deleted file mode 100644
index a7b84adcd..000000000
--- a/hw/xfree86/ddc/Makefile.am
+++ /dev/null
@@ -1,11 +0,0 @@
-sdk_HEADERS = edid.h xf86DDC.h
-
-noinst_LTLIBRARIES = libddc.la
-
-libddc_la_SOURCES = ddc.c interpret_edid.c print_edid.c ddcProperty.c
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../i2c
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-EXTRA_DIST = DDC.HOWTO
diff --git a/hw/xfree86/dixmods/Makefile.am b/hw/xfree86/dixmods/Makefile.am
deleted file mode 100644
index 3d5811066..000000000
--- a/hw/xfree86/dixmods/Makefile.am
+++ /dev/null
@@ -1,41 +0,0 @@
-noinst_LTLIBRARIES = libdixmods.la
-
-if GLX
-GLXMODS = libglx.la
-endif
-
-module_LTLIBRARIES = libwfb.la \
-                     libshadow.la
-
-extsmoduledir = $(moduledir)/extensions
-extsmodule_LTLIBRARIES = $(GLXMODS)
-
-AM_CFLAGS = @XORG_CFLAGS@ @DIX_CFLAGS@
-AM_CPPFLAGS = @XORG_INCS@ \
-           -I$(top_srcdir)/hw/xfree86/loader \
-           -I$(top_srcdir)/miext/shadow \
-           -I$(top_srcdir)/glx
-
-libwfb_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-libwfb_la_LIBADD = $(top_builddir)/fb/libwfb.la
-libwfb_la_SOURCES = fbmodule.c
-libwfb_la_CFLAGS = $(AM_CFLAGS) -DFB_ACCESS_WRAPPER
-
-libglx_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-libglx_la_LIBADD = $(top_builddir)/glx/libglx.la $(GLX_SYS_LIBS)
-if DRI2
-libglx_la_LIBADD += $(top_builddir)/glx/libglxdri.la
-if NO_UNDEFINED
-libglx_la_LIBADD += $(LIBDRM_LIBS) $(PIXMAN_LIBS)
-endif
-endif
-libglx_la_SOURCES = glxmodule.c
-
-libshadow_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-libshadow_la_LIBADD = $(top_builddir)/miext/shadow/libshadow.la
-libshadow_la_SOURCES = shmodule.c
-
-libdixmods_la_SOURCES = \
-	$(top_srcdir)/mi/miinitext.c \
-	$(top_srcdir)/mi/miinitext.h
-libdixmods_la_CFLAGS = $(AM_CFLAGS)
diff --git a/hw/xfree86/doc/Makefile.am b/hw/xfree86/doc/Makefile.am
deleted file mode 100644
index 392bdfa03..000000000
--- a/hw/xfree86/doc/Makefile.am
+++ /dev/null
@@ -1,17 +0,0 @@
-
-if ENABLE_DEVEL_DOCS
-if HAVE_XMLTO
-
-# Main DocBook/XML files (DOCTYPE book)
-docbook = ddxDesign.xml
-
-# Generate DocBook/XML output formats with or without stylesheets
-include $(top_srcdir)/devbook.am
-
-endif HAVE_XMLTO
-endif ENABLE_DEVEL_DOCS
-
-EXTRA_DIST =		\
-	Registry	\
-	exa-driver.txt	\
-	README.modes
diff --git a/hw/xfree86/dri/Makefile.am b/hw/xfree86/dri/Makefile.am
deleted file mode 100644
index ced04ff38..000000000
--- a/hw/xfree86/dri/Makefile.am
+++ /dev/null
@@ -1,20 +0,0 @@
-noinst_LTLIBRARIES = libdri.la
-AM_CFLAGS = -I$(top_srcdir)/hw/xfree86/common \
-            -I$(top_srcdir)/hw/xfree86/os-support \
-            -I$(top_srcdir)/hw/xfree86/modes \
-            -I$(top_srcdir)/hw/xfree86/ddc \
-            -I$(top_srcdir)/hw/xfree86/i2c \
-            -I$(top_srcdir)/hw/xfree86/parser \
-            -I$(top_srcdir)/hw/xfree86/ramdac \
-            -I$(top_srcdir)/hw/xfree86/os-support/bus \
-            -I$(top_srcdir)/glx \
-            -DHAVE_XORG_CONFIG_H \
-            @DIX_CFLAGS@ @XORG_CFLAGS@
-libdri_la_SOURCES = \
-	dri.c \
-	dri.h \
-	dristruct.h \
-	sarea.h \
-	xf86dri.c
-
-sdk_HEADERS = dri.h sarea.h dristruct.h
diff --git a/hw/xfree86/dri2/Makefile.am b/hw/xfree86/dri2/Makefile.am
deleted file mode 100644
index 78e507bd3..000000000
--- a/hw/xfree86/dri2/Makefile.am
+++ /dev/null
@@ -1,16 +0,0 @@
-SUBDIRS=pci_ids
-
-noinst_LTLIBRARIES = libdri2.la
-AM_CFLAGS = \
-	-DHAVE_XORG_CONFIG_H \
-	@DIX_CFLAGS@ @XORG_CFLAGS@ \
-	-I$(top_srcdir)/hw/xfree86/common \
-	-I$(top_srcdir)/hw/xfree86/os-support/bus
-
-libdri2_la_SOURCES = \
-	dri2.c \
-	dri2.h \
-	dri2ext.c \
-	dri2int.h
-
-sdk_HEADERS = dri2.h
diff --git a/hw/xfree86/dri2/pci_ids/Makefile.am b/hw/xfree86/dri2/pci_ids/Makefile.am
deleted file mode 100644
index 69fe8c40d..000000000
--- a/hw/xfree86/dri2/pci_ids/Makefile.am
+++ /dev/null
@@ -1,12 +0,0 @@
-EXTRA_DIST = \
-	pci_id_driver_map.h \
-	i810_pci_ids.h \
-	i915_pci_ids.h \
-	i965_pci_ids.h \
-	r200_pci_ids.h \
-	r300_pci_ids.h \
-	r600_pci_ids.h \
-	radeon_pci_ids.h \
-	radeonsi_pci_ids.h \
-	virtio_gpu_pci_ids.h \
-	vmwgfx_pci_ids.h
diff --git a/hw/xfree86/drivers/Makefile.am b/hw/xfree86/drivers/Makefile.am
deleted file mode 100644
index 954c9f1d4..000000000
--- a/hw/xfree86/drivers/Makefile.am
+++ /dev/null
@@ -1,8 +0,0 @@
-SUBDIRS =
-
-if XORG_DRIVER_MODESETTING
-SUBDIRS += modesetting
-endif
-if XORG_DRIVER_INPUT_INPUTTEST
-SUBDIRS += inputtest
-endif
diff --git a/hw/xfree86/drivers/inputtest/Makefile.am b/hw/xfree86/drivers/inputtest/Makefile.am
deleted file mode 100644
index f6210aa8d..000000000
--- a/hw/xfree86/drivers/inputtest/Makefile.am
+++ /dev/null
@@ -1,48 +0,0 @@
-#  Copyright 2005 Adam Jackson.
-#
-#  Permission is hereby granted, free of charge, to any person obtaining a
-#  copy of this software and associated documentation files (the "Software"),
-#  to deal in the Software without restriction, including without limitation
-#  on the rights to use, copy, modify, merge, publish, distribute, sub
-#  license, and/or sell copies of the Software, and to permit persons to whom
-#  the Software is furnished to do so, subject to the following conditions:
-#
-#  The above copyright notice and this permission notice (including the next
-#  paragraph) shall be included in all copies or substantial portions of the
-#  Software.
-#
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-#  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
-#  ADAM JACKSON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-# this is obnoxious:
-# -module lets us name the module exactly how we want
-# -avoid-version prevents gratuitous .0.0.0 version numbers on the end
-# _ladir passes a dummy rpath to libtool so the thing will actually link
-# TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
-
-include $(top_srcdir)/manpages.am
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS) $(CWARNFLAGS)
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-inputtest_drv_la_LTLIBRARIES = inputtest_drv.la
-inputtest_drv_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-inputtest_drv_ladir = @moduledir@/input
-
-inputtest_drv_la_SOURCES = xf86-input-inputtest.c xf86-input-inputtest-protocol.h
-
-sdk_HEADERS = xf86-input-inputtest-protocol.h
-
-drivermandir = $(DRIVER_MAN_DIR)
-driverman_PRE = inputtestdrv.man
-driverman_DATA = $(driverman_PRE:man=@DRIVER_MAN_SUFFIX@)
-
-EXTRA_DIST = inputtestdrv.man
-
-CLEANFILES = $(driverman_DATA)
-
diff --git a/hw/xfree86/drivers/modesetting/Makefile.am b/hw/xfree86/drivers/modesetting/Makefile.am
deleted file mode 100644
index 961c57408..000000000
--- a/hw/xfree86/drivers/modesetting/Makefile.am
+++ /dev/null
@@ -1,66 +0,0 @@
-#  Copyright 2005 Adam Jackson.
-#
-#  Permission is hereby granted, free of charge, to any person obtaining a
-#  copy of this software and associated documentation files (the "Software"),
-#  to deal in the Software without restriction, including without limitation
-#  on the rights to use, copy, modify, merge, publish, distribute, sub
-#  license, and/or sell copies of the Software, and to permit persons to whom
-#  the Software is furnished to do so, subject to the following conditions:
-#
-#  The above copyright notice and this permission notice (including the next
-#  paragraph) shall be included in all copies or substantial portions of the
-#  Software.
-#
-#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-#  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
-#  ADAM JACKSON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-# this is obnoxious:
-# -module lets us name the module exactly how we want
-# -avoid-version prevents gratuitous .0.0.0 version numbers on the end
-# _ladir passes a dummy rpath to libtool so the thing will actually link
-# TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
-
-include $(top_srcdir)/manpages.am
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS) $(LIBDRM_CFLAGS) $(UDEV_CFLAGS) $(CWARNFLAGS)
-
-AM_CPPFLAGS = \
-	$(XORG_INCS) \
-	-I$(top_srcdir)/glamor \
-	-I$(srcdir)/../../ddc \
-	-I$(srcdir)/../../dri2 \
-	-I$(srcdir)/../../i2c \
-	-I$(srcdir)/../../modes \
-	-I$(srcdir)/../../parser \
-	-I$(srcdir)/../../ramdac \
-	$(NULL)
-
-modesetting_drv_la_LTLIBRARIES = modesetting_drv.la
-modesetting_drv_la_LDFLAGS = -module -avoid-version
-modesetting_drv_la_LIBADD = $(UDEV_LIBS) $(DRM_LIBS)
-modesetting_drv_ladir = @moduledir@/drivers
-
-modesetting_drv_la_SOURCES = \
-	 dri2.c \
-	 driver.c \
-	 driver.h \
-	 drmmode_display.c \
-	 drmmode_display.h \
-	 dumb_bo.c \
-	 dumb_bo.h \
-	 present.c \
-	 vblank.c \
-	 pageflip.c \
-	 $(NULL)
-
-drivermandir = $(DRIVER_MAN_DIR)
-driverman_PRE = modesetting.man
-driverman_DATA = $(driverman_PRE:man=@DRIVER_MAN_SUFFIX@)
-
-EXTRA_DIST = modesetting.man
-
-CLEANFILES = $(driverman_DATA)
diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 535f49d1d..3f185489e 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -145,6 +145,7 @@ static const OptionInfoRec Options[] = {
     {OPTION_VARIABLE_REFRESH, "VariableRefresh", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_USE_GAMMA_LUT, "UseGammaLUT", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_ASYNC_FLIP_SECONDARIES, "AsyncFlipSecondaries", OPTV_BOOLEAN, {0}, FALSE},
+    {OPTION_TEARFREE, "TearFree", OPTV_BOOLEAN, {0}, FALSE},
     {-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
@@ -515,15 +516,49 @@ GetRec(ScrnInfoPtr pScrn)
     return TRUE;
 }
 
+static void
+rotate_clip(PixmapPtr pixmap, BoxPtr rect, drmModeClip *clip, Rotation rotation)
+{
+    int w = pixmap->drawable.width;
+    int h = pixmap->drawable.height;
+
+    if (rotation == RR_Rotate_90) {
+	/* Rotate 90 degrees counter clockwise */
+        clip->x1 = rect->y1;
+	clip->x2 = rect->y2;
+	clip->y1 = w - rect->x2;
+	clip->y2 = w - rect->x1;
+    } else if (rotation == RR_Rotate_180) {
+	/* Rotate 180 degrees */
+        clip->x1 = w - rect->x2;
+	clip->x2 = w - rect->x1;
+	clip->y1 = h - rect->y2;
+	clip->y2 = h - rect->y1;
+    } else if (rotation == RR_Rotate_270) {
+	/* Rotate 90 degrees clockwise */
+        clip->x1 = h - rect->y2;
+	clip->x2 = h - rect->y1;
+	clip->y1 = rect->x1;
+	clip->y2 = rect->x2;
+    } else {
+	clip->x1 = rect->x1;
+	clip->x2 = rect->x2;
+	clip->y1 = rect->y1;
+	clip->y2 = rect->y2;
+    }
+}
+
 static int
-dispatch_dirty_region(ScrnInfoPtr scrn,
-                      PixmapPtr pixmap, DamagePtr damage, int fb_id)
+dispatch_damages(ScrnInfoPtr scrn, xf86CrtcPtr crtc, RegionPtr dirty,
+                 PixmapPtr pixmap, DamagePtr damage, int fb_id)
 {
     modesettingPtr ms = modesettingPTR(scrn);
-    RegionPtr dirty = DamageRegion(damage);
     unsigned num_cliprects = REGION_NUM_RECTS(dirty);
     int ret = 0;
 
+    if (!ms->dirty_enabled)
+        return 0;
+
     if (num_cliprects) {
         drmModeClip *clip = xallocarray(num_cliprects, sizeof(drmModeClip));
         BoxPtr rect = REGION_RECTS(dirty);
@@ -532,13 +567,9 @@ dispatch_dirty_region(ScrnInfoPtr scrn,
         if (!clip)
             return -ENOMEM;
 
-        /* XXX no need for copy? */
-        for (i = 0; i < num_cliprects; i++, rect++) {
-            clip[i].x1 = rect->x1;
-            clip[i].y1 = rect->y1;
-            clip[i].x2 = rect->x2;
-            clip[i].y2 = rect->y2;
-        }
+        /* Rotate and copy rects into clips */
+        for (i = 0; i < num_cliprects; i++, rect++)
+	    rotate_clip(pixmap, rect, &clip[i], crtc->rotation);
 
         /* TODO query connector property to see if this is needed */
         ret = drmModeDirtyFB(ms->fd, fb_id, clip, num_cliprects);
@@ -551,30 +582,128 @@ dispatch_dirty_region(ScrnInfoPtr scrn,
             }
         }
 
+        if (ret == -EINVAL || ret == -ENOSYS) {
+            xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                       "Disabling kernel dirty updates, not required.\n");
+            ms->dirty_enabled = FALSE;
+        }
+
         free(clip);
-        DamageEmpty(damage);
+        if (damage)
+            DamageEmpty(damage);
     }
     return ret;
 }
 
+static int
+dispatch_dirty_region(ScrnInfoPtr scrn, xf86CrtcPtr crtc,
+                      PixmapPtr pixmap, DamagePtr damage, int fb_id)
+{
+    return dispatch_damages(scrn, crtc, DamageRegion(damage),
+                            pixmap, damage, fb_id);
+}
+
+static void
+ms_tearfree_update_damages(ScreenPtr pScreen)
+{
+    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    modesettingPtr ms = modesettingPTR(scrn);
+    RegionPtr dirty = DamageRegion(ms->damage);
+    int c, i;
+
+    if (RegionNil(dirty))
+        return;
+
+    for (c = 0; c < xf86_config->num_crtc; c++) {
+        xf86CrtcPtr crtc = xf86_config->crtc[c];
+        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+        drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+        RegionRec region;
+
+        /* Compute how much of the damage intersects with this CRTC */
+        RegionInit(&region, &crtc->bounds, 0);
+        RegionIntersect(&region, &region, dirty);
+
+        if (trf->buf[0].px) {
+            for (i = 0; i < ARRAY_SIZE(trf->buf); i++)
+                RegionUnion(&trf->buf[i].dmg, &trf->buf[i].dmg, &region);
+        } else {
+            /* Just notify the kernel of the damages if TearFree isn't used */
+            dispatch_damages(scrn, crtc, &region,
+                             pScreen->GetScreenPixmap(pScreen),
+                             NULL, ms->drmmode.fb_id);
+        }
+    }
+    DamageEmpty(ms->damage);
+}
+
+static void
+ms_tearfree_do_flips(ScreenPtr pScreen)
+{
+#ifdef GLAMOR_HAS_GBM
+    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    modesettingPtr ms = modesettingPTR(scrn);
+    int c;
+
+    if (!ms->drmmode.tearfree_enable)
+        return;
+
+    for (c = 0; c < xf86_config->num_crtc; c++) {
+        xf86CrtcPtr crtc = xf86_config->crtc[c];
+        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+        drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+
+        /* Skip disabled CRTCs and those which aren't using TearFree */
+        if (!trf->buf[0].px || !crtc->scrn->vtSema || !xf86_crtc_on(crtc))
+            continue;
+
+        /* Skip if the last flip is still pending, a DRI client is flipping, or
+         * there isn't any damage on the front buffer.
+         */
+        if (trf->flip_seq || ms->drmmode.dri2_flipping ||
+            ms->drmmode.present_flipping ||
+            RegionNil(&trf->buf[trf->back_idx ^ 1].dmg))
+            continue;
+
+        /* Flip. If it fails, notify the kernel of the front buffer damages */
+        if (ms_do_tearfree_flip(pScreen, crtc)) {
+            dispatch_damages(scrn, crtc, &trf->buf[trf->back_idx ^ 1].dmg,
+                             trf->buf[trf->back_idx ^ 1].px, NULL,
+                             trf->buf[trf->back_idx ^ 1].fb_id);
+            RegionEmpty(&trf->buf[trf->back_idx ^ 1].dmg);
+        }
+    }
+#endif
+}
+
 static void
 dispatch_dirty(ScreenPtr pScreen)
 {
     ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
     modesettingPtr ms = modesettingPTR(scrn);
     PixmapPtr pixmap = pScreen->GetScreenPixmap(pScreen);
-    int fb_id = ms->drmmode.fb_id;
-    int ret;
+    uint32_t fb_id;
+    int ret, c, x, y ;
 
-    ret = dispatch_dirty_region(scrn, pixmap, ms->damage, fb_id);
-    if (ret == -EINVAL || ret == -ENOSYS) {
-        ms->dirty_enabled = FALSE;
-        DamageUnregister(ms->damage);
-        DamageDestroy(ms->damage);
-        ms->damage = NULL;
-        xf86DrvMsg(scrn->scrnIndex, X_INFO,
-                   "Disabling kernel dirty updates, not required.\n");
-        return;
+    for (c = 0; c < xf86_config->num_crtc; c++) {
+        xf86CrtcPtr crtc = xf86_config->crtc[c];
+        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+        if (!drmmode_crtc)
+            continue;
+
+	drmmode_crtc_get_fb_id(crtc, &fb_id, &x, &y);
+
+        ret = dispatch_dirty_region(scrn, crtc, pixmap, ms->damage, fb_id);
+        if (ret == -EINVAL || ret == -ENOSYS) {
+            DamageUnregister(ms->damage);
+            DamageDestroy(ms->damage);
+            ms->damage = NULL;
+            return;
+        }
     }
 }
 
@@ -586,7 +715,7 @@ dispatch_dirty_pixmap(ScrnInfoPtr scrn, xf86CrtcPtr crtc, PixmapPtr ppix)
     DamagePtr damage = ppriv->secondary_damage;
     int fb_id = ppriv->fb_id;
 
-    dispatch_dirty_region(scrn, ppix, damage, fb_id);
+    dispatch_dirty_region(scrn, crtc, ppix, damage, fb_id);
 }
 
 static void
@@ -703,10 +832,13 @@ msBlockHandler(ScreenPtr pScreen, void *timeout)
     pScreen->BlockHandler = msBlockHandler;
     if (pScreen->isGPU && !ms->drmmode.reverse_prime_offload_mode)
         dispatch_secondary_dirty(pScreen);
+    else if (ms->drmmode.tearfree_enable)
+        ms_tearfree_update_damages(pScreen);
     else if (ms->dirty_enabled)
         dispatch_dirty(pScreen);
 
     ms_dirty_update(pScreen, timeout);
+    ms_tearfree_do_flips(pScreen);
 }
 
 static void
@@ -1238,9 +1370,34 @@ PreInit(ScrnInfoPtr pScrn, int flags)
     if (xf86ReturnOptValBool(ms->drmmode.Options, OPTION_ATOMIC, FALSE)) {
         ret = drmSetClientCap(ms->fd, DRM_CLIENT_CAP_ATOMIC, 1);
         ms->atomic_modeset = (ret == 0);
+        if (!ms->atomic_modeset)
+            xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Atomic modesetting not supported\n");
     } else {
         ms->atomic_modeset = FALSE;
     }
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+               "Atomic modesetting %sabled\n", ms->atomic_modeset ? "en" : "dis");
+
+    /* TearFree requires glamor and, if PageFlip is enabled, universal planes */
+    if (xf86ReturnOptValBool(ms->drmmode.Options, OPTION_TEARFREE, FALSE)) {
+        if (pScrn->is_gpu) {
+            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+                       "TearFree cannot synchronize PRIME; use 'PRIME Synchronization' instead\n");
+        } else if (ms->drmmode.glamor) {
+            /* Atomic modesetting implicitly enables universal planes */
+            if (!ms->drmmode.pageflip || ms->atomic_modeset ||
+                !drmSetClientCap(ms->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1)) {
+                ms->drmmode.tearfree_enable = TRUE;
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "TearFree: enabled\n");
+            } else {
+                xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+                           "TearFree requires either universal planes, or setting 'Option \"PageFlip\" \"off\"'\n");
+            }
+        } else {
+            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+                       "TearFree requires Glamor acceleration\n");
+        }
+    }
 
     ms->kms_has_modifiers = FALSE;
     ret = drmGetCap(ms->fd, DRM_CAP_ADDFB2_MODIFIERS, &value);
@@ -1589,13 +1746,13 @@ CreateScreenResources(ScreenPtr pScreen)
 
     err = drmModeDirtyFB(ms->fd, ms->drmmode.fb_id, NULL, 0);
 
-    if (err != -EINVAL && err != -ENOSYS) {
+    if ((err != -EINVAL && err != -ENOSYS) || ms->drmmode.tearfree_enable) {
         ms->damage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
                                   pScreen, rootPixmap);
 
         if (ms->damage) {
             DamageRegister(&rootPixmap->drawable, ms->damage);
-            ms->dirty_enabled = TRUE;
+            ms->dirty_enabled = err != -EINVAL && err != -ENOSYS;
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Damage tracking initialized\n");
         }
         else {
diff --git a/hw/xfree86/drivers/modesetting/driver.h b/hw/xfree86/drivers/modesetting/driver.h
index 71aa8730e..3f2b1d1ae 100644
--- a/hw/xfree86/drivers/modesetting/driver.h
+++ b/hw/xfree86/drivers/modesetting/driver.h
@@ -61,6 +61,7 @@ typedef enum {
     OPTION_VARIABLE_REFRESH,
     OPTION_USE_GAMMA_LUT,
     OPTION_ASYNC_FLIP_SECONDARIES,
+    OPTION_TEARFREE,
 } modesettingOpts;
 
 typedef struct
@@ -86,10 +87,13 @@ struct ms_drm_queue {
     struct xorg_list list;
     xf86CrtcPtr crtc;
     uint32_t seq;
+    uint64_t msc;
     void *data;
     ScrnInfoPtr scrn;
     ms_drm_handler_proc handler;
     ms_drm_abort_proc abort;
+    Bool kernel_queued;
+    Bool aborted;
 };
 
 typedef struct _modesettingRec {
@@ -238,6 +242,8 @@ Bool ms_do_pageflip(ScreenPtr screen,
                     ms_pageflip_abort_proc pageflip_abort,
                     const char *log_prefix);
 
+Bool ms_do_tearfree_flip(ScreenPtr screen, xf86CrtcPtr crtc);
+
 #endif
 
 int ms_flush_drm_events(ScreenPtr screen);
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 48dccad73..8f8e4060a 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -519,13 +519,13 @@ connector_add_prop(drmModeAtomicReq *req, drmmode_output_private_ptr drmmode_out
 }
 
 static int
-drmmode_CompareKModes(drmModeModeInfo * kmode, drmModeModeInfo * other)
+drmmode_CompareKModes(const drmModeModeInfo * kmode, const drmModeModeInfo * other)
 {
     return memcmp(kmode, other, sizeof(*kmode));
 }
 
 static int
-drm_mode_ensure_blob(xf86CrtcPtr crtc, drmModeModeInfo mode_info)
+drm_mode_ensure_blob(xf86CrtcPtr crtc, const drmModeModeInfo* mode_info)
 {
     modesettingPtr ms = modesettingPTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
@@ -533,14 +533,14 @@ drm_mode_ensure_blob(xf86CrtcPtr crtc, drmModeModeInfo mode_info)
     int ret;
 
     if (drmmode_crtc->current_mode &&
-        drmmode_CompareKModes(&drmmode_crtc->current_mode->mode_info, &mode_info) == 0)
+        drmmode_CompareKModes(&drmmode_crtc->current_mode->mode_info, mode_info) == 0)
         return 0;
 
     mode = calloc(sizeof(drmmode_mode_rec), 1);
     if (!mode)
         return -1;
 
-    mode->mode_info = mode_info;
+    mode->mode_info = *mode_info;
     ret = drmModeCreatePropertyBlob(ms->fd,
                                     &mode->mode_info,
                                     sizeof(mode->mode_info),
@@ -589,7 +589,7 @@ crtc_add_dpms_props(drmModeAtomicReq *req, xf86CrtcPtr crtc,
         drmModeModeInfo kmode;
 
         drmmode_ConvertToKMode(crtc->scrn, &kmode, &crtc->mode);
-        ret |= drm_mode_ensure_blob(crtc, kmode);
+        ret |= drm_mode_ensure_blob(crtc, &kmode);
 
         ret |= crtc_add_prop(req, drmmode_crtc,
                              DRMMODE_CRTC_ACTIVE, 1);
@@ -627,11 +627,12 @@ drmmode_crtc_can_test_mode(xf86CrtcPtr crtc)
     return ms->atomic_modeset;
 }
 
-static Bool
+Bool
 drmmode_crtc_get_fb_id(xf86CrtcPtr crtc, uint32_t *fb_id, int *x, int *y)
 {
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
+    drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
     int ret;
 
     *fb_id = 0;
@@ -646,6 +647,10 @@ drmmode_crtc_get_fb_id(xf86CrtcPtr crtc, uint32_t *fb_id, int *x, int *y)
             *x = drmmode_crtc->prime_pixmap_x;
         *y = 0;
     }
+    else if (trf->buf[trf->back_idx ^ 1].px) {
+        *fb_id = trf->buf[trf->back_idx ^ 1].fb_id;
+        *x = *y = 0;
+    }
     else if (drmmode_crtc->rotate_fb_id) {
         *fb_id = drmmode_crtc->rotate_fb_id;
         *x = *y = 0;
@@ -922,6 +927,10 @@ drmmode_crtc_set_mode(xf86CrtcPtr crtc, Bool test_only)
     drmmode_ConvertToKMode(crtc->scrn, &kmode, &crtc->mode);
     ret = drmModeSetCrtc(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
                          fb_id, x, y, output_ids, output_count, &kmode);
+    if (!ret && !ms->atomic_modeset) {
+        drmmode_crtc->src_x = x;
+        drmmode_crtc->src_y = y;
+    }
 
     drmmode_set_ctm(crtc, ctm);
 
@@ -930,7 +939,8 @@ drmmode_crtc_set_mode(xf86CrtcPtr crtc, Bool test_only)
 }
 
 int
-drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data)
+drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, int x, int y,
+                  uint32_t flags, void *data)
 {
     modesettingPtr ms = modesettingPTR(crtc->scrn);
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
@@ -942,7 +952,7 @@ drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data)
         if (!req)
             return 1;
 
-        ret = plane_add_props(req, crtc, fb_id, crtc->x, crtc->y);
+        ret = plane_add_props(req, crtc, fb_id, x, y);
         flags |= DRM_MODE_ATOMIC_NONBLOCK;
         if (ret == 0)
             ret = drmModeAtomicCommit(ms->fd, req, flags, data);
@@ -950,6 +960,26 @@ drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data)
         return ret;
     }
 
+    /* The frame buffer source coordinates may change when switching between the
+     * primary frame buffer and a per-CRTC frame buffer. Set the correct source
+     * coordinates if they differ for this flip.
+     */
+    if (drmmode_crtc->src_x != x || drmmode_crtc->src_y != y) {
+        ret = drmModeSetPlane(ms->fd, drmmode_crtc->plane_id,
+                              drmmode_crtc->mode_crtc->crtc_id, fb_id, 0,
+                              0, 0, crtc->mode.HDisplay, crtc->mode.VDisplay,
+                              x << 16, y << 16, crtc->mode.HDisplay << 16,
+                              crtc->mode.VDisplay << 16);
+        if (ret) {
+            xf86DrvMsg(crtc->scrn->scrnIndex, X_WARNING,
+                       "error changing fb src coordinates for flip: %d\n", ret);
+            return ret;
+        }
+
+        drmmode_crtc->src_x = x;
+        drmmode_crtc->src_y = y;
+    }
+
     return drmModePageFlip(ms->fd, drmmode_crtc->mode_crtc->crtc_id,
                            fb_id, flags, data);
 }
@@ -1548,6 +1578,90 @@ drmmode_copy_fb(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
 #endif
 }
 
+void
+drmmode_copy_damage(xf86CrtcPtr crtc, PixmapPtr dst, RegionPtr dmg, Bool empty)
+{
+#ifdef GLAMOR_HAS_GBM
+    ScreenPtr pScreen = xf86ScrnToScreen(crtc->scrn);
+    DrawableRec *src;
+
+    /* Copy the screen's pixmap into the destination pixmap */
+    if (crtc->rotatedPixmap) {
+        src = &crtc->rotatedPixmap->drawable;
+        xf86RotateCrtcRedisplay(crtc, dst, src, dmg, FALSE);
+    } else {
+        src = &pScreen->GetScreenPixmap(pScreen)->drawable;
+        PixmapDirtyCopyArea(dst, src, 0, 0, -crtc->x, -crtc->y, dmg);
+    }
+
+    /* Reset the damages if requested */
+    if (empty)
+        RegionEmpty(dmg);
+
+    /* Wait until the GC operations finish */
+    modesettingPTR(crtc->scrn)->glamor.finish(pScreen);
+#endif
+}
+
+static void
+drmmode_shadow_fb_destroy(xf86CrtcPtr crtc, PixmapPtr pixmap,
+                          void *data, drmmode_bo *bo, uint32_t *fb_id);
+static void
+drmmode_destroy_tearfree_shadow(xf86CrtcPtr crtc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+    int i;
+
+    if (trf->flip_seq)
+        ms_drm_abort_seq(crtc->scrn, trf->flip_seq);
+
+    for (i = 0; i < ARRAY_SIZE(trf->buf); i++) {
+        if (trf->buf[i].px) {
+            drmmode_shadow_fb_destroy(crtc, trf->buf[i].px, (void *)(long)1,
+                                      &trf->buf[i].bo, &trf->buf[i].fb_id);
+            trf->buf[i].px = NULL;
+            RegionUninit(&trf->buf[i].dmg);
+        }
+    }
+}
+
+static PixmapPtr
+drmmode_shadow_fb_create(xf86CrtcPtr crtc, void *data, int width, int height,
+                         drmmode_bo *bo, uint32_t *fb_id);
+static Bool
+drmmode_create_tearfree_shadow(xf86CrtcPtr crtc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_ptr drmmode = drmmode_crtc->drmmode;
+    drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+    uint32_t w = crtc->mode.HDisplay, h = crtc->mode.VDisplay;
+    int i;
+
+    if (!drmmode->tearfree_enable)
+        return TRUE;
+
+    /* Destroy the old mode's buffers and make new ones */
+    drmmode_destroy_tearfree_shadow(crtc);
+    for (i = 0; i < ARRAY_SIZE(trf->buf); i++) {
+        trf->buf[i].px = drmmode_shadow_fb_create(crtc, NULL, w, h,
+                                                  &trf->buf[i].bo,
+                                                  &trf->buf[i].fb_id);
+        if (!trf->buf[i].px) {
+            drmmode_destroy_tearfree_shadow(crtc);
+            xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
+                       "shadow creation failed for TearFree buf%d\n", i);
+            return FALSE;
+        }
+        RegionInit(&trf->buf[i].dmg, &crtc->bounds, 0);
+    }
+
+    /* Initialize the front buffer with the current scanout */
+    drmmode_copy_damage(crtc, trf->buf[trf->back_idx ^ 1].px,
+                        &trf->buf[trf->back_idx ^ 1].dmg, TRUE);
+    return TRUE;
+}
+
 static Bool
 drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
                        Rotation rotation, int x, int y)
@@ -1581,6 +1695,10 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                                crtc->gamma_blue, crtc->gamma_size);
 
+        ret = drmmode_create_tearfree_shadow(crtc);
+        if (!ret)
+            goto done;
+
         can_test = drmmode_crtc_can_test_mode(crtc);
         if (drmmode_crtc_set_mode(crtc, can_test)) {
             xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
@@ -1626,6 +1744,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
         crtc->y = saved_y;
         crtc->rotation = saved_rotation;
         crtc->mode = saved_mode;
+        drmmode_create_tearfree_shadow(crtc);
     } else
         crtc->active = TRUE;
 
@@ -1931,33 +2050,42 @@ drmmode_clear_pixmap(PixmapPtr pixmap)
 }
 
 static void *
-drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+drmmode_shadow_fb_allocate(xf86CrtcPtr crtc, int width, int height,
+                           drmmode_bo *bo, uint32_t *fb_id)
 {
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
     int ret;
 
-    if (!drmmode_create_bo(drmmode, &drmmode_crtc->rotate_bo,
-                           width, height, drmmode->kbpp)) {
+    if (!drmmode_create_bo(drmmode, bo, width, height, drmmode->kbpp)) {
         xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
                "Couldn't allocate shadow memory for rotated CRTC\n");
         return NULL;
     }
 
-    ret = drmmode_bo_import(drmmode, &drmmode_crtc->rotate_bo,
-                            &drmmode_crtc->rotate_fb_id);
+    ret = drmmode_bo_import(drmmode, bo, fb_id);
 
     if (ret) {
         ErrorF("failed to add rotate fb\n");
-        drmmode_bo_destroy(drmmode, &drmmode_crtc->rotate_bo);
+        drmmode_bo_destroy(drmmode, bo);
         return NULL;
     }
 
 #ifdef GLAMOR_HAS_GBM
     if (drmmode->gbm)
-        return drmmode_crtc->rotate_bo.gbm;
+        return bo->gbm;
 #endif
-    return drmmode_crtc->rotate_bo.dumb;
+    return bo->dumb;
+}
+
+static void *
+drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+    return drmmode_shadow_fb_allocate(crtc, width, height,
+                                      &drmmode_crtc->rotate_bo,
+                                      &drmmode_crtc->rotate_fb_id);
 }
 
 static PixmapPtr
@@ -1983,70 +2111,91 @@ static Bool
 drmmode_set_pixmap_bo(drmmode_ptr drmmode, PixmapPtr pixmap, drmmode_bo *bo);
 
 static PixmapPtr
-drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+drmmode_shadow_fb_create(xf86CrtcPtr crtc, void *data, int width, int height,
+                         drmmode_bo *bo, uint32_t *fb_id)
 {
     ScrnInfoPtr scrn = crtc->scrn;
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
-    uint32_t rotate_pitch;
-    PixmapPtr rotate_pixmap;
+    uint32_t pitch;
+    PixmapPtr pixmap;
     void *pPixData = NULL;
 
     if (!data) {
-        data = drmmode_shadow_allocate(crtc, width, height);
+        data = drmmode_shadow_fb_allocate(crtc, width, height, bo, fb_id);
         if (!data) {
             xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "Couldn't allocate shadow pixmap for rotated CRTC\n");
+                       "Couldn't allocate shadow pixmap for CRTC\n");
             return NULL;
         }
     }
 
-    if (!drmmode_bo_has_bo(&drmmode_crtc->rotate_bo)) {
+    if (!drmmode_bo_has_bo(bo)) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                   "Couldn't allocate shadow pixmap for rotated CRTC\n");
+                   "Couldn't allocate shadow pixmap for CRTC\n");
         return NULL;
     }
 
-    pPixData = drmmode_bo_map(drmmode, &drmmode_crtc->rotate_bo);
-    rotate_pitch = drmmode_bo_get_pitch(&drmmode_crtc->rotate_bo);
+    pPixData = drmmode_bo_map(drmmode, bo);
+    pitch = drmmode_bo_get_pitch(bo);
 
-    rotate_pixmap = drmmode_create_pixmap_header(scrn->pScreen,
-                                                 width, height,
-                                                 scrn->depth,
-                                                 drmmode->kbpp,
-                                                 rotate_pitch,
-                                                 pPixData);
+    pixmap = drmmode_create_pixmap_header(scrn->pScreen,
+                                          width, height,
+                                          scrn->depth,
+                                          drmmode->kbpp,
+                                          pitch,
+                                          pPixData);
 
-    if (rotate_pixmap == NULL) {
+    if (pixmap == NULL) {
         xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                   "Couldn't allocate shadow pixmap for rotated CRTC\n");
+                   "Couldn't allocate shadow pixmap for CRTC\n");
         return NULL;
     }
 
-    drmmode_set_pixmap_bo(drmmode, rotate_pixmap, &drmmode_crtc->rotate_bo);
+    drmmode_set_pixmap_bo(drmmode, pixmap, bo);
 
-    return rotate_pixmap;
+    return pixmap;
+}
+
+static PixmapPtr
+drmmode_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+    return drmmode_shadow_fb_create(crtc, data, width, height,
+                                    &drmmode_crtc->rotate_bo,
+                                    &drmmode_crtc->rotate_fb_id);
 }
 
 static void
-drmmode_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
+drmmode_shadow_fb_destroy(xf86CrtcPtr crtc, PixmapPtr pixmap,
+                          void *data, drmmode_bo *bo, uint32_t *fb_id)
 {
     drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
     drmmode_ptr drmmode = drmmode_crtc->drmmode;
 
-    if (rotate_pixmap) {
-        rotate_pixmap->drawable.pScreen->DestroyPixmap(rotate_pixmap);
+    if (pixmap) {
+        pixmap->drawable.pScreen->DestroyPixmap(pixmap);
     }
 
     if (data) {
-        drmModeRmFB(drmmode->fd, drmmode_crtc->rotate_fb_id);
-        drmmode_crtc->rotate_fb_id = 0;
+        drmModeRmFB(drmmode->fd, *fb_id);
+        *fb_id = 0;
 
-        drmmode_bo_destroy(drmmode, &drmmode_crtc->rotate_bo);
-        memset(&drmmode_crtc->rotate_bo, 0, sizeof drmmode_crtc->rotate_bo);
+        drmmode_bo_destroy(drmmode, bo);
+        memset(bo, 0, sizeof(*bo));
     }
 }
 
+static void
+drmmode_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr pixmap, void *data)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+    drmmode_shadow_fb_destroy(crtc, pixmap, data, &drmmode_crtc->rotate_bo,
+                              &drmmode_crtc->rotate_fb_id);
+}
+
 static void
 drmmode_crtc_destroy(xf86CrtcPtr crtc)
 {
@@ -2380,6 +2529,7 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, drmModeResPtr mode_res
     drmmode_crtc->drmmode = drmmode;
     drmmode_crtc->vblank_pipe = drmmode_crtc_vblank_pipe(num);
     xorg_list_init(&drmmode_crtc->mode_list);
+    drmmode_crtc->next_msc = UINT64_MAX;
 
     props = drmModeObjectGetProperties(drmmode->fd, mode_res->crtcs[num],
                                        DRM_MODE_OBJECT_CRTC);
@@ -4242,6 +4392,7 @@ drmmode_free_bos(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
         drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 
         dumb_bo_destroy(drmmode->fd, drmmode_crtc->cursor_bo);
+        drmmode_destroy_tearfree_shadow(crtc);
     }
 }
 
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index 29f9b8f7d..145cb8cc7 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -135,6 +135,7 @@ typedef struct {
     Bool async_flip_secondaries;
     Bool dri2_enable;
     Bool present_enable;
+    Bool tearfree_enable;
 
     uint32_t vrr_prop_id;
     Bool use_ctm;
@@ -166,6 +167,19 @@ typedef struct {
     uint64_t *modifiers;
 } drmmode_format_rec, *drmmode_format_ptr;
 
+typedef struct {
+    drmmode_bo bo;
+    uint32_t fb_id;
+    PixmapPtr px;
+    RegionRec dmg;
+} drmmode_shadow_fb_rec, *drmmode_shadow_fb_ptr;
+
+typedef struct {
+    drmmode_shadow_fb_rec buf[2];
+    uint32_t back_idx;
+    uint32_t flip_seq;
+} drmmode_tearfree_rec, *drmmode_tearfree_ptr;
+
 typedef struct {
     drmmode_ptr drmmode;
     drmModeCrtcPtr mode_crtc;
@@ -184,11 +198,14 @@ typedef struct {
 
     drmmode_bo rotate_bo;
     unsigned rotate_fb_id;
+    drmmode_tearfree_rec tearfree;
 
     PixmapPtr prime_pixmap;
     PixmapPtr prime_pixmap_back;
     unsigned prime_pixmap_x;
 
+    int src_x, src_y;
+
     /**
      * @{ MSC (vblank count) handling for the PRESENT extension.
      *
@@ -200,6 +217,8 @@ typedef struct {
     uint64_t msc_high;
     /** @} */
 
+    uint64_t next_msc;
+
     Bool need_modeset;
     struct xorg_list mode_list;
 
@@ -308,8 +327,13 @@ void drmmode_get_default_bpp(ScrnInfoPtr pScrn, drmmode_ptr drmmmode,
                              int *depth, int *bpp);
 
 void drmmode_copy_fb(ScrnInfoPtr pScrn, drmmode_ptr drmmode);
+void drmmode_copy_damage(xf86CrtcPtr crtc, PixmapPtr dst, RegionPtr damage,
+                         Bool empty);
+
+int drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, int x, int y,
+                      uint32_t flags, void *data);
 
-int drmmode_crtc_flip(xf86CrtcPtr crtc, uint32_t fb_id, uint32_t flags, void *data);
+Bool drmmode_crtc_get_fb_id(xf86CrtcPtr crtc, uint32_t *fb_id, int *x, int *y);
 
 void drmmode_set_dpms(ScrnInfoPtr scrn, int PowerManagementMode, int flags);
 void drmmode_crtc_set_vrr(xf86CrtcPtr crtc, Bool enabled);
diff --git a/hw/xfree86/drivers/modesetting/modesetting.man b/hw/xfree86/drivers/modesetting/modesetting.man
index 71790011e..485beff48 100644
--- a/hw/xfree86/drivers/modesetting/modesetting.man
+++ b/hw/xfree86/drivers/modesetting/modesetting.man
@@ -109,6 +109,21 @@ When enabled, this option allows the driver to use gamma ramps with more
 entries, if supported by the kernel. By default, GAMMA_LUT will be used for
 kms drivers which are known to be safe for use of GAMMA_LUT.
 .TP
+.BI "Option \*qTearFree\*q \*q" boolean \*q
+Enable tearing prevention using the hardware page flipping mechanism.
+It allocates two extra scanout buffers for each CRTC and utilizes damage
+tracking to minimize buffer copying and skip unnecessary flips when the
+screen's contents have not changed. It works on transformed screens too, such
+as rotated and scaled CRTCs. When PageFlip is enabled, fullscreen DRI
+applications will still have the discretion to not use tearing prevention.
+.br
+The default is
+.B off.
+.TP
+.BI "Option \*qAtomic\*q \*q" boolean \*q
+Enable atomic modesetting when supported.  The default is
+.B off.
+.TP
 .SH "SEE ALSO"
 @xservername@(@appmansuffix@), @xconfigfile@(@filemansuffix@), Xserver(@appmansuffix@),
 X(@miscmansuffix@)
diff --git a/hw/xfree86/drivers/modesetting/pageflip.c b/hw/xfree86/drivers/modesetting/pageflip.c
index 23ee95f9a..8d57047ef 100644
--- a/hw/xfree86/drivers/modesetting/pageflip.c
+++ b/hw/xfree86/drivers/modesetting/pageflip.c
@@ -35,8 +35,8 @@
  * Returns a negative value on error, 0 if there was nothing to process,
  * or 1 if we handled any events.
  */
-int
-ms_flush_drm_events(ScreenPtr screen)
+static int
+ms_flush_drm_events_timeout(ScreenPtr screen, int timeout)
 {
     ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
     modesettingPtr ms = modesettingPTR(scrn);
@@ -45,7 +45,7 @@ ms_flush_drm_events(ScreenPtr screen)
     int r;
 
     do {
-            r = xserver_poll(&p, 1, 0);
+            r = xserver_poll(&p, 1, timeout);
     } while (r == -1 && (errno == EINTR || errno == EAGAIN));
 
     /* If there was an error, r will be < 0.  Return that.  If there was
@@ -63,6 +63,12 @@ ms_flush_drm_events(ScreenPtr screen)
     return 1;
 }
 
+int
+ms_flush_drm_events(ScreenPtr screen)
+{
+    return ms_flush_drm_events_timeout(screen, 0);
+}
+
 #ifdef GLAMOR_HAS_GBM
 
 /*
@@ -160,11 +166,32 @@ ms_pageflip_abort(void *data)
 }
 
 static Bool
-do_queue_flip_on_crtc(modesettingPtr ms, xf86CrtcPtr crtc,
-                      uint32_t flags, uint32_t seq)
+do_queue_flip_on_crtc(ScreenPtr screen, xf86CrtcPtr crtc, uint32_t flags,
+                      uint32_t seq, uint32_t fb_id, int x, int y)
 {
-    return drmmode_crtc_flip(crtc, ms->drmmode.fb_id, flags,
-                             (void *) (uintptr_t) seq);
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+
+    while (drmmode_crtc_flip(crtc, fb_id, x, y, flags, (void *)(long)seq)) {
+        /* We may have failed because the event queue was full.  Flush it
+         * and retry.  If there was nothing to flush, then we failed for
+         * some other reason and should just return an error.
+         */
+        if (ms_flush_drm_events(screen) <= 0) {
+            /* The failure could be caused by a pending TearFree flip, in which
+             * case we should wait until there's a new event and try again.
+             */
+            if (!trf->flip_seq || ms_flush_drm_events_timeout(screen, -1) < 0) {
+                ms_drm_abort_seq(crtc->scrn, seq);
+                return TRUE;
+            }
+        }
+
+        /* We flushed some events, so try again. */
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_WARNING, "flip queue retry\n");
+    }
+
+    return FALSE;
 }
 
 enum queue_flip_status {
@@ -205,20 +232,9 @@ queue_flip_on_crtc(ScreenPtr screen, xf86CrtcPtr crtc,
     /* take a reference on flipdata for use in flip */
     flipdata->flip_count++;
 
-    while (do_queue_flip_on_crtc(ms, crtc, flags, seq)) {
-        /* We may have failed because the event queue was full.  Flush it
-         * and retry.  If there was nothing to flush, then we failed for
-         * some other reason and should just return an error.
-         */
-        if (ms_flush_drm_events(screen) <= 0) {
-            /* Aborting will also decrement flip_count and free(flip). */
-            ms_drm_abort_seq(scrn, seq);
-            return QUEUE_FLIP_DRM_FLUSH_FAILED;
-        }
-
-        /* We flushed some events, so try again. */
-        xf86DrvMsg(scrn->scrnIndex, X_WARNING, "flip queue retry\n");
-    }
+    if (do_queue_flip_on_crtc(screen, crtc, flags, seq, ms->drmmode.fb_id,
+                              crtc->x, crtc->y))
+        return QUEUE_FLIP_DRM_FLUSH_FAILED;
 
     /* The page flip succeeded. */
     return QUEUE_FLIP_SUCCESS;
@@ -465,4 +481,50 @@ error_out:
 #endif /* GLAMOR_HAS_GBM */
 }
 
+static void
+ms_tearfree_flip_abort(void *data)
+{
+    drmmode_tearfree_ptr trf = data;
+
+    trf->flip_seq = 0;
+}
+
+static void
+ms_tearfree_flip_handler(uint64_t msc, uint64_t usec, void *data)
+{
+    drmmode_tearfree_ptr trf = data;
+
+    /* Swap the buffers and complete the flip */
+    trf->back_idx ^= 1;
+    trf->flip_seq = 0;
+}
+
+Bool
+ms_do_tearfree_flip(ScreenPtr screen, xf86CrtcPtr crtc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+    drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+    uint32_t idx = trf->back_idx, seq;
+
+    seq = ms_drm_queue_alloc(crtc, trf, ms_tearfree_flip_handler,
+                             ms_tearfree_flip_abort);
+    if (!seq)
+        goto no_flip;
+
+    /* Copy the damage to the back buffer and then flip it at the vblank */
+    drmmode_copy_damage(crtc, trf->buf[idx].px, &trf->buf[idx].dmg, TRUE);
+    if (do_queue_flip_on_crtc(screen, crtc, DRM_MODE_PAGE_FLIP_EVENT,
+                              seq, trf->buf[idx].fb_id, 0, 0))
+        goto no_flip;
+
+    trf->flip_seq = seq;
+    return FALSE;
+
+no_flip:
+    xf86DrvMsg(crtc->scrn->scrnIndex, X_WARNING,
+               "TearFree flip failed, rendering frame without TearFree\n");
+    drmmode_copy_damage(crtc, trf->buf[idx ^ 1].px,
+                        &trf->buf[idx ^ 1].dmg, FALSE);
+    return TRUE;
+}
 #endif
diff --git a/hw/xfree86/drivers/modesetting/present.c b/hw/xfree86/drivers/modesetting/present.c
index c3266d871..642f7baaf 100644
--- a/hw/xfree86/drivers/modesetting/present.c
+++ b/hw/xfree86/drivers/modesetting/present.c
@@ -318,14 +318,32 @@ ms_present_check_flip(RRCrtcPtr crtc,
     modesettingPtr ms = modesettingPTR(scrn);
 
     if (ms->drmmode.sprites_visible > 0)
-        return FALSE;
+        goto no_flip;
 
     if(!ms_present_check_unflip(crtc, window, pixmap, sync_flip, reason))
-        return FALSE;
+        goto no_flip;
 
     ms->flip_window = window;
 
     return TRUE;
+
+no_flip:
+    /* Export some info about TearFree if Present can't flip anyway */
+    if (reason && ms->drmmode.tearfree_enable) {
+        xf86CrtcPtr xf86_crtc = crtc->devPrivate;
+        drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
+        drmmode_tearfree_ptr trf = &drmmode_crtc->tearfree;
+
+        if (trf->buf[0].px) {
+            if (trf->flip_seq)
+                /* The driver has a TearFree flip pending */
+                *reason = PRESENT_FLIP_REASON_DRIVER_TEARFREE_FLIPPING;
+            else
+                /* The driver uses TearFree flips and there's no flip pending */
+                *reason = PRESENT_FLIP_REASON_DRIVER_TEARFREE;
+        }
+    }
+    return FALSE;
 }
 
 /*
diff --git a/hw/xfree86/drivers/modesetting/vblank.c b/hw/xfree86/drivers/modesetting/vblank.c
index ea9e7a88c..4d250aa34 100644
--- a/hw/xfree86/drivers/modesetting/vblank.c
+++ b/hw/xfree86/drivers/modesetting/vblank.c
@@ -260,6 +260,51 @@ ms_get_kernel_ust_msc(xf86CrtcPtr crtc,
     }
 }
 
+static void
+ms_drm_set_seq_msc(uint32_t seq, uint64_t msc)
+{
+    struct ms_drm_queue *q;
+
+    xorg_list_for_each_entry(q, &ms_drm_queue, list) {
+        if (q->seq == seq) {
+            q->msc = msc;
+            break;
+        }
+    }
+}
+
+static void
+ms_drm_set_seq_queued(uint32_t seq, uint64_t msc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc;
+    struct ms_drm_queue *q;
+
+    xorg_list_for_each_entry(q, &ms_drm_queue, list) {
+        if (q->seq == seq) {
+            drmmode_crtc = q->crtc->driver_private;
+            if (msc < drmmode_crtc->next_msc)
+                drmmode_crtc->next_msc = msc;
+            q->msc = msc;
+            q->kernel_queued = TRUE;
+            break;
+        }
+    }
+}
+
+static Bool
+ms_queue_coalesce(xf86CrtcPtr crtc, uint32_t seq, uint64_t msc)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+
+    /* If the next MSC is too late, then this event can't be coalesced */
+    if (msc < drmmode_crtc->next_msc)
+        return FALSE;
+
+    /* Set the target MSC on this sequence number */
+    ms_drm_set_seq_msc(seq, msc);
+    return TRUE;
+}
+
 Bool
 ms_queue_vblank(xf86CrtcPtr crtc, ms_queue_flag flags,
                 uint64_t msc, uint64_t *msc_queued, uint32_t seq)
@@ -271,6 +316,10 @@ ms_queue_vblank(xf86CrtcPtr crtc, ms_queue_flag flags,
     drmVBlank vbl;
     int ret;
 
+    /* Try coalescing this event into another to avoid event queue exhaustion */
+    if (flags == MS_QUEUE_ABSOLUTE && ms_queue_coalesce(crtc, seq, msc))
+        return TRUE;
+
     for (;;) {
         /* Queue an event at the specified sequence */
         if (ms->has_queue_sequence || !ms->tried_queue_sequence) {
@@ -287,8 +336,10 @@ ms_queue_vblank(xf86CrtcPtr crtc, ms_queue_flag flags,
             ret = drmCrtcQueueSequence(ms->fd, drmmode_crtc->mode_crtc->crtc_id,
                                        drm_flags, msc, &kernel_queued, seq);
             if (ret == 0) {
+                msc = ms_kernel_msc_to_crtc_msc(crtc, kernel_queued, TRUE);
+                ms_drm_set_seq_queued(seq, msc);
                 if (msc_queued)
-                    *msc_queued = ms_kernel_msc_to_crtc_msc(crtc, kernel_queued, TRUE);
+                    *msc_queued = msc;
                 ms->has_queue_sequence = TRUE;
                 return TRUE;
             }
@@ -310,8 +361,10 @@ ms_queue_vblank(xf86CrtcPtr crtc, ms_queue_flag flags,
         vbl.request.signal = seq;
         ret = drmWaitVBlank(ms->fd, &vbl);
         if (ret == 0) {
+            msc = ms_kernel_msc_to_crtc_msc(crtc, vbl.reply.sequence, FALSE);
+            ms_drm_set_seq_queued(seq, msc);
             if (msc_queued)
-                *msc_queued = ms_kernel_msc_to_crtc_msc(crtc, vbl.reply.sequence, FALSE);
+                *msc_queued = msc;
             return TRUE;
         }
     check:
@@ -418,13 +471,15 @@ ms_drm_queue_alloc(xf86CrtcPtr crtc,
     if (!ms_drm_seq)
         ++ms_drm_seq;
     q->seq = ms_drm_seq++;
+    q->msc = UINT64_MAX;
     q->scrn = scrn;
     q->crtc = crtc;
     q->data = data;
     q->handler = handler;
     q->abort = abort;
 
-    xorg_list_add(&q->list, &ms_drm_queue);
+    /* Keep the list formatted in ascending order of sequence number */
+    xorg_list_append(&q->list, &ms_drm_queue);
 
     return q->seq;
 }
@@ -437,9 +492,18 @@ ms_drm_queue_alloc(xf86CrtcPtr crtc,
 static void
 ms_drm_abort_one(struct ms_drm_queue *q)
 {
+    if (q->aborted)
+        return;
+
+    /* Don't remove vblank events if they were queued in the kernel */
+    if (q->kernel_queued) {
+        q->abort(q->data);
+        q->aborted = TRUE;
+    } else {
         xorg_list_del(&q->list);
         q->abort(q->data);
         free(q);
+    }
 }
 
 /**
@@ -500,18 +564,61 @@ ms_drm_sequence_handler(int fd, uint64_t frame, uint64_t ns, Bool is64bit, uint6
 {
     struct ms_drm_queue *q, *tmp;
     uint32_t seq = (uint32_t) user_data;
+    xf86CrtcPtr crtc = NULL;
+    drmmode_crtc_private_ptr drmmode_crtc;
+    uint64_t msc, next_msc = UINT64_MAX;
 
-    xorg_list_for_each_entry_safe(q, tmp, &ms_drm_queue, list) {
+    /* Handle the seq for this event first in order to get the CRTC */
+    xorg_list_for_each_entry(q, &ms_drm_queue, list) {
         if (q->seq == seq) {
-            uint64_t msc;
-
-            msc = ms_kernel_msc_to_crtc_msc(q->crtc, frame, is64bit);
+            crtc = q->crtc;
+            msc = ms_kernel_msc_to_crtc_msc(crtc, frame, is64bit);
             xorg_list_del(&q->list);
-            q->handler(msc, ns / 1000, q->data);
+            if (!q->aborted)
+                q->handler(msc, ns / 1000, q->data);
             free(q);
             break;
         }
     }
+
+    if (!crtc)
+        return;
+
+    /* Now run all of the vblank events for this CRTC with an expired MSC */
+    xorg_list_for_each_entry_safe(q, tmp, &ms_drm_queue, list) {
+        if (q->crtc == crtc && q->msc <= msc) {
+            xorg_list_del(&q->list);
+            if (!q->aborted)
+                q->handler(msc, ns / 1000, q->data);
+            free(q);
+        }
+    }
+
+    /* Find this CRTC's next queued MSC and next non-queued MSC to be handled */
+    msc = UINT64_MAX;
+    xorg_list_for_each_entry(q, &ms_drm_queue, list) {
+        if (q->crtc == crtc) {
+            if (q->kernel_queued) {
+                if (q->msc < next_msc)
+                    next_msc = q->msc;
+            } else if (q->msc < msc) {
+                msc = q->msc;
+                seq = q->seq;
+            }
+        }
+    }
+
+    /* Queue an event if the next queued MSC isn't soon enough */
+    drmmode_crtc = crtc->driver_private;
+    drmmode_crtc->next_msc = next_msc;
+    if (msc < next_msc && !ms_queue_vblank(crtc, MS_QUEUE_ABSOLUTE, msc, NULL, seq)) {
+        xf86DrvMsg(crtc->scrn->scrnIndex, X_WARNING,
+                   "failed to queue next vblank event, aborting lost events\n");
+        xorg_list_for_each_entry_safe(q, tmp, &ms_drm_queue, list) {
+            if (q->crtc == crtc && q->msc < next_msc)
+                ms_drm_abort_one(q);
+        }
+    }
 }
 
 static void
diff --git a/hw/xfree86/exa/Makefile.am b/hw/xfree86/exa/Makefile.am
deleted file mode 100644
index ccbb305d3..000000000
--- a/hw/xfree86/exa/Makefile.am
+++ /dev/null
@@ -1,17 +0,0 @@
-SUBDIRS = man
-
-module_LTLIBRARIES = libexa.la
-
-libexa_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-
-AM_CPPFLAGS = \
-	$(XORG_INCS) \
-	-I$(srcdir)/../../../exa
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-libexa_la_SOURCES = \
-	examodule.c
-
-libexa_la_LIBADD = \
-	../../../exa/libexa.la $(PIXMAN_LIBS)
diff --git a/hw/xfree86/exa/man/Makefile.am b/hw/xfree86/exa/man/Makefile.am
deleted file mode 100644
index 51da4fd50..000000000
--- a/hw/xfree86/exa/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-driverman_PRE = exa.man
diff --git a/hw/xfree86/fbdevhw/Makefile.am b/hw/xfree86/fbdevhw/Makefile.am
deleted file mode 100644
index 37cd88c0e..000000000
--- a/hw/xfree86/fbdevhw/Makefile.am
+++ /dev/null
@@ -1,19 +0,0 @@
-SUBDIRS = man
-
-module_LTLIBRARIES = libfbdevhw.la
-
-libfbdevhw_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-
-if FBDEVHW
-libfbdevhw_la_SOURCES = fbdevhw.c
-else
-libfbdevhw_la_SOURCES = fbdevhwstub.c
-endif
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../i2c -I$(srcdir)/../modes -I$(srcdir)/../ddc -I$(srcdir)/../parser
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-sdk_HEADERS = fbdevhw.h
-
-EXTRA_DIST = fbpriv.h README
diff --git a/hw/xfree86/fbdevhw/man/Makefile.am b/hw/xfree86/fbdevhw/man/Makefile.am
deleted file mode 100644
index 7f22a12b9..000000000
--- a/hw/xfree86/fbdevhw/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-driverman_PRE = fbdevhw.man
diff --git a/hw/xfree86/glamor_egl/Makefile.am b/hw/xfree86/glamor_egl/Makefile.am
deleted file mode 100644
index e697c8296..000000000
--- a/hw/xfree86/glamor_egl/Makefile.am
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright © 2013 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-module_LTLIBRARIES = libglamoregl.la
-
-libglamoregl_la_SOURCES = \
-	$(top_srcdir)/glamor/glamor_egl.c \
-	$(top_srcdir)/glamor/glamor_eglmodule.c \
-	glamor_xf86_xv.c \
-	$()
-
-libglamoregl_la_LDFLAGS = \
-	-avoid-version \
-	$(GBM_LIBS) \
-	$()
-
-libglamoregl_la_LIBADD = \
-	$(top_builddir)/glamor/libglamor.la \
-	$()
-
-AM_CPPFLAGS = $(XORG_INCS) \
-	-I$(top_srcdir)/dri3 \
-	-I$(top_srcdir)/glamor \
-	$()
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS) $(GLAMOR_CFLAGS) $(GBM_CFLAGS)
diff --git a/hw/xfree86/i2c/Makefile.am b/hw/xfree86/i2c/Makefile.am
deleted file mode 100644
index 8bf795ded..000000000
--- a/hw/xfree86/i2c/Makefile.am
+++ /dev/null
@@ -1,9 +0,0 @@
-noinst_LTLIBRARIES = libi2c.la
-
-libi2c_la_SOURCES = xf86i2c.c
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-sdk_HEADERS = xf86i2c.h i2c_def.h
diff --git a/hw/xfree86/int10/Makefile.am b/hw/xfree86/int10/Makefile.am
deleted file mode 100644
index 0248dc781..000000000
--- a/hw/xfree86/int10/Makefile.am
+++ /dev/null
@@ -1,49 +0,0 @@
-module_LTLIBRARIES = libint10.la
-
-sdk_HEADERS = xf86int10.h vbe.h vbeModes.h
-
-EXTRA_CFLAGS =
-
-libint10_la_LDFLAGS = -avoid-version
-libint10_la_LIBADD = $(PCIACCESS_LIBS)
-
-COMMON_SOURCES = \
-	vbe.c \
-	vbeModes.c \
-	helper_exec.c \
-	helper_mem.c \
-	xf86int10.c \
-	xf86int10module.c
-
-if I386_VIDEO
-I386_VIDEO_CFLAGS = -D_PC
-endif
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../ddc -I$(srcdir)/../modes -I$(srcdir)/../i2c \
-	      -I$(srcdir)/../parser
-
-if INT10_VM86
-AM_CFLAGS = $(I386_VIDEO_CFLAGS) -D_VM86_LINUX $(DIX_CFLAGS) $(XORG_CFLAGS) $(EXTRA_CFLAGS)
-libint10_la_SOURCES = \
-	$(COMMON_SOURCES) \
-	$(srcdir)/../os-support/linux/int10/vm86/linux_vm86.c \
-	$(srcdir)/../os-support/linux/int10/linux.c
-endif
-
-if INT10_X86EMU
-AM_CFLAGS = $(I386_VIDEO_CFLAGS) -D_X86EMU -DNO_SYS_HEADERS \
-           $(XORG_CFLAGS) $(EXTRA_CFLAGS) $(DIX_CFLAGS)
-AM_CPPFLAGS += -I$(srcdir)/../x86emu
-libint10_la_SOURCES = \
-	$(COMMON_SOURCES) \
-	xf86x86emu.c \
-	generic.c \
-	x86emu.c
-endif
-
-if INT10_STUB
-AM_CFLAGS = $(I386_VIDEO_CFLAGS) -D_VM86_LINUX $(DIX_CFLAGS) $(XORG_CFLAGS) $(EXTRA_CFLAGS)
-libint10_la_SOURCES = stub.c xf86int10module.c
-endif
-
-EXTRA_DIST = xf86x86emu.h INT10.HOWTO
diff --git a/hw/xfree86/loader/Makefile.am b/hw/xfree86/loader/Makefile.am
deleted file mode 100644
index 3529a7acd..000000000
--- a/hw/xfree86/loader/Makefile.am
+++ /dev/null
@@ -1,19 +0,0 @@
-noinst_LTLIBRARIES = libloader.la
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../parser \
-	   -I$(srcdir)/../ddc -I$(srcdir)/../i2c -I$(srcdir)/../modes \
-	   -I$(srcdir)/../ramdac -I$(srcdir)/../dri -I$(srcdir)/../dri2
-
-#AM_LDFLAGS = -r
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-EXTRA_DIST = \
-	loader.h \
-	loaderProcs.h
-
-libloader_la_SOURCES = \
-	loader.c \
-	loaderProcs.h \
-        loadmod.c
-
-libloader_la_LIBADD = $(DLOPEN_LIBS)
diff --git a/hw/xfree86/man/Makefile.am b/hw/xfree86/man/Makefile.am
deleted file mode 100644
index 5da404cbb..000000000
--- a/hw/xfree86/man/Makefile.am
+++ /dev/null
@@ -1,10 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = Xorg.man
-fileman_PRE = xorg.conf.man xorg.conf.d.man
-
-if SUID_WRAPPER
-appman_PRE += Xorg.wrap.man
-fileman_PRE += Xwrapper.config.man
-else
-EXTRA_DIST += Xorg.wrap.man Xwrapper.config.man
-endif
diff --git a/hw/xfree86/man/xorg.conf.man b/hw/xfree86/man/xorg.conf.man
index ac88d7e7a..d057f26ec 100644
--- a/hw/xfree86/man/xorg.conf.man
+++ b/hw/xfree86/man/xorg.conf.man
@@ -677,6 +677,8 @@ Possible values are
 or
 .BR sync .
 Unset by default.
+.BI "Option \*qAllowByteSwappedClients\*q  \*q" boolean \*q
+Allow clients with a different byte-order than the server. Disabled by default.
 .SH "MODULE SECTION"
 The
 .B Module
@@ -1296,7 +1298,20 @@ This option specifies that the matched device should be treated as the
 primary GPU, replacing the selection of the GPU used as output by the
 firmware. If multiple output devices match an OutputClass section with
 the PrimaryGPU option set, the first one enumerated becomes the primary GPU.
-.PP
+.TP 7
+.BI "Option \*qHotplugDriver\*q \*q" driver \*q
+This option specifies that the matched driver should be used to handle a
+hot-plugged GPU device.
+The module specified by
+.I driver
+will be loaded during setup of the GPU device.
+If loading of this module fails or there is no driver by that name, the
+modesetting driver will be used, which is the default behavior.
+If multiple output devices match an
+.B OutputClass
+section with the
+.B HotplugDriver
+option, the first one enumerated becomes the hotplug driver.
 A
 .B OutputClass
 Section may contain
diff --git a/hw/xfree86/modes/Makefile.am b/hw/xfree86/modes/Makefile.am
deleted file mode 100644
index 35a174b5b..000000000
--- a/hw/xfree86/modes/Makefile.am
+++ /dev/null
@@ -1,31 +0,0 @@
-noinst_LTLIBRARIES = libxf86modes.la
-
-if DGA
-DGA_SRCS = xf86DiDGA.c
-endif
-
-libxf86modes_la_SOURCES = \
-	xf86Crtc.c \
-	xf86Crtc.h \
-	xf86Cursors.c \
-	xf86gtf.c \
-	xf86EdidModes.c \
-	xf86Modes.c \
-	xf86Modes.h \
-	xf86RandR12.c \
-	xf86RandR12.h \
-	xf86Rotate.c \
-        $(DGA_SRCS)
-
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../ddc -I$(srcdir)/../i2c \
-	   -I$(srcdir)/../loader -I$(srcdir)/../rac -I$(srcdir)/../parser \
-	   -I$(srcdir)/../vbe -I$(srcdir)/../int10 \
-	   -I$(srcdir)/../vgahw -I$(srcdir)/../ramdac \
-	   -I$(srcdir)/../dixmods/extmod
-
-sdk_HEADERS = \
-	xf86Crtc.h \
-	xf86Modes.h \
-	xf86RandR12.h
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
diff --git a/hw/xfree86/modes/xf86Crtc.h b/hw/xfree86/modes/xf86Crtc.h
index 7a562874c..e9db8e3e5 100644
--- a/hw/xfree86/modes/xf86Crtc.h
+++ b/hw/xfree86/modes/xf86Crtc.h
@@ -837,11 +837,11 @@ extern _X_EXPORT int xf86CrtcConfigPrivateIndex;
 static _X_INLINE xf86OutputPtr
 xf86CompatOutput(ScrnInfoPtr pScrn)
 {
-    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
+    xf86CrtcConfigPtr config;
 
     if (xf86CrtcConfigPrivateIndex == -1)
         return NULL;
-
+    config = XF86_CRTC_CONFIG_PTR(pScrn);
     if (config->compat_output < 0)
         return NULL;
     return config->output[config->compat_output];
@@ -912,6 +912,11 @@ extern _X_EXPORT void
 extern _X_EXPORT Bool
  xf86CrtcRotate(xf86CrtcPtr crtc);
 
+extern _X_EXPORT void
+ xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, PixmapPtr dst_pixmap,
+                         DrawableRec *src_drawable, RegionPtr region,
+                         Bool transform_src);
+
 /*
  * Clean up any rotation data, used when a crtc is turned off
  * as well as when rotation is disabled.
diff --git a/hw/xfree86/modes/xf86Modes.c b/hw/xfree86/modes/xf86Modes.c
index 384996724..00586c457 100644
--- a/hw/xfree86/modes/xf86Modes.c
+++ b/hw/xfree86/modes/xf86Modes.c
@@ -803,10 +803,14 @@ xf86CVTMode(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
 {
     struct libxcvt_mode_info *libxcvt_mode_info;
     DisplayModeRec *Mode = xnfcalloc(1, sizeof(DisplayModeRec));
+    char *tmp;
 
     libxcvt_mode_info =
         libxcvt_gen_mode_info(HDisplay, VDisplay, VRefresh, Reduced, Interlaced);
 
+    XNFasprintf(&tmp, "%dx%d", HDisplay, VDisplay);
+    Mode->name = tmp;
+    
     Mode->VDisplay   = libxcvt_mode_info->vdisplay;
     Mode->HDisplay   = libxcvt_mode_info->hdisplay;
     Mode->Clock      = libxcvt_mode_info->dot_clock;
diff --git a/hw/xfree86/modes/xf86Rotate.c b/hw/xfree86/modes/xf86Rotate.c
index ea9c43c0f..944a01b1c 100644
--- a/hw/xfree86/modes/xf86Rotate.c
+++ b/hw/xfree86/modes/xf86Rotate.c
@@ -39,13 +39,13 @@
 #include "X11/extensions/dpmsconst.h"
 #include "X11/Xatom.h"
 
-static void
-xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, RegionPtr region)
+void
+xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, PixmapPtr dst_pixmap,
+                        DrawableRec *src_drawable, RegionPtr region,
+                        Bool transform_src)
 {
     ScrnInfoPtr scrn = crtc->scrn;
     ScreenPtr screen = scrn->pScreen;
-    WindowPtr root = screen->root;
-    PixmapPtr dst_pixmap = crtc->rotatedPixmap;
     PictFormatPtr format = PictureWindowFormat(screen->root);
     int error;
     PicturePtr src, dst;
@@ -57,7 +57,7 @@ xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, RegionPtr region)
         return;
 
     src = CreatePicture(None,
-                        &root->drawable,
+                        src_drawable,
                         format,
                         CPSubwindowMode,
                         &include_inferiors, serverClient, &error);
@@ -70,9 +70,11 @@ xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, RegionPtr region)
     if (!dst)
         return;
 
-    error = SetPictureTransform(src, &crtc->crtc_to_framebuffer);
-    if (error)
-        return;
+    if (transform_src) {
+        error = SetPictureTransform(src, &crtc->crtc_to_framebuffer);
+        if (error)
+            return;
+    }
     if (crtc->transform_in_use && crtc->filter)
         SetPicturePictFilter(src, crtc->filter, crtc->params, crtc->nparams);
 
@@ -205,7 +207,9 @@ xf86RotateRedisplay(ScreenPtr pScreen)
 
                 /* update damaged region */
                 if (RegionNotEmpty(&crtc_damage))
-                    xf86RotateCrtcRedisplay(crtc, &crtc_damage);
+                    xf86RotateCrtcRedisplay(crtc, crtc->rotatedPixmap,
+                                            &pScreen->root->drawable,
+                                            &crtc_damage, TRUE);
 
                 RegionUninit(&crtc_damage);
             }
diff --git a/hw/xfree86/os-support/Makefile.am b/hw/xfree86/os-support/Makefile.am
deleted file mode 100644
index a0140a16d..000000000
--- a/hw/xfree86/os-support/Makefile.am
+++ /dev/null
@@ -1,18 +0,0 @@
-SUBDIRS = bus @XORG_OS_SUBDIR@ misc $(DRI_SUBDIRS)
-DIST_SUBDIRS = bsd bus misc linux solaris stub hurd
-
-sdk_HEADERS = xf86_OSproc.h xf86_OSlib.h
-
-EXTRA_DIST = int10Defines.h xf86OSpriv.h
-
-# to get the grouping semantics right, you have to glom these three together
-# as one library, otherwise libtool will actively defeat your attempts to
-# list them multiple times on the link line.
-noinst_LTLIBRARIES = libxorgos.la
-libxorgos_la_SOURCES =
-libxorgos_la_LIBADD = @XORG_OS_SUBDIR@/lib@XORG_OS_SUBDIR@.la \
-                      bus/libbus.la \
-                      misc/libmisc.la
-
-AM_CFLAGS = $(DIX_CFLAGS) 
-
diff --git a/hw/xfree86/os-support/bsd/Makefile.am b/hw/xfree86/os-support/bsd/Makefile.am
deleted file mode 100644
index 2311dc242..000000000
--- a/hw/xfree86/os-support/bsd/Makefile.am
+++ /dev/null
@@ -1,65 +0,0 @@
-noinst_LTLIBRARIES = libbsd.la
-
-# No APM support.
-APM_SOURCES = $(srcdir)/../shared/pm_noop.c
-
-if FREEBSD_KLDLOAD
-KMOD_SOURCES = bsd_kmod.c
-else
-KMOD_SOURCES = $(srcdir)/../shared/kmod_noop.c
-endif
-
-if AGP
-AGP_SOURCES = $(srcdir)/../linux/lnx_agp.c
-else
-AGP_SOURCES = $(srcdir)/../shared/agp_noop.c
-endif
-
-if ALPHA_VIDEO
-# Cheat here and piggyback other alpha bits on ALPHA_VIDEO.
-ARCH_SOURCES = \
-	alpha_video.c
-endif
-
-if ARM_VIDEO
-ARCH_SOURCES = arm_video.c
-endif
-
-if I386_VIDEO
-ARCH_SOURCES = i386_video.c
-endif
-
-if PPC_VIDEO
-ARCH_SOURCES = ppc_video.c
-endif
-
-if SPARC64_VIDEO
-# Cheat here and piggyback other sparc64 bits on SPARC64_VIDEO.
-ARCH_SOURCES = \
-	sparc64_video.c \
-	$(srcdir)/../shared/ioperm_noop.c
-endif
-
-# FIXME: NetBSD Aperture defines (configure.ac)
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-libbsd_la_SOURCES = \
-	$(srcdir)/../shared/posix_tty.c \
-	$(srcdir)/../shared/sigio.c \
-	$(srcdir)/../shared/vidmem.c \
-	bsd_VTsw.c \
-	bsd_init.c \
-	bsd_bell.c \
-	$(ARCH_SOURCES) \
-	$(AGP_SOURCES) \
-	$(APM_SOURCES) \
-	$(AXP_SOURCES) \
-	$(DRI_SOURCES) \
-	$(KMOD_SOURCES) \
-	$(RES_SOURCES)
-
-# FIXME: Add these files to the build as needed
-EXTRA_DIST = \
-	memrange.h
diff --git a/hw/xfree86/os-support/bus/Makefile.am b/hw/xfree86/os-support/bus/Makefile.am
deleted file mode 100644
index eebb3aed6..000000000
--- a/hw/xfree86/os-support/bus/Makefile.am
+++ /dev/null
@@ -1,24 +0,0 @@
-noinst_LTLIBRARIES = libbus.la
-sdk_HEADERS = xf86Pci.h
-
-PCI_SOURCES =
-if XORG_BUS_PCI
-PCI_SOURCES += Pci.c Pci.h
-endif
-
-if XORG_BUS_BSDPCI
-PCI_SOURCES += bsd_pci.c
-endif
-
-if XORG_BUS_SPARC
-PLATFORM_SOURCES = Sbus.c
-sdk_HEADERS += xf86Sbus.h
-endif
-
-libbus_la_SOURCES = $(PCI_SOURCES) $(PLATFORM_SOURCES) nobus.c
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-EXTRA_DIST = $(sdk_HEADERS)
diff --git a/hw/xfree86/os-support/hurd/Makefile.am b/hw/xfree86/os-support/hurd/Makefile.am
deleted file mode 100644
index 33857f459..000000000
--- a/hw/xfree86/os-support/hurd/Makefile.am
+++ /dev/null
@@ -1,15 +0,0 @@
-noinst_LTLIBRARIES = libhurd.la
-
-libhurd_la_SOURCES = hurd_bell.c hurd_init.c \
-		hurd_video.c \
-		$(srcdir)/../shared/VTsw_noop.c \
-		$(srcdir)/../shared/posix_tty.c \
-		$(srcdir)/../shared/vidmem.c \
-		$(srcdir)/../shared/sigiostubs.c \
-		$(srcdir)/../shared/pm_noop.c \
-		$(srcdir)/../shared/kmod_noop.c \
-		$(srcdir)/../shared/agp_noop.c
-
-AM_CFLAGS = -DHAVE_SYSV_IPC $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-AM_CPPFLAGS = $(XORG_INCS)
diff --git a/hw/xfree86/os-support/linux/Makefile.am b/hw/xfree86/os-support/linux/Makefile.am
deleted file mode 100644
index 4392fe8d4..000000000
--- a/hw/xfree86/os-support/linux/Makefile.am
+++ /dev/null
@@ -1,44 +0,0 @@
-noinst_LTLIBRARIES = liblinux.la
-
-if LNXACPI
-ACPI_SRCS = lnx_acpi.c
-if !LNXAPM
-ACPI_SRCS += lnx_apm.c
-endif
-XORG_CFLAGS += -DHAVE_ACPI
-endif
-
-if LNXAPM
-APM_SRCS = lnx_apm.c
-XORG_CFLAGS += -DHAVE_APM
-endif
-
-if !LNXAPM
-if !LNXACPI
-ACPI_SRCS = $(srcdir)/../shared/pm_noop.c
-endif
-endif
-
-if SYSTEMD_LOGIND
-LOGIND_SRCS = systemd-logind.c
-XORG_CFLAGS += $(DBUS_CFLAGS)
-endif
-
-if AGP
-AGP_SRCS = lnx_agp.c
-endif
-
-liblinux_la_SOURCES = linux.h lnx_init.c lnx_video.c \
-                      lnx_kmod.c lnx_bell.c lnx_platform.c \
-		     $(srcdir)/../shared/VTsw_usl.c \
-		     $(srcdir)/../shared/posix_tty.c \
-                     $(srcdir)/../shared/vidmem.c \
-		     $(srcdir)/../shared/sigio.c \
-                     $(ACPI_SRCS) \
-                     $(APM_SRCS) \
-                     $(LOGIND_SRCS) \
-		     $(AGP_SRCS)
-
-AM_CFLAGS = -DHAVE_SYSV_IPC $(DIX_CFLAGS) $(XORG_CFLAGS) $(PLATFORM_DEFINES)
-
-AM_CPPFLAGS = $(XORG_INCS) $(PLATFORM_INCLUDES) $(LIBDRM_CFLAGS)
diff --git a/hw/xfree86/os-support/linux/lnx_platform.c b/hw/xfree86/os-support/linux/lnx_platform.c
index 8a6be97aa..90013573c 100644
--- a/hw/xfree86/os-support/linux/lnx_platform.c
+++ b/hw/xfree86/os-support/linux/lnx_platform.c
@@ -125,7 +125,7 @@ xf86PlatformReprobeDevice(int index, struct OdevAttributes *attribs)
         xf86_remove_platform_device(index);
         return;
     }
-    ret = xf86platformAddDevice(index);
+    ret = xf86platformAddDevice(xf86PlatformFindHotplugDriver(index), index);
     if (ret == -1)
         xf86_remove_platform_device(index);
 }
@@ -173,6 +173,8 @@ void NewGPUDeviceRequest(struct OdevAttributes *attribs)
 {
     int old_num = xf86_num_platform_devices;
     int ret;
+    const char *driver_name;
+
     xf86PlatformDeviceProbe(attribs);
 
     if (old_num == xf86_num_platform_devices)
@@ -181,7 +183,11 @@ void NewGPUDeviceRequest(struct OdevAttributes *attribs)
     if (xf86_get_platform_device_unowned(xf86_num_platform_devices - 1) == TRUE)
         return;
 
-    ret = xf86platformAddDevice(xf86_num_platform_devices-1);
+    /* Scan and update PCI devices before adding new platform device */
+    xf86PlatformScanPciDev();
+    driver_name = xf86PlatformFindHotplugDriver(xf86_num_platform_devices - 1);
+
+    ret = xf86platformAddDevice(driver_name, xf86_num_platform_devices-1);
     if (ret == -1)
         xf86_remove_platform_device(xf86_num_platform_devices-1);
 
diff --git a/hw/xfree86/os-support/linux/systemd-logind.c b/hw/xfree86/os-support/linux/systemd-logind.c
index dbb00cd85..d97e92ff8 100644
--- a/hw/xfree86/os-support/linux/systemd-logind.c
+++ b/hw/xfree86/os-support/linux/systemd-logind.c
@@ -310,15 +310,19 @@ cleanup:
  */
 void systemd_logind_drop_master(void)
 {
+    struct systemd_logind_info *info = &logind_info;
     int i;
+    /* Our VT_PROCESS usage guarantees we've already given up the vt */
+    info->active = info->vt_active = FALSE;
     for (i = 0; i < xf86_num_platform_devices; i++) {
         if (xf86_platform_devices[i].flags & XF86_PDEV_SERVER_FD) {
             dbus_int32_t major, minor;
-            struct systemd_logind_info *info = &logind_info;
 
             xf86_platform_devices[i].flags |= XF86_PDEV_PAUSED;
             major = xf86_platform_odev_attributes(i)->major;
             minor = xf86_platform_odev_attributes(i)->minor;
+            LogMessage(X_INFO, "systemd-logind: drop master for %u:%u\n",
+               major, minor);
             systemd_logind_ack_pause(info, minor, major);
         }
     }
diff --git a/hw/xfree86/os-support/meson.build b/hw/xfree86/os-support/meson.build
index b6069ee85..64a6c9adb 100644
--- a/hw/xfree86/os-support/meson.build
+++ b/hw/xfree86/os-support/meson.build
@@ -113,7 +113,7 @@ elif host_machine.system().endswith('bsd')
         endif
     elif host_machine.cpu_family() == 'arm'
         srcs_xorg_os_support += 'bsd/arm_video.c'
-    elif host_machine.cpu_family() == 'powerpc'
+    elif host_machine.cpu_family() == 'ppc' or host_machine.cpu_family() == 'ppc64'
         srcs_xorg_os_support += 'bsd/ppc_video.c'
     elif host_machine.cpu_family() == 'sparc64'
         srcs_xorg_os_support += 'bsd/sparc64_video.c'
diff --git a/hw/xfree86/os-support/misc/Makefile.am b/hw/xfree86/os-support/misc/Makefile.am
deleted file mode 100644
index 0265aecd4..000000000
--- a/hw/xfree86/os-support/misc/Makefile.am
+++ /dev/null
@@ -1,12 +0,0 @@
-
-noinst_LTLIBRARIES = libmisc.la
-
-libmisc_la_SOURCES = SlowBcopy.c
-
-#AM_LDFLAGS = -r
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-EXTRA_DIST = $(I386_SRCS) $(PORTIO_SRCS)
diff --git a/hw/xfree86/os-support/solaris/Makefile.am b/hw/xfree86/os-support/solaris/Makefile.am
deleted file mode 100644
index ae109ff09..000000000
--- a/hw/xfree86/os-support/solaris/Makefile.am
+++ /dev/null
@@ -1,36 +0,0 @@
-if SOLARIS_VT
-VTSW_SRC = sun_VTsw.c
-else
-VTSW_SRC = $(srcdir)/../shared/VTsw_noop.c
-endif
-
-if AGP
-AGP_SRC = sun_agp.c
-else
-AGP_SRC = $(srcdir)/../shared/agp_noop.c
-endif
-
-SOLARIS_INOUT_SRC = solaris-@SOLARIS_INOUT_ARCH@.S
-DISTCLEANFILES = solaris-@SOLARIS_INOUT_ARCH@.il
-
-solaris-@SOLARIS_INOUT_ARCH@.il: solaris-@SOLARIS_INOUT_ARCH@.S
-	$(CPP) -P -DINLINE_ASM $(srcdir)/solaris-@SOLARIS_INOUT_ARCH@.S > $@
-
-noinst_LTLIBRARIES = libsolaris.la
-libsolaris_la_SOURCES = sun_init.c \
-	sun_vid.c sun_bell.c $(AGP_SRC) sun_apm.c \
-	$(srcdir)/../shared/kmod_noop.c \
-	$(srcdir)/../shared/posix_tty.c \
-	$(srcdir)/../shared/sigio.c \
-	$(srcdir)/../shared/vidmem.c \
-	$(VTSW_SRC)
-nodist_libsolaris_la_SOURCES = $(SOLARIS_INOUT_SRC)
-
-sdk_HEADERS =
-nodist_sdk_HEADERS = solaris-@SOLARIS_INOUT_ARCH@.il
-
-AM_CFLAGS = -DHAVE_SYSV_IPC $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-AM_CPPFLAGS = $(XORG_INCS) 
-
-EXTRA_DIST = solaris-amd64.S solaris-ia32.S solaris-sparcv8plus.S sun_inout.s
diff --git a/hw/xfree86/os-support/solaris/sun_init.c b/hw/xfree86/os-support/solaris/sun_init.c
index cc50f36c4..d7bf2e54b 100644
--- a/hw/xfree86/os-support/solaris/sun_init.c
+++ b/hw/xfree86/os-support/solaris/sun_init.c
@@ -61,6 +61,7 @@ static char consoleDev[PATH_MAX] = "/dev/fb";
    Used by hw/xfree86/common/xf86AutoConfig.c for VIS_GETIDENTIFIER */
 _X_HIDDEN char xf86SolarisFbDev[PATH_MAX] = "/dev/fb";
 
+#ifdef HAS_USL_VTS
 static void
 switch_to(int vt, const char *from)
 {
@@ -76,6 +77,7 @@ switch_to(int vt, const char *from)
         xf86Msg(X_WARNING, "%s: VT_WAITACTIVE failed: %s\n",
                 from, strerror(errno));
 }
+#endif
 
 void
 xf86OpenConsole(void)
diff --git a/hw/xfree86/os-support/solaris/sun_vid.c b/hw/xfree86/os-support/solaris/sun_vid.c
index 2b48e66b0..8e94fcced 100644
--- a/hw/xfree86/os-support/solaris/sun_vid.c
+++ b/hw/xfree86/os-support/solaris/sun_vid.c
@@ -88,7 +88,7 @@ xf86EnableIO(void)
 {
 #if defined(__i386__) || defined(__i386) || defined(__x86)
     if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0) {
-        xf86Msg(X_WARNING, "xf86EnableIOPorts: Failed to set IOPL for I/O\n");
+        xf86Msg(X_WARNING, "xf86EnableIO: Failed to set IOPL for I/O\n");
         return FALSE;
     }
 #endif                          /* i386 */
diff --git a/hw/xfree86/os-support/stub/Makefile.am b/hw/xfree86/os-support/stub/Makefile.am
deleted file mode 100644
index 19468c6de..000000000
--- a/hw/xfree86/os-support/stub/Makefile.am
+++ /dev/null
@@ -1,18 +0,0 @@
-noinst_LTLIBRARIES = libstub.la
-
-AM_CFLAGS = $(XORG_CFLAGS) $(DIX_CFLAGS)
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-libstub_la_SOURCES = \
-	$(srcdir)/../shared/VTsw_noop.c \
-	$(srcdir)/../shared/agp_noop.c \
-	$(srcdir)/../shared/ioperm_noop.c \
-	$(srcdir)/../shared/kmod_noop.c \
-	$(srcdir)/../shared/pm_noop.c \
-	$(srcdir)/../shared/vidmem.c \
-	$(srcdir)/../shared/posix_tty.c \
-	$(srcdir)/../shared/sigio.c \
-	stub_bell.c \
-	stub_init.c \
-	stub_video.c
diff --git a/hw/xfree86/parser/Makefile.am b/hw/xfree86/parser/Makefile.am
deleted file mode 100644
index 2e4c6afdb..000000000
--- a/hw/xfree86/parser/Makefile.am
+++ /dev/null
@@ -1,40 +0,0 @@
-noinst_LTLIBRARIES = libxf86config.la
-
-INTERNAL_SOURCES= \
-	Device.c \
-	Files.c \
-	Flags.c \
-	Input.c \
-	InputClass.c \
-	OutputClass.c \
-	Layout.c \
-	Module.c \
-	Video.c \
-	Monitor.c \
-	Pointer.c \
-	Screen.c \
-	Vendor.c \
-	read.c \
-	scan.c \
-	write.c \
-	DRI.c \
-	Extensions.c
-
-libxf86config_la_SOURCES = \
-	$(INTERNAL_SOURCES)
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS) \
-	-DDATADIR=\"$(datadir)\"
-
-EXTRA_DIST = \
-	Configint.h \
-	configProcs.h \
-	xf86Optrec.h \
-	xf86Parser.h \
-	xf86tokens.h
-
-sdk_HEADERS = \
-	xf86Parser.h \
-	xf86Optrec.h
-
-AM_CPPFLAGS = -I$(srcdir)/../common
diff --git a/hw/xfree86/ramdac/CURSOR.NOTES b/hw/xfree86/ramdac/CURSOR.NOTES
index 3be79a1e2..eb77f70be 100644
--- a/hw/xfree86/ramdac/CURSOR.NOTES
+++ b/hw/xfree86/ramdac/CURSOR.NOTES
@@ -124,7 +124,7 @@ Flags
    Hardware cursor data consists of two pieces, a source and a mask.
    The mask is a bitmap indicating which parts of the cursor are
    transparent and which parts are drawn.  The source is a bitmap
-   indicating which parts of the non-transparent portion of the the
+   indicating which parts of the non-transparent portion of the
    cursor should be painted in the foreground color and which should
    be painted in the background color.
 
diff --git a/hw/xfree86/ramdac/Makefile.am b/hw/xfree86/ramdac/Makefile.am
deleted file mode 100644
index ffae2c31f..000000000
--- a/hw/xfree86/ramdac/Makefile.am
+++ /dev/null
@@ -1,10 +0,0 @@
-noinst_LTLIBRARIES = libramdac.la
-
-libramdac_la_SOURCES = xf86CursorRD.c xf86HWCurs.c
-
-sdk_HEADERS = xf86Cursor.h
-
-EXTRA_DIST = xf86CursorPriv.h CURSOR.NOTES
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-AM_CPPFLAGS = $(XORG_INCS)
diff --git a/hw/xfree86/shadowfb/Makefile.am b/hw/xfree86/shadowfb/Makefile.am
deleted file mode 100644
index 67fb2e4cb..000000000
--- a/hw/xfree86/shadowfb/Makefile.am
+++ /dev/null
@@ -1,10 +0,0 @@
-module_LTLIBRARIES = libshadowfb.la
-libshadowfb_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
-libshadowfb_la_SOURCES = sfbmodule.c shadowfb.c
-libshadowfb_la_LIBADD = $(PIXMAN_LIBS)
-
-sdk_HEADERS = shadowfb.h
-
-AM_CPPFLAGS = $(XORG_INCS)
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
diff --git a/hw/xfree86/utils/Makefile.am b/hw/xfree86/utils/Makefile.am
deleted file mode 100644
index ce83bc3b1..000000000
--- a/hw/xfree86/utils/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-SUBDIRS = \
-	gtf \
-	man
diff --git a/hw/xfree86/utils/gtf/Makefile.am b/hw/xfree86/utils/gtf/Makefile.am
deleted file mode 100644
index f77bf608e..000000000
--- a/hw/xfree86/utils/gtf/Makefile.am
+++ /dev/null
@@ -1,27 +0,0 @@
-# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-# 
-
-bin_PROGRAMS = gtf
-
-gtf_SOURCES = gtf.c
-gtf_CFLAGS = $(XORG_CFLAGS)
-gtf_LDADD = -lm
diff --git a/hw/xfree86/utils/man/Makefile.am b/hw/xfree86/utils/man/Makefile.am
deleted file mode 100644
index 25b3b6a4f..000000000
--- a/hw/xfree86/utils/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = gtf.man
diff --git a/hw/xfree86/vgahw/Makefile.am b/hw/xfree86/vgahw/Makefile.am
deleted file mode 100644
index b8196a695..000000000
--- a/hw/xfree86/vgahw/Makefile.am
+++ /dev/null
@@ -1,8 +0,0 @@
-module_LTLIBRARIES = libvgahw.la
-libvgahw_la_LDFLAGS = -avoid-version
-libvgahw_la_LIBADD = $(PCIACCESS_LIBS)
-libvgahw_la_SOURCES = vgaHW.c vgaHWmodule.c
-AM_CPPFLAGS = $(XORG_INCS) -I$(srcdir)/../ddc -I$(srcdir)/../i2c
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-sdk_HEADERS = vgaHW.h
diff --git a/hw/xfree86/x86emu/Makefile.am b/hw/xfree86/x86emu/Makefile.am
deleted file mode 100644
index 2a55d6353..000000000
--- a/hw/xfree86/x86emu/Makefile.am
+++ /dev/null
@@ -1,29 +0,0 @@
-if INT10_X86EMU
-noinst_LTLIBRARIES = libx86emu.la
-endif
-
-libx86emu_la_SOURCES = debug.c \
-                      decode.c \
-                      fpu.c \
-                      ops2.c \
-                      ops.c \
-                      prim_ops.c \
-                      sys.c \
-                      x86emu.h
-
-AM_CPPFLAGS = 
-
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
-
-EXTRA_DIST = validate.c \
-             x86emu/debug.h \
-             x86emu/decode.h \
-             x86emu/fpu.h \
-             x86emu/fpu_regs.h \
-             x86emu/ops.h \
-             x86emu/prim_asm.h \
-             x86emu/prim_ops.h \
-	     x86emu/prim_x86_gcc.h \
-             x86emu/regs.h \
-             x86emu/types.h \
-             x86emu/x86emui.h
diff --git a/hw/xfree86/x86emu/ops.c b/hw/xfree86/x86emu/ops.c
index 8846db0ca..4983382bc 100644
--- a/hw/xfree86/x86emu/ops.c
+++ b/hw/xfree86/x86emu/ops.c
@@ -58,7 +58,7 @@
 * modularize it, was basically: 1) no unnecessary subroutine calls,
 * 2) no routines more than about 200 lines in size, and 3) modularize
 * any code that I might not get right the first time.  The fetch_*
-* subroutines fall into the latter category.  The The decode_* fall
+* subroutines fall into the latter category.  The decode_* fall
 * into the second category.  The coding of the "switch(mod){ .... }"
 * in many of the subroutines below falls into the first category.
 * Especially, the coding of {add,and,or,sub,...}_{byte,word}
diff --git a/hw/xfree86/x86emu/prim_ops.c b/hw/xfree86/x86emu/prim_ops.c
index 35ef94710..47877eb26 100644
--- a/hw/xfree86/x86emu/prim_ops.c
+++ b/hw/xfree86/x86emu/prim_ops.c
@@ -2622,8 +2622,8 @@ ins(int size)
                 store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
                                     (*sys_inl) (M.x86.R_DX));
                 M.x86.R_DI += inc;
-                break;
             }
+            break;
         }
         M.x86.R_CX = 0;
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
@@ -2688,8 +2688,8 @@ outs(int size)
                 (*sys_outl) (M.x86.R_DX,
                              fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
                 M.x86.R_SI += inc;
-                break;
             }
+            break;
         }
         M.x86.R_CX = 0;
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
diff --git a/hw/xfree86/xkb/Makefile.am b/hw/xfree86/xkb/Makefile.am
deleted file mode 100644
index 252cf3b5d..000000000
--- a/hw/xfree86/xkb/Makefile.am
+++ /dev/null
@@ -1,6 +0,0 @@
-noinst_LTLIBRARIES = libxorgxkb.la
-
-AM_CFLAGS = @XORG_CFLAGS@ @DIX_CFLAGS@
-AM_CPPFLAGS = @XORG_INCS@
-
-libxorgxkb_la_SOURCES = xkbVT.c xkbPrivate.c xkbKillSrv.c
diff --git a/hw/xnest/Makefile.am b/hw/xnest/Makefile.am
deleted file mode 100644
index 3342f9e13..000000000
--- a/hw/xnest/Makefile.am
+++ /dev/null
@@ -1,61 +0,0 @@
-SUBDIRS = man
-
-bin_PROGRAMS = Xnest
-
-AM_CFLAGS = -DHAVE_XNEST_CONFIG_H \
-            $(DIX_CFLAGS) \
-            $(XNESTMODULES_CFLAGS)
-
-SRCS =	Args.c \
-	Args.h \
-	Color.c \
-	Color.h \
-	Cursor.c \
-	Display.c \
-	Display.h \
-	Drawable.h \
-	Events.c \
-	Events.h \
-	Font.c \
-	GC.c \
-	GCOps.c \
-	GCOps.h \
-	Handlers.c \
-	Handlers.h \
-	Init.c \
-	Init.h \
-	Keyboard.c \
-	Keyboard.h \
-	Pixmap.c \
-	Pointer.c \
-	Pointer.h \
-	Screen.c \
-	Screen.h \
-	Visual.c \
-	Visual.h \
-	Window.c \
-	XNCursor.h \
-	Xnest.h \
-	XNFont.h \
-	XNGC.h \
-	XNPixmap.h \
-	XNWindow.h \
-	xnest-config.h \
-	$(top_srcdir)/mi/miinitext.c \
-	$(top_srcdir)/mi/miinitext.h
-
-XNEST_LIBS = \
-        @XNEST_LIBS@ \
-	$(top_builddir)/Xi/libXistubs.la
-
-Xnest_SOURCES = $(SRCS)
-
-Xnest_DEPENDENCIES = $(XNEST_LIBS)
-Xnest_LDADD = $(XNEST_LIBS) $(XNEST_SYS_LIBS) $(XSERVER_SYS_LIBS)
-Xnest_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
-
-EXTRA_DIST = icon \
-             screensaver
-
-relink:
-	$(AM_V_at)rm -f Xnest$(EXEEXT) && $(MAKE) Xnest$(EXEEXT)
diff --git a/hw/xnest/man/Makefile.am b/hw/xnest/man/Makefile.am
deleted file mode 100644
index 30b6370bc..000000000
--- a/hw/xnest/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = Xnest.man
diff --git a/hw/xnest/man/Xnest.man b/hw/xnest/man/Xnest.man
index 1057e2d72..6ad871d65 100644
--- a/hw/xnest/man/Xnest.man
+++ b/hw/xnest/man/Xnest.man
@@ -309,7 +309,7 @@ development of
 .PP
 Since
 .B Xnest
-need not use the same default visual as the the real server, the top-level
+need not use the same default visual as the real server, the top-level
 window of the
 .B Xnest
 client always has its own color map.
diff --git a/hw/xquartz/GL/Makefile.am b/hw/xquartz/GL/Makefile.am
deleted file mode 100644
index 736c94b4a..000000000
--- a/hw/xquartz/GL/Makefile.am
+++ /dev/null
@@ -1,17 +0,0 @@
-noinst_LTLIBRARIES = libCGLCore.la
-AM_CFLAGS = $(DIX_CFLAGS) $(GL_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir) \
-	-I$(top_srcdir)/glx \
-	-I$(top_srcdir)/hw/xquartz \
-	-I$(top_srcdir)/hw/xquartz/xpr \
-	-I$(top_srcdir)/miext/damage
-
-libCGLCore_la_SOURCES = \
-	indirect.c \
-	capabilities.c \
-	visualConfigs.c
-
-EXTRA_DIST = \
-	capabilities.h \
-	visualConfigs.h
diff --git a/hw/xquartz/Makefile.am b/hw/xquartz/Makefile.am
deleted file mode 100644
index 9db38c403..000000000
--- a/hw/xquartz/Makefile.am
+++ /dev/null
@@ -1,54 +0,0 @@
-noinst_LTLIBRARIES = libXquartz.la
-AM_CFLAGS = $(DIX_CFLAGS)
-AM_OBJCFLAGS = $(DIX_CFLAGS)
-AM_CPPFLAGS = \
-	-DXQUARTZ_DATA_DIR=\"$(datadir)/X11/XQuartz\" \
-	-DXSERVER_VERSION=\"$(VERSION)\" \
-	-DBUNDLE_ID_PREFIX=\"$(BUNDLE_ID_PREFIX)\" \
-	-DUSE_NEW_CLUT \
-	-DXFree86Server \
-	-I$(top_srcdir)/miext/rootless \
-	-I$(top_builddir)/pseudoramiX \
-	-I$(top_builddir)"
-
-if GLX
-GL_DIR = GL
-endif
-
-SUBDIRS = bundle . $(GL_DIR) xpr pbproxy mach-startup man
-
-DIST_SUBDIRS = bundle . GL xpr pbproxy mach-startup man
-
-libXquartz_la_SOURCES = \
-	$(top_srcdir)/mi/miinitext.c \
-	$(top_srcdir)/mi/miinitext.h \
-	NSUserDefaults+XQuartzDefaults.m \
-	X11Application.m \
-	X11Controller.m \
-	applewm.c \
-	darwin.c \
-	darwinEvents.c \
-	darwinXinput.c \
-	keysym2ucs.c \
-	quartz.c \
-	quartzKeyboard.c \
-	quartzStartup.c \
-	quartzRandR.c
-
-libXquartz_la_LIBADD = $(top_builddir)/pseudoramiX/libPseudoramiX.la
-
-EXTRA_DIST = \
-	NSUserDefaults+XQuartzDefaults.h \
-	X11Application.h \
-	X11Controller.h \
-	applewmExt.h \
-	darwin.h \
-	darwinfb.h \
-	darwinEvents.h \
-	defaults.plist \
-	keysym2ucs.h \
-	quartz.h \
-	quartzKeyboard.h \
-	quartzRandR.h \
-	sanitizedCarbon.h \
-	sanitizedCocoa.h
diff --git a/hw/xquartz/bundle/Info.plist.cpp b/hw/xquartz/bundle/Info.plist.cpp
index 7cb59ea77..f576f7eb5 100644
--- a/hw/xquartz/bundle/Info.plist.cpp
+++ b/hw/xquartz/bundle/Info.plist.cpp
@@ -64,9 +64,9 @@
 	<key>LSApplicationCategoryType</key>
 		<string>public.app-category.utilities</string>
 	<key>NSHumanReadableCopyright</key>
-		<string>© 2003-2022 Apple Inc.
+		<string>© 2003-2023 Apple Inc.
 © 2003 XFree86 Project, Inc.
-© 2003-2022 X.org Foundation, Inc.
+© 2003-2023 X.org Foundation, Inc.
 </string>
 	<key>NSMainNibFile</key>
 		<string>main</string>
diff --git a/hw/xquartz/bundle/Makefile.am b/hw/xquartz/bundle/Makefile.am
deleted file mode 100644
index be7d28b8a..000000000
--- a/hw/xquartz/bundle/Makefile.am
+++ /dev/null
@@ -1,183 +0,0 @@
-include cpprules.in
-
-CPP_FILES_FLAGS = \
-	-DAPPLE_APPLICATION_NAME="$(APPLE_APPLICATION_NAME)" \
-	-DBUNDLE_ID_PREFIX="$(BUNDLE_ID_PREFIX)" \
-	-DBUNDLE_VERSION="$(BUNDLE_VERSION)" \
-	-DBUNDLE_VERSION_STRING="$(BUNDLE_VERSION_STRING)"
-
-if XQUARTZ_SPARKLE
-CPP_FILES_FLAGS += -DXQUARTZ_SPARKLE -DXQUARTZ_SPARKLE_FEED_URL="$(XQUARTZ_SPARKLE_FEED_URL)"
-endif
-
-install-data-hook:
-	$(srcdir)/mk_bundke.sh $(srcdir) $(builddir) $(DESTDIR)$(APPLE_APPLICATIONS_DIR)/$(APPLE_APPLICATION_NAME).app install
-
-uninstall-hook:
-	$(RM) -rf $(DESTDIR)$(APPLE_APPLICATIONS_DIR)/$(APPLE_APPLICATION_NAME).app/Contents/Resources
-	$(RM) -rf $(DESTDIR)$(APPLE_APPLICATIONS_DIR)/$(APPLE_APPLICATION_NAME).app/Contents/Info.plist
-	$(RM) -rf $(DESTDIR)$(APPLE_APPLICATIONS_DIR)/$(APPLE_APPLICATION_NAME).app/Contents/PkgInfo
-
-noinst_PRE = Info.plist.cpp
-noinst_DATA = $(noinst_PRE:plist.cpp=plist)
-
-CLEANFILES = $(noinst_DATA)
-
-EXTRA_DIST = \
-	chown-bundle.sh \
-	mk_bundke.sh \
-	X11.sh \
-	Info.plist.cpp \
-	PkgInfo \
-	$(resource_DATA) \
-	Resources/ar.lproj/Localizable.strings \
-	Resources/ar.lproj/locversion.plist \
-	Resources/ar.lproj/main.nib/designable.nib \
-	Resources/ar.lproj/main.nib/keyedobjects.nib \
-	Resources/ar.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/ca.lproj/Localizable.strings \
-	Resources/ca.lproj/locversion.plist \
-	Resources/ca.lproj/main.nib/designable.nib \
-	Resources/ca.lproj/main.nib/keyedobjects.nib \
-	Resources/ca.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/cs.lproj/Localizable.strings \
-	Resources/cs.lproj/locversion.plist \
-	Resources/cs.lproj/main.nib/designable.nib \
-	Resources/cs.lproj/main.nib/keyedobjects.nib \
-	Resources/cs.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/da.lproj/Localizable.strings \
-	Resources/da.lproj/locversion.plist \
-	Resources/da.lproj/main.nib/designable.nib \
-	Resources/da.lproj/main.nib/keyedobjects.nib \
-	Resources/da.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/Dutch.lproj/Localizable.strings \
-	Resources/Dutch.lproj/locversion.plist \
-	Resources/Dutch.lproj/main.nib/designable.nib \
-	Resources/Dutch.lproj/main.nib/keyedobjects.nib \
-	Resources/Dutch.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/el.lproj/Localizable.strings \
-	Resources/el.lproj/locversion.plist \
-	Resources/el.lproj/main.nib/designable.nib \
-	Resources/el.lproj/main.nib/keyedobjects.nib \
-	Resources/el.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/English.lproj/Localizable.strings \
-	Resources/English.lproj/locversion.plist \
-	Resources/English.lproj/main.nib/designable.nib \
-	Resources/English.lproj/main.nib/keyedobjects.nib \
-	Resources/English.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/fi.lproj/Localizable.strings \
-	Resources/fi.lproj/locversion.plist \
-	Resources/fi.lproj/main.nib/designable.nib \
-	Resources/fi.lproj/main.nib/keyedobjects.nib \
-	Resources/fi.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/French.lproj/Localizable.strings \
-	Resources/French.lproj/locversion.plist \
-	Resources/French.lproj/main.nib/designable.nib \
-	Resources/French.lproj/main.nib/keyedobjects.nib \
-	Resources/French.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/German.lproj/Localizable.strings \
-	Resources/German.lproj/locversion.plist \
-	Resources/German.lproj/main.nib/designable.nib \
-	Resources/German.lproj/main.nib/keyedobjects.nib \
-	Resources/German.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/he.lproj/Localizable.strings \
-	Resources/he.lproj/locversion.plist \
-	Resources/he.lproj/main.nib/designable.nib \
-	Resources/he.lproj/main.nib/keyedobjects.nib \
-	Resources/he.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/hr.lproj/Localizable.strings \
-	Resources/hr.lproj/locversion.plist \
-	Resources/hr.lproj/main.nib/designable.nib \
-	Resources/hr.lproj/main.nib/keyedobjects.nib \
-	Resources/hr.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/hu.lproj/Localizable.strings \
-	Resources/hu.lproj/locversion.plist \
-	Resources/hu.lproj/main.nib/designable.nib \
-	Resources/hu.lproj/main.nib/keyedobjects.nib \
-	Resources/hu.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/Italian.lproj/Localizable.strings \
-	Resources/Italian.lproj/locversion.plist \
-	Resources/Italian.lproj/main.nib/designable.nib \
-	Resources/Italian.lproj/main.nib/keyedobjects.nib \
-	Resources/Italian.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/Japanese.lproj/Localizable.strings \
-	Resources/Japanese.lproj/locversion.plist \
-	Resources/Japanese.lproj/main.nib/designable.nib \
-	Resources/Japanese.lproj/main.nib/keyedobjects.nib \
-	Resources/Japanese.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/ko.lproj/Localizable.strings \
-	Resources/ko.lproj/locversion.plist \
-	Resources/ko.lproj/main.nib/designable.nib \
-	Resources/ko.lproj/main.nib/keyedobjects.nib \
-	Resources/ko.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/no.lproj/Localizable.strings \
-	Resources/no.lproj/locversion.plist \
-	Resources/no.lproj/main.nib/designable.nib \
-	Resources/no.lproj/main.nib/keyedobjects.nib \
-	Resources/no.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/pl.lproj/Localizable.strings \
-	Resources/pl.lproj/locversion.plist \
-	Resources/pl.lproj/main.nib/designable.nib \
-	Resources/pl.lproj/main.nib/keyedobjects.nib \
-	Resources/pl.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/pt.lproj/Localizable.strings \
-	Resources/pt.lproj/locversion.plist \
-	Resources/pt.lproj/main.nib/designable.nib \
-	Resources/pt.lproj/main.nib/keyedobjects.nib \
-	Resources/pt.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/pt_PT.lproj/Localizable.strings \
-	Resources/pt_PT.lproj/locversion.plist \
-	Resources/pt_PT.lproj/main.nib/designable.nib \
-	Resources/pt_PT.lproj/main.nib/keyedobjects.nib \
-	Resources/pt_PT.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/ro.lproj/Localizable.strings \
-	Resources/ro.lproj/locversion.plist \
-	Resources/ro.lproj/main.nib/designable.nib \
-	Resources/ro.lproj/main.nib/keyedobjects.nib \
-	Resources/ro.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/ru.lproj/Localizable.strings \
-	Resources/ru.lproj/locversion.plist \
-	Resources/ru.lproj/main.nib/designable.nib \
-	Resources/ru.lproj/main.nib/keyedobjects.nib \
-	Resources/ru.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/sk.lproj/Localizable.strings \
-	Resources/sk.lproj/locversion.plist \
-	Resources/sk.lproj/main.nib/designable.nib \
-	Resources/sk.lproj/main.nib/keyedobjects.nib \
-	Resources/sk.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/Spanish.lproj/Localizable.strings \
-	Resources/Spanish.lproj/locversion.plist \
-	Resources/Spanish.lproj/main.nib/designable.nib \
-	Resources/Spanish.lproj/main.nib/keyedobjects.nib \
-	Resources/Spanish.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/sv.lproj/Localizable.strings \
-	Resources/sv.lproj/locversion.plist \
-	Resources/sv.lproj/main.nib/designable.nib \
-	Resources/sv.lproj/main.nib/keyedobjects.nib \
-	Resources/sv.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/th.lproj/Localizable.strings \
-	Resources/th.lproj/locversion.plist \
-	Resources/th.lproj/main.nib/designable.nib \
-	Resources/th.lproj/main.nib/keyedobjects.nib \
-	Resources/th.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/tr.lproj/Localizable.strings \
-	Resources/tr.lproj/locversion.plist \
-	Resources/tr.lproj/main.nib/designable.nib \
-	Resources/tr.lproj/main.nib/keyedobjects.nib \
-	Resources/tr.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/uk.lproj/Localizable.strings \
-	Resources/uk.lproj/locversion.plist \
-	Resources/uk.lproj/main.nib/designable.nib \
-	Resources/uk.lproj/main.nib/keyedobjects.nib \
-	Resources/uk.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/X11.icns \
-	Resources/zh_CN.lproj/Localizable.strings \
-	Resources/zh_CN.lproj/locversion.plist \
-	Resources/zh_CN.lproj/main.nib/designable.nib \
-	Resources/zh_CN.lproj/main.nib/keyedobjects.nib \
-	Resources/zh_CN.lproj/main.nib/keyedobjects-110000.nib \
-	Resources/zh_TW.lproj/Localizable.strings \
-	Resources/zh_TW.lproj/locversion.plist \
-	Resources/zh_TW.lproj/main.nib/designable.nib \
-	Resources/zh_TW.lproj/main.nib/keyedobjects.nib \
-	Resources/zh_TW.lproj/main.nib/keyedobjects-110000.nib
diff --git a/hw/xquartz/mach-startup/Makefile.am b/hw/xquartz/mach-startup/Makefile.am
deleted file mode 100644
index e250b2869..000000000
--- a/hw/xquartz/mach-startup/Makefile.am
+++ /dev/null
@@ -1,94 +0,0 @@
-AM_CPPFLAGS = \
-	-I$(srcdir)/.. \
-	-I$(top_builddir) \
-	-DXSERVER_VERSION=\"$(VERSION)\" \
-	-DX11BINDIR=\"$(bindir)\"
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-x11appdir = $(APPLE_APPLICATIONS_DIR)/$(APPLE_APPLICATION_NAME).app/Contents/MacOS
-x11app_PROGRAMS = X11.bin X11
-
-dist_X11_bin_SOURCES = \
-	bundle-main.c
-
-dist_X11_SOURCES = \
-	bundle_trampoline.c
-
-nodist_X11_bin_SOURCES = \
-	mach_startupServer.c \
-	mach_startupUser.c
-
-X11_bin_DEPENDENCIES = \
-	$(top_builddir)/hw/xquartz/libXquartz.la \
-	$(top_builddir)/hw/xquartz/xpr/libXquartzXpr.la \
-	$(top_builddir)/dix/dixfonts.lo \
-	$(top_builddir)/miext/rootless/librootless.la \
-	$(top_builddir)/hw/xquartz/pbproxy/libxpbproxy.la \
-	$(XQUARTZ_LIBS) $(XSERVER_LIBS)
-
-# $(XSERVER_SYS_LIBS) is placed here in order to set command line ordering
-# to work around build issues on Tiger.
-X11_bin_LDADD = $(X11_bin_DEPENDENCIES) $(XSERVER_SYS_LIBS)
-
-X11_bin_LDFLAGS =  \
-	-lXplugin \
-	-XCClinker -Objc \
-	-Wl,-u,_miDCInitialize \
-	-Wl,-framework,Carbon \
-	-Wl,-framework,Cocoa \
-	-Wl,-framework,CoreAudio \
-	-Wl,-framework,IOKit
-
-if GLX
-X11_bin_DEPENDENCIES += \
-	$(top_builddir)/hw/xquartz/GL/libCGLCore.la \
-	$(top_builddir)/glx/libglxvnd.la \
-	$(top_builddir)/glx/libglx.la
-
-X11_bin_LDFLAGS += \
-	-Wl,-framework,OpenGL
-endif
-
-if XQUARTZ_SPARKLE
-X11_bin_LDFLAGS += \
-	-Wl,-framework,Sparkle
-endif
-
-if RECORD
-X11_bin_DEPENDENCIES += \
-	$(top_builddir)/record/librecord.la
-endif
-
-bin_PROGRAMS = Xquartz
-
-dist_Xquartz_SOURCES = \
-	stub.c \
-	launchd_fd.c
-
-nodist_Xquartz_SOURCES = \
-	mach_startupUser.c
-
-Xquartz_LDFLAGS =  \
-	-Wl,-framework,CoreServices
-
-if XQUARTZ
-
-BUILT_SOURCES = \
-	mach_startupServer.c \
-	mach_startupUser.c \
-	mach_startupServer.h \
-	mach_startup.h
-
-CLEANFILES = \
-	$(BUILT_SOURCES)
-
-$(BUILT_SOURCES): $(srcdir)/mach_startup.defs
-	mig -sheader mach_startupServer.h $(srcdir)/mach_startup.defs
-
-endif
-
-EXTRA_DIST = \
-	launchd_fd.h \
-	mach_startup.defs \
-	mach_startup_types.h
diff --git a/hw/xquartz/mach-startup/bundle-main.c b/hw/xquartz/mach-startup/bundle-main.c
index 363bf5ac1..de82e2280 100644
--- a/hw/xquartz/mach-startup/bundle-main.c
+++ b/hw/xquartz/mach-startup/bundle-main.c
@@ -72,6 +72,10 @@ FatalError(const char *f, ...) _X_ATTRIBUTE_PRINTF(1, 2) _X_NORETURN;
 
 extern int noPanoramiXExtension;
 
+#ifdef COMPOSITE
+extern Bool noCompositeExtension;
+#endif
+
 #define DEFAULT_CLIENT X11BINDIR "/xterm"
 #define DEFAULT_STARTX X11BINDIR "/startx -- " X11BINDIR "/Xquartz"
 #define DEFAULT_SHELL  "/bin/sh"
@@ -626,12 +630,20 @@ main(int argc, char **argv, char **envp)
     mach_port_t mp;
     kern_return_t kr;
 
+    /* Ignore SIGPIPE */
+    signal(SIGPIPE, SIG_IGN);
+
     /* Setup our environment for our children */
     setup_env();
 
     /* The server must not run the PanoramiX operations. */
     noPanoramiXExtension = TRUE;
 
+#ifdef COMPOSITE
+    /* https://gitlab.freedesktop.org/xorg/xserver/-/issues/1409 */
+    noCompositeExtension = TRUE;
+#endif
+
     /* Setup the initial crasherporter info */
     strlcpy(__crashreporter_info_buff__, __crashreporter_info__base,
             sizeof(__crashreporter_info_buff__));
diff --git a/hw/xquartz/man/Makefile.am b/hw/xquartz/man/Makefile.am
deleted file mode 100644
index 5a0cde7cc..000000000
--- a/hw/xquartz/man/Makefile.am
+++ /dev/null
@@ -1,2 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = Xquartz.man
diff --git a/hw/xquartz/man/Xquartz.man b/hw/xquartz/man/Xquartz.man
index 643bea9df..9b01bbaf3 100644
--- a/hw/xquartz/man/Xquartz.man
+++ b/hw/xquartz/man/Xquartz.man
@@ -73,10 +73,10 @@ Enable syncing between the OSX pasteboard and clipboard/primary selection buffer
 Update the X11 CLIPBOARD when the OSX NSPasteboard is updated.
 .TP 8
 .B defaults write @bundle_id_prefix@.X11 sync_pasteboard_to_primary -boolean true
-Update the the X11 PRIMARY buffer when the OSX NSPasteboard is updated.
+Update the X11 PRIMARY buffer when the OSX NSPasteboard is updated.
 .TP 8
 .B defaults write @bundle_id_prefix@.X11 sync_clipboard_to_pasteboard -boolean true
-Update the the OSX NSPasteboard when the X11 CLIPBOARD is updated.  Note that enabling this option causes the clipboard synchronization to act as a clipboard manager in X11.  This makes it impossible to use xclipboard, klipper, or any other such clipboard managers.  If you want to use any of these programs, you must disable this option.
+Update the OSX NSPasteboard when the X11 CLIPBOARD is updated.  Note that enabling this option causes the clipboard synchronization to act as a clipboard manager in X11.  This makes it impossible to use xclipboard, klipper, or any other such clipboard managers.  If you want to use any of these programs, you must disable this option.
 .TP 8
 .B defaults write @bundle_id_prefix@.X11 sync_primary_on_select -boolean true
 This option defaults to false and is provided only "for experts."  It updates the NSPasteboard whenever a new X11 selection is made (rather than requiring you to hit cmd-c to copy the selection to the NSPasteboard).  Since the X11 protocol does not require applications to send notification when they change selection, this might not work in all cases (if you run into this problem, try selecting text in another application first, then selecting the text you want).
diff --git a/hw/xquartz/pbproxy/Makefile.am b/hw/xquartz/pbproxy/Makefile.am
deleted file mode 100644
index b26b8e273..000000000
--- a/hw/xquartz/pbproxy/Makefile.am
+++ /dev/null
@@ -1,28 +0,0 @@
-AM_CPPFLAGS=-I.. -DXQUARTZ_DATA_DIR=\"$(datadir)/X11/XQuartz\"
-
-AM_CFLAGS=$(XPBPROXY_CFLAGS)
-AM_OBJCFLAGS=$(XPBPROXY_CFLAGS)
-
-noinst_LTLIBRARIES = libxpbproxy.la
-libxpbproxy_la_SOURCES = \
-	trick_autotools.c \
-	main.m \
-	x-input.m \
-	x-selection.m
-
-libxpbproxy_la_LDFLAGS=$(XPBPROXY_LIBS)
-
-if STANDALONE_XPBPROXY
-
-bin_PROGRAMS = xpbproxy
-xpbproxy_SOURCES = app-main.m ../NSUserDefaults+XQuartzDefaults.m
-xpbproxy_LDADD = libxpbproxy.la
-xpbproxy_LDFLAGS = -Wl,-framework,Cocoa
-
-AM_CPPFLAGS += -DSTANDALONE_XPBPROXY
-
-endif
-
-EXTRA_DIST = \
-	pbproxy.h \
-	x-selection.h
diff --git a/hw/xquartz/xpr/Makefile.am b/hw/xquartz/xpr/Makefile.am
deleted file mode 100644
index c654ee595..000000000
--- a/hw/xquartz/xpr/Makefile.am
+++ /dev/null
@@ -1,33 +0,0 @@
-noinst_LTLIBRARIES = libXquartzXpr.la
-
-AM_CFLAGS =  $(DIX_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(srcdir) -I$(srcdir)/.. \
-	-I$(top_builddir)/pseudoramiX \
-	-I$(top_srcdir)/miext \
-	-I$(top_srcdir)/miext/rootless
-
-libXquartzXpr_la_SOURCES = \
-	appledri.c \
-	dri.c \
-	driWrap.c \
-	xprAppleWM.c \
-	xprCursor.c \
-	xprEvent.c \
-	xprFrame.c \
-	xprScreen.c \
-	x-hash.c \
-	x-hook.c \
-	x-list.c
-
-EXTRA_DIST = \
-	dri.h \
-	driWrap.h \
-	dristruct.h \
-	appledri.h \
-	appledristr.h \
-	x-hash.h \
-	x-hook.h \
-	x-list.h \
-	xpr.h \
-	xprEvent.h
diff --git a/hw/xquartz/xpr/xprFrame.c b/hw/xquartz/xpr/xprFrame.c
index ba84548b5..57d16d42f 100644
--- a/hw/xquartz/xpr/xprFrame.c
+++ b/hw/xquartz/xpr/xprFrame.c
@@ -45,10 +45,6 @@
 
 #include <dispatch/dispatch.h>
 
-#ifdef DEBUG_XP_LOCK_WINDOW
-#include <execinfo.h>
-#endif
-
 #define DEFINE_ATOM_HELPER(func, atom_name)                      \
     static Atom func(void) {                                       \
         static int generation;                                      \
@@ -353,15 +349,8 @@ xprStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow)
     xp_error err;
 
 #ifdef DEBUG_XP_LOCK_WINDOW
-    void* callstack[128];
-    int i, frames = backtrace(callstack, 128);
-    char** strs = backtrace_symbols(callstack, frames);
-
     ErrorF("=== LOCK %d ===\n", (int)x_cvt_vptr_to_uint(wid));
-    for (i = 0; i < frames; ++i) {
-        ErrorF("    %s\n", strs[i]);
-    }
-    free(strs);
+    xorg_backtrace();
 #endif
 
     err = xp_lock_window(x_cvt_vptr_to_uint(
@@ -371,6 +360,10 @@ xprStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow)
                    (int)x_cvt_vptr_to_uint(
                        wid), (int)err);
 
+#ifdef DEBUG_XP_LOCK_WINDOW
+    ErrorF("  bits: %p\n", *data);
+#endif
+
     *pixelData = data[0];
     *bytesPerRow = rowbytes[0];
 }
@@ -384,15 +377,8 @@ xprStopDrawing(RootlessFrameID wid, Bool flush)
     xp_error err;
 
 #ifdef DEBUG_XP_LOCK_WINDOW
-    void* callstack[128];
-    int i, frames = backtrace(callstack, 128);
-    char** strs = backtrace_symbols(callstack, frames);
-
     ErrorF("=== UNLOCK %d ===\n", (int)x_cvt_vptr_to_uint(wid));
-    for (i = 0; i < frames; ++i) {
-        ErrorF("    %s\n", strs[i]);
-    }
-    free(strs);
+    xorg_backtrace();
 #endif
 
     err = xp_unlock_window(x_cvt_vptr_to_uint(wid), flush);
diff --git a/hw/xwayland/.gitignore b/hw/xwayland/.gitignore
new file mode 100644
index 000000000..2fe460529
--- /dev/null
+++ b/hw/xwayland/.gitignore
@@ -0,0 +1,17 @@
+Xwayland
+drm-client-protocol.h
+drm-protocol.c
+linux-dmabuf-unstable-v1-client-protocol.h
+linux-dmabuf-unstable-v1-protocol.c
+pointer-constraints-unstable-v1-client-protocol.h
+pointer-constraints-unstable-v1-protocol.c
+relative-pointer-unstable-v1-client-protocol.h
+relative-pointer-unstable-v1-protocol.c
+tablet-unstable-v2-client-protocol.h
+tablet-unstable-v2-protocol.c
+viewporter-client-protocol.h
+viewporter-protocol.c
+xdg-output-unstable-v1-client-protocol.h
+xdg-output-unstable-v1-protocol.c
+xwayland-keyboard-grab-unstable-v1-client-protocol.h
+xwayland-keyboard-grab-unstable-v1-protocol.c
diff --git a/hw/xwayland/desktop/org.freedesktop.Xwayland.desktop b/hw/xwayland/desktop/org.freedesktop.Xwayland.desktop
new file mode 100644
index 000000000..d0122adf5
--- /dev/null
+++ b/hw/xwayland/desktop/org.freedesktop.Xwayland.desktop
@@ -0,0 +1,7 @@
+[Desktop Entry]
+Name=Xwayland
+Comment=A rootful instance of the Xwayland X11 server
+Terminal=false
+Type=Application
+Categories=System;
+NoDisplay=true
diff --git a/hw/xwayland/drm.xml b/hw/xwayland/drm.xml
new file mode 100644
index 000000000..5e64622df
--- /dev/null
+++ b/hw/xwayland/drm.xml
@@ -0,0 +1,185 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="drm">
+
+  <copyright>
+    Copyright © 2008-2011 Kristian Høgsberg
+    Copyright © 2010-2011 Intel Corporation
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that\n the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <!-- drm support. This object is created by the server and published
+       using the display's global event. -->
+  <interface name="wl_drm" version="2">
+    <enum name="error">
+      <entry name="authenticate_fail" value="0"/>
+      <entry name="invalid_format" value="1"/>
+      <entry name="invalid_name" value="2"/>
+    </enum>
+
+    <enum name="format">
+      <!-- The drm format codes match the #defines in drm_fourcc.h.
+           The formats actually supported by the compositor will be
+           reported by the format event. -->
+      <entry name="c8" value="0x20203843"/>
+      <entry name="rgb332" value="0x38424752"/>
+      <entry name="bgr233" value="0x38524742"/>
+      <entry name="xrgb4444" value="0x32315258"/>
+      <entry name="xbgr4444" value="0x32314258"/>
+      <entry name="rgbx4444" value="0x32315852"/>
+      <entry name="bgrx4444" value="0x32315842"/>
+      <entry name="argb4444" value="0x32315241"/>
+      <entry name="abgr4444" value="0x32314241"/>
+      <entry name="rgba4444" value="0x32314152"/>
+      <entry name="bgra4444" value="0x32314142"/>
+      <entry name="xrgb1555" value="0x35315258"/>
+      <entry name="xbgr1555" value="0x35314258"/>
+      <entry name="rgbx5551" value="0x35315852"/>
+      <entry name="bgrx5551" value="0x35315842"/>
+      <entry name="argb1555" value="0x35315241"/>
+      <entry name="abgr1555" value="0x35314241"/>
+      <entry name="rgba5551" value="0x35314152"/>
+      <entry name="bgra5551" value="0x35314142"/>
+      <entry name="rgb565" value="0x36314752"/>
+      <entry name="bgr565" value="0x36314742"/>
+      <entry name="rgb888" value="0x34324752"/>
+      <entry name="bgr888" value="0x34324742"/>
+      <entry name="xrgb8888" value="0x34325258"/>
+      <entry name="xbgr8888" value="0x34324258"/>
+      <entry name="rgbx8888" value="0x34325852"/>
+      <entry name="bgrx8888" value="0x34325842"/>
+      <entry name="argb8888" value="0x34325241"/>
+      <entry name="abgr8888" value="0x34324241"/>
+      <entry name="rgba8888" value="0x34324152"/>
+      <entry name="bgra8888" value="0x34324142"/>
+      <entry name="xrgb2101010" value="0x30335258"/>
+      <entry name="xbgr2101010" value="0x30334258"/>
+      <entry name="rgbx1010102" value="0x30335852"/>
+      <entry name="bgrx1010102" value="0x30335842"/>
+      <entry name="argb2101010" value="0x30335241"/>
+      <entry name="abgr2101010" value="0x30334241"/>
+      <entry name="rgba1010102" value="0x30334152"/>
+      <entry name="bgra1010102" value="0x30334142"/>
+      <entry name="yuyv" value="0x56595559"/>
+      <entry name="yvyu" value="0x55595659"/>
+      <entry name="uyvy" value="0x59565955"/>
+      <entry name="vyuy" value="0x59555956"/>
+      <entry name="ayuv" value="0x56555941"/>
+      <entry name="nv12" value="0x3231564e"/>
+      <entry name="nv21" value="0x3132564e"/>
+      <entry name="nv16" value="0x3631564e"/>
+      <entry name="nv61" value="0x3136564e"/>
+      <entry name="yuv410" value="0x39565559"/>
+      <entry name="yvu410" value="0x39555659"/>
+      <entry name="yuv411" value="0x31315559"/>
+      <entry name="yvu411" value="0x31315659"/>
+      <entry name="yuv420" value="0x32315559"/>
+      <entry name="yvu420" value="0x32315659"/>
+      <entry name="yuv422" value="0x36315559"/>
+      <entry name="yvu422" value="0x36315659"/>
+      <entry name="yuv444" value="0x34325559"/>
+      <entry name="yvu444" value="0x34325659"/>
+    </enum>
+
+    <!-- Call this request with the magic received from drmGetMagic().
+         It will be passed on to the drmAuthMagic() or
+         DRIAuthConnection() call.  This authentication must be
+         completed before create_buffer could be used. -->
+    <request name="authenticate">
+      <arg name="id" type="uint"/>
+    </request>
+
+    <!-- Create a wayland buffer for the named DRM buffer.  The DRM
+         surface must have a name using the flink ioctl -->
+    <request name="create_buffer">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="name" type="uint"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="stride" type="uint"/>
+      <arg name="format" type="uint"/>
+    </request>
+
+    <!-- Create a wayland buffer for the named DRM buffer.  The DRM
+         surface must have a name using the flink ioctl -->
+    <request name="create_planar_buffer">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="name" type="uint"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="format" type="uint"/>
+      <arg name="offset0" type="int"/>
+      <arg name="stride0" type="int"/>
+      <arg name="offset1" type="int"/>
+      <arg name="stride1" type="int"/>
+      <arg name="offset2" type="int"/>
+      <arg name="stride2" type="int"/>
+    </request>
+
+    <!-- Notification of the path of the drm device which is used by
+         the server.  The client should use this device for creating
+         local buffers.  Only buffers created from this device should
+         be be passed to the server using this drm object's
+         create_buffer request. -->
+    <event name="device">
+      <arg name="name" type="string"/>
+    </event>
+
+    <event name="format">
+      <arg name="format" type="uint"/>
+    </event>
+
+    <!-- Raised if the authenticate request succeeded -->
+    <event name="authenticated"/>
+
+    <enum name="capability" since="2">
+      <description summary="wl_drm capability bitmask">
+        Bitmask of capabilities.
+      </description>
+      <entry name="prime" value="1" summary="wl_drm prime available"/>
+    </enum>
+
+    <event name="capabilities">
+      <arg name="value" type="uint"/>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <!-- Create a wayland buffer for the prime fd.  Use for regular and planar
+         buffers.  Pass 0 for offset and stride for unused planes. -->
+    <request name="create_prime_buffer" since="2">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="name" type="fd"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="format" type="uint"/>
+      <arg name="offset0" type="int"/>
+      <arg name="stride0" type="int"/>
+      <arg name="offset1" type="int"/>
+      <arg name="stride1" type="int"/>
+      <arg name="offset2" type="int"/>
+      <arg name="stride2" type="int"/>
+    </request>
+
+  </interface>
+
+</protocol>
diff --git a/hw/xwayland/man/Xwayland.man b/hw/xwayland/man/Xwayland.man
new file mode 100644
index 000000000..02b333be9
--- /dev/null
+++ b/hw/xwayland/man/Xwayland.man
@@ -0,0 +1,142 @@
+'\" t
+.\"
+.\" Copyright 1984 - 1991, 1993, 1994, 1998  The Open Group
+.\"
+.\" Permission to use, copy, modify, distribute, and sell this software and its
+.\" documentation for any purpose is hereby granted without fee, provided that
+.\" the above copyright notice appear in all copies and that both that
+.\" copyright notice and this permission notice appear in supporting
+.\" documentation.
+.\"
+.\" The above copyright notice and this permission notice shall be included
+.\" in all copies or substantial portions of the Software.
+.\"
+.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+.\" IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+.\" OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+.\" ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+.\" OTHER DEALINGS IN THE SOFTWARE.
+.\"
+.\" Except as contained in this notice, the name of The Open Group shall
+.\" not be used in advertising or otherwise to promote the sale, use or
+.\" other dealings in this Software without prior written authorization
+.\" from The Open Group.
+.\" shorthand for double quote that works everywhere.
+.ds q \N'34'
+.TH XWAYLAND 1 @xorgversion@
+.SH NAME
+Xwayland \- an X server for running X clients under Wayland.
+.SH SYNOPSIS
+.B Xwayland
+[option ...]
+.SH DESCRIPTION
+.I Xwayland
+is an X server and a Wayland client. It plays the role of a proxy between
+legacy X clients which do not support the Wayland protocols and the Wayland
+server.
+.PP
+Usually, \fIXwayland\fP is spawned automatically by the Wayland server
+and runs rootless so that X clients integrate seamlessly with the rest
+of the Wayland desktop. It is however possible for a user to launch Xwayland
+non-rootless, mainly for testing purposes.
+.PP
+Like all of the X servers, \fIXwayland\fP accepts the command line options
+described in the \fIXserver\fP(@miscmansuffix@) manual page.
+The following additional arguments are supported as well.
+.TP 8
+.B \-decorate
+Add decorations to the Xwayland root window when running rootful.
+
+This option has no effect when \fIXwayland\fP is built without libdecor
+support (optional).
+
+This option is not compatible with rootless mode (\fI-rootless\fP).
+.TP 8
+.B \-eglstream
+Use EGLStream backend for NVidia GPUs. If \fIXwayland\fP was compiled with
+EGLStream support, this option will instruct \fIXwayland\fP to try that
+backend first, then fallback to the GBM backend if EGLStream is not supported
+by the Wayland server. Without this option, \fIXwayland\fP tries the GBM
+backend first, and fallback to EGLStream if GBM is not usable.
+.TP 8
+.B \-fullscreen
+Set the Xwayland window fullscreen when running rootful.
+
+This option is not compatible with rootless mode (\fI-rootless\fP).
+.TP 8
+.B \-geometry \fIWxH\fP
+Sets the geometry of the \fIXwayland\fP window to \fIWxH\fP when running rootful.
+
+This option is not compatible with rootless mode (\fI-rootless\fP).
+.TP 8
+.B \-host-grab
+Disable host keyboard shorcuts and confine the pointer when running rootful.
+
+This feature relies on the protocol for inhibiting the compositor keyboard
+shortcuts and on the protocol for pointer locking and confinement and may
+have no effect if the Wayland compositor in use does not support these
+protocols.
+
+Use the keys [CTRL]+[SHIFT] simultaneously to release the keyboard and
+pointer devices.
+
+This option is not compatible with rootless mode (\fI-rootless\fP).
+.TP 8
+.B \-initfd \fIfd\fP
+Add the given \fIfd\fP as a listen socket for initialization of X clients.
+This options is aimed at \fIWayland\fP servers which run \fIXwayland\fP
+on-demand, to be able to spawn specific X clients which need to complete
+before other regular X clients can connect to \fIXwayland\fP, like \fIxrdb\fP.
+.TP 8
+.B \-listen \fIfd\fP
+deprecated, use \fI\-listenfd\fP instead.
+.TP 8
+.B \-listenfd \fIfd\\fP
+Add given fd as a listen socket. This option is used by the \fIWayland\fP
+server to pass \fIXwayland\fP the socket where X clients connect.
+.TP 8
+.B \-noTouchPointerEmulation
+Disable touch pointer emulation. This allows the Wayland compositor to
+implement its own pointer emulation mechanism for X11 clients that don't
+support touch input.
+.TP 8
+.B \-force-xrandr-emulation
+Force additional non-native modes to be exposed when viewporter is not
+supported by the Wayland compositor.
+.TP 8
+.B \-rootless
+Run \fIXwayland\fP rootless, so that X clients integrate seamlessly with
+Wayland clients in a Wayland desktop. That requires the Wayland server
+to be an X window manager as well.
+.TP 8
+.BI \-shm
+Force the shared memory backend instead of glamor (if available) for passing
+buffers to the Wayland server.
+.TP 8
+.BR \-verbose " [\fIn\fP]"
+Sets the verbosity level for information printed on stderr.  If the
+.I n
+value isn't supplied, each occurrence of this option increments the
+verbosity level.  When the
+.I n
+value is supplied, the verbosity level is set to that value.  The default
+verbosity level is 0.
+.TP 8
+.BI \-version
+Show the server version and exit.
+.TP 8
+.B \-wm \fIfd\fP
+This option is used by the \fIWayland\fP server to pass \fIXwayland\fP
+the socket where the X window manager client connects, when \fIXwayland\fP
+is running with \fI-rootless\fP.
+.SH ENVIRONMENT
+.TP 8
+.B WAYLAND_DISPLAY
+the name of the display of the Wayland server.
+.TP 8
+.B XWAYLAND_NO_GLAMOR
+disable glamor and DRI3 support in \fIXwayland\fP, for testing purposes.
+.SH "SEE ALSO"
+General information: \fIX\fP(@miscmansuffix@)
diff --git a/hw/xwayland/meson.build b/hw/xwayland/meson.build
new file mode 100644
index 000000000..6dddfd63e
--- /dev/null
+++ b/hw/xwayland/meson.build
@@ -0,0 +1,188 @@
+srcs = [
+    'xwayland.c',
+    'xwayland-input.c',
+    'xwayland-input.h',
+    'xwayland-cursor.c',
+    'xwayland-cursor.h',
+    'xwayland-drm-lease.h',
+    'xwayland-drm-lease.c',
+    'xwayland-glamor.h',
+    'xwayland-glx.h',
+    'xwayland-pixmap.c',
+    'xwayland-pixmap.h',
+    'xwayland-present.h',
+    'xwayland-screen.c',
+    'xwayland-screen.h',
+    'xwayland-shm.c',
+    'xwayland-shm.h',
+    'xwayland-types.h',
+    'xwayland-output.c',
+    'xwayland-output.h',
+    'xwayland-cvt.c',
+    'xwayland-cvt.h',
+    'xwayland-vidmode.c',
+    'xwayland-vidmode.h',
+    'xwayland-window.c',
+    'xwayland-window.h',
+    'xwayland-window-buffers.c',
+    'xwayland-window-buffers.h',
+    '../../mi/miinitext.c',
+    '../../mi/miinitext.h',
+]
+
+scanner_dep = dependency('wayland-scanner', native: true)
+scanner = find_program(scanner_dep.get_pkgconfig_variable('wayland_scanner'))
+
+protocols_dep = dependency('wayland-protocols', version: wayland_protocols_req)
+protodir = protocols_dep.get_pkgconfig_variable('pkgdatadir')
+
+pointer_xml = join_paths(protodir, 'unstable', 'pointer-constraints', 'pointer-constraints-unstable-v1.xml')
+relative_xml = join_paths(protodir, 'unstable', 'relative-pointer', 'relative-pointer-unstable-v1.xml')
+gestures_xml = join_paths(protodir, 'unstable', 'pointer-gestures', 'pointer-gestures-unstable-v1.xml')
+tablet_xml = join_paths(protodir, 'unstable', 'tablet', 'tablet-unstable-v2.xml')
+kbgrab_xml = join_paths(protodir, 'unstable', 'xwayland-keyboard-grab', 'xwayland-keyboard-grab-unstable-v1.xml')
+xdg_output_xml = join_paths(protodir, 'unstable', 'xdg-output', 'xdg-output-unstable-v1.xml')
+dmabuf_xml = join_paths(protodir, 'unstable', 'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml')
+viewporter_xml = join_paths(protodir, 'stable', 'viewporter', 'viewporter.xml')
+xdg_shell_xml = join_paths(protodir, 'stable', 'xdg-shell', 'xdg-shell.xml')
+drm_lease_xml = join_paths(protodir, 'staging', 'drm-lease', 'drm-lease-v1.xml')
+shortcuts_inhibit_xml = join_paths(protodir, 'unstable', 'keyboard-shortcuts-inhibit', 'keyboard-shortcuts-inhibit-unstable-v1.xml')
+xwayland_shell_xml = join_paths(protodir, 'staging', 'xwayland-shell', 'xwayland-shell-v1.xml')
+
+client_header = generator(scanner,
+    output : '@BASENAME@-client-protocol.h',
+    arguments : ['client-header', '@INPUT@', '@OUTPUT@']
+)
+
+if scanner_dep.version().version_compare('>= 1.14.91')
+    scanner_argument = 'private-code'
+else
+    scanner_argument = 'code'
+endif
+
+code = generator(scanner,
+    output : '@BASENAME@-protocol.c',
+    arguments : [scanner_argument, '@INPUT@', '@OUTPUT@']
+)
+srcs += client_header.process(relative_xml)
+srcs += client_header.process(pointer_xml)
+srcs += client_header.process(gestures_xml)
+srcs += client_header.process(tablet_xml)
+srcs += client_header.process(kbgrab_xml)
+srcs += client_header.process(xdg_output_xml)
+srcs += client_header.process(dmabuf_xml)
+srcs += client_header.process(viewporter_xml)
+srcs += client_header.process(xdg_shell_xml)
+srcs += client_header.process(drm_lease_xml)
+srcs += client_header.process(shortcuts_inhibit_xml)
+srcs += client_header.process(xwayland_shell_xml)
+srcs += code.process(relative_xml)
+srcs += code.process(pointer_xml)
+srcs += code.process(gestures_xml)
+srcs += code.process(tablet_xml)
+srcs += code.process(kbgrab_xml)
+srcs += code.process(xdg_output_xml)
+srcs += code.process(dmabuf_xml)
+srcs += code.process(viewporter_xml)
+srcs += code.process(xdg_shell_xml)
+srcs += code.process(drm_lease_xml)
+srcs += code.process(shortcuts_inhibit_xml)
+srcs += code.process(xwayland_shell_xml)
+
+xwayland_glamor = []
+eglstream_srcs = []
+if build_glamor
+    srcs += 'xwayland-glamor.c'
+    if build_glx
+        srcs += 'xwayland-glx.c'
+    endif
+    if gbm_dep.found()
+        srcs += 'xwayland-glamor-gbm.c'
+    endif
+    if build_eglstream
+        eglstream_protodir = eglstream_dep.get_pkgconfig_variable('pkgdatadir')
+        eglstream_xml = join_paths(eglstream_protodir, 'wayland-eglstream.xml')
+        eglstream_controller_xml = join_paths(eglstream_protodir, 'wayland-eglstream-controller.xml')
+
+        srcs += client_header.process(eglstream_xml)
+        srcs += client_header.process(eglstream_controller_xml)
+        srcs += code.process(eglstream_xml)
+        srcs += code.process(eglstream_controller_xml)
+
+        srcs += 'xwayland-glamor-eglstream.c'
+    endif
+    srcs += 'xwayland-present.c'
+    if build_xv
+        srcs += 'xwayland-glamor-xv.c'
+    endif
+
+    srcs += client_header.process('drm.xml')
+    srcs += code.process('drm.xml')
+    xwayland_dep += gbm_dep
+    xwayland_glamor += glamor
+endif
+
+wayland_inc = [ inc, ]
+if build_glx
+    wayland_inc += glx_inc
+endif
+
+if libdrm_dep.found()
+    xwayland_dep += libdrm_dep
+endif
+
+if have_libdecor
+    xwayland_dep += libdecor_dep
+endif
+
+xwayland_server = executable(
+    'Xwayland',
+    srcs,
+    include_directories: wayland_inc,
+    dependencies: [
+        common_dep,
+        xwayland_dep,
+        xwaylandproto_dep,
+    ],
+    link_with: [
+        libxserver_main,
+        xwayland_glamor,
+        libxserver_fb,
+        libxserver,
+        libxserver_xext_vidmode,
+        libxserver_xkb_stubs,
+        libxserver_xi_stubs,
+        libxserver_glx,
+        libglxvnd,
+    ],
+    install: true,
+    install_dir: xwayland_path
+)
+
+xwayland_data = configuration_data()
+xwayland_data.set('prefix', get_option('prefix'))
+xwayland_data.set('exec_prefix', '${prefix}')
+xwayland_data.set('PACKAGE_VERSION', meson.project_version())
+xwayland_data.set('xwayland_path', xwayland_path)
+xwayland_data.set('have_glamor', build_glamor ? 'true' : 'false')
+xwayland_data.set('have_eglstream', build_eglstream ? 'true' : 'false')
+xwayland_data.set('have_libdecor', have_libdecor ? 'true' : 'false')
+configure_file(
+    input: 'xwayland.pc.in',
+    output: 'xwayland.pc',
+    configuration: xwayland_data,
+    install_dir: join_paths(get_option('prefix'),
+                            get_option('libdir'),
+                            'pkgconfig'),
+)
+
+xwayland_manpage = configure_file(
+    input: 'man/Xwayland.man',
+    output: 'Xwayland.1',
+    configuration: manpage_config,
+)
+install_man(xwayland_manpage)
+
+datadir = join_paths(get_option('prefix'), get_option('datadir'))
+desktopdir = join_paths(datadir, 'applications')
+install_data('desktop/org.freedesktop.Xwayland.desktop', install_dir : desktopdir)
diff --git a/hw/xwayland/xwayland-cursor.c b/hw/xwayland/xwayland-cursor.c
new file mode 100644
index 000000000..e3c1aaa50
--- /dev/null
+++ b/hw/xwayland/xwayland-cursor.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2011 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include "scrnintstr.h"
+#include "servermd.h"
+#include "cursorstr.h"
+#include "inputstr.h"
+#include "mipointer.h"
+
+#include "xwayland-cursor.h"
+#include "xwayland-input.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-screen.h"
+#include "xwayland-shm.h"
+#include "xwayland-types.h"
+
+#include "tablet-unstable-v2-client-protocol.h"
+
+#define DELAYED_X_CURSOR_TIMEOUT 5 /* ms */
+
+static DevPrivateKeyRec xwl_cursor_private_key;
+
+static void
+expand_source_and_mask(CursorPtr cursor, CARD32 *data)
+{
+    CARD32 *p, d, fg, bg;
+    CursorBitsPtr bits = cursor->bits;
+    int x, y, stride, i, bit;
+
+    p = data;
+    fg = ((cursor->foreRed & 0xff00) << 8) |
+          (cursor->foreGreen & 0xff00) |
+          (cursor->foreBlue >> 8);
+    bg = ((cursor->backRed & 0xff00) << 8) |
+          (cursor->backGreen & 0xff00) |
+          (cursor->backBlue >> 8);
+    stride = BitmapBytePad(bits->width);
+    for (y = 0; y < bits->height; y++)
+        for (x = 0; x < bits->width; x++) {
+            i = y * stride + x / 8;
+            bit = 1 << (x & 7);
+            if (bits->source[i] & bit)
+                d = fg;
+            else
+                d = bg;
+            if (bits->mask[i] & bit)
+                d |= 0xff000000;
+            else
+                d = 0x00000000;
+
+            *p++ = d;
+        }
+}
+
+static Bool
+xwl_realize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
+{
+    PixmapPtr pixmap;
+
+    pixmap = xwl_shm_create_pixmap(screen, cursor->bits->width,
+                                   cursor->bits->height, 32,
+                                   CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    dixSetPrivate(&cursor->devPrivates, &xwl_cursor_private_key, pixmap);
+
+    return TRUE;
+}
+
+static Bool
+xwl_unrealize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
+{
+    PixmapPtr pixmap;
+    struct xwl_screen *xwl_screen;
+    struct xwl_seat *xwl_seat;
+
+    pixmap = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    if (!pixmap)
+        return TRUE;
+
+    dixSetPrivate(&cursor->devPrivates, &xwl_cursor_private_key, NULL);
+
+    /* When called from FreeCursor(), device is always NULL */
+    xwl_screen = xwl_screen_get(screen);
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (cursor == xwl_seat->x_cursor)
+            xwl_seat->x_cursor = NULL;
+    }
+
+    return xwl_shm_destroy_pixmap(pixmap);
+}
+
+static void
+frame_callback(void *data,
+               struct wl_callback *callback,
+               uint32_t time)
+{
+    struct xwl_cursor *xwl_cursor = data;
+
+    xwl_cursor_clear_frame_cb(xwl_cursor);
+    if (xwl_cursor->needs_update) {
+        xwl_cursor->needs_update = FALSE;
+        xwl_cursor->update_proc(xwl_cursor);
+    }
+}
+
+static const struct wl_callback_listener frame_listener = {
+    frame_callback
+};
+
+static void
+xwl_cursor_buffer_release_callback(void *data)
+{
+    /* drop the reference we took in set_cursor */
+    xwl_shm_destroy_pixmap(data);
+}
+
+static void
+xwl_cursor_copy_bits_to_pixmap(CursorPtr cursor, PixmapPtr pixmap)
+{
+    int stride;
+
+    stride = cursor->bits->width * 4;
+    if (cursor->bits->argb)
+        memcpy(pixmap->devPrivate.ptr,
+               cursor->bits->argb, cursor->bits->height * stride);
+    else
+        expand_source_and_mask(cursor, pixmap->devPrivate.ptr);
+}
+
+static void
+xwl_cursor_attach_pixmap(struct xwl_seat *xwl_seat,
+                         struct xwl_cursor *xwl_cursor, PixmapPtr pixmap)
+{
+    struct wl_buffer *buffer;
+
+    buffer = xwl_shm_pixmap_get_wl_buffer(pixmap);
+    if (!buffer) {
+        ErrorF("cursor: Error getting buffer\n");
+        return;
+    }
+
+    wl_surface_attach(xwl_cursor->surface, buffer, 0, 0);
+    xwl_surface_damage(xwl_seat->xwl_screen, xwl_cursor->surface, 0, 0,
+                       xwl_seat->x_cursor->bits->width,
+                       xwl_seat->x_cursor->bits->height);
+
+    xwl_cursor->frame_cb = wl_surface_frame(xwl_cursor->surface);
+    wl_callback_add_listener(xwl_cursor->frame_cb, &frame_listener, xwl_cursor);
+
+    /* Hold a reference on the pixmap until it's released by the compositor */
+    pixmap->refcnt++;
+    xwl_pixmap_set_buffer_release_cb(pixmap,
+                                     xwl_cursor_buffer_release_callback,
+                                     pixmap);
+
+    wl_surface_commit(xwl_cursor->surface);
+}
+
+Bool
+xwl_cursor_clear_frame_cb(struct xwl_cursor *xwl_cursor)
+{
+    if (xwl_cursor->frame_cb) {
+        wl_callback_destroy(xwl_cursor->frame_cb);
+        xwl_cursor->frame_cb = NULL;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+void
+xwl_seat_set_cursor(struct xwl_seat *xwl_seat)
+{
+    struct xwl_cursor *xwl_cursor = &xwl_seat->cursor;
+    PixmapPtr pixmap;
+    CursorPtr cursor;
+
+    if (!xwl_seat->wl_pointer)
+        return;
+
+    if (!xwl_seat->x_cursor) {
+        wl_pointer_set_cursor(xwl_seat->wl_pointer,
+                              xwl_seat->pointer_enter_serial, NULL, 0, 0);
+        xwl_cursor_clear_frame_cb(xwl_cursor);
+        xwl_cursor->needs_update = FALSE;
+        return;
+    }
+
+    if (xwl_cursor->frame_cb) {
+        xwl_cursor->needs_update = TRUE;
+        return;
+    }
+
+    cursor = xwl_seat->x_cursor;
+    pixmap = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    if (!pixmap)
+        return;
+
+    xwl_cursor_copy_bits_to_pixmap(cursor, pixmap);
+
+    wl_pointer_set_cursor(xwl_seat->wl_pointer,
+                          xwl_seat->pointer_enter_serial,
+                          xwl_cursor->surface,
+                          xwl_seat->x_cursor->bits->xhot,
+                          xwl_seat->x_cursor->bits->yhot);
+
+    xwl_cursor_attach_pixmap(xwl_seat, xwl_cursor, pixmap);
+}
+
+void
+xwl_tablet_tool_set_cursor(struct xwl_tablet_tool *xwl_tablet_tool)
+{
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    struct xwl_cursor *xwl_cursor = &xwl_tablet_tool->cursor;
+    PixmapPtr pixmap;
+    CursorPtr cursor;
+
+    if (!xwl_seat->x_cursor) {
+        zwp_tablet_tool_v2_set_cursor(xwl_tablet_tool->tool,
+                                      xwl_tablet_tool->proximity_in_serial,
+                                      NULL, 0, 0);
+        xwl_cursor_clear_frame_cb(xwl_cursor);
+        xwl_cursor->needs_update = FALSE;
+        return;
+    }
+
+    if (xwl_cursor->frame_cb) {
+        xwl_cursor->needs_update = TRUE;
+        return;
+    }
+
+    cursor = xwl_seat->x_cursor;
+    pixmap = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    if (!pixmap)
+        return;
+
+    xwl_cursor_copy_bits_to_pixmap(cursor, pixmap);
+
+    zwp_tablet_tool_v2_set_cursor(xwl_tablet_tool->tool,
+                                  xwl_tablet_tool->proximity_in_serial,
+                                  xwl_cursor->surface,
+                                  xwl_seat->x_cursor->bits->xhot,
+                                  xwl_seat->x_cursor->bits->yhot);
+
+    xwl_cursor_attach_pixmap(xwl_seat, xwl_cursor, pixmap);
+}
+
+void
+xwl_cursor_release(struct xwl_cursor *xwl_cursor)
+{
+    wl_surface_destroy(xwl_cursor->surface);
+    xwl_cursor_clear_frame_cb(xwl_cursor);
+}
+
+static void
+xwl_seat_update_all_cursors(struct xwl_seat *xwl_seat)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool;
+
+    xwl_seat_set_cursor(xwl_seat);
+
+    xorg_list_for_each_entry(xwl_tablet_tool, &xwl_seat->tablet_tools, link) {
+        if (xwl_tablet_tool->proximity_in_serial != 0)
+            xwl_tablet_tool_set_cursor(xwl_tablet_tool);
+    }
+
+    /* Clear delayed cursor if any */
+    xwl_seat->pending_x_cursor = NULL;
+}
+
+static void
+xwl_seat_update_cursor_visibility(struct xwl_seat *xwl_seat)
+{
+    xwl_seat->x_cursor = xwl_seat->pending_x_cursor;
+    xwl_seat_cursor_visibility_changed(xwl_seat);
+    xwl_seat_update_all_cursors(xwl_seat);
+}
+
+static void
+xwl_set_cursor_free_timer(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->x_cursor_timer) {
+        TimerFree(xwl_seat->x_cursor_timer);
+        xwl_seat->x_cursor_timer = NULL;
+    }
+}
+
+static CARD32
+xwl_set_cursor_timer_callback(OsTimerPtr timer, CARD32 time, void *arg)
+{
+    struct xwl_seat *xwl_seat = arg;
+
+    xwl_set_cursor_free_timer(xwl_seat);
+    xwl_seat_update_cursor_visibility(xwl_seat);
+
+    /* Don't re-arm the timer */
+    return 0;
+}
+
+static void
+xwl_set_cursor_delayed(struct xwl_seat *xwl_seat, CursorPtr cursor)
+{
+    xwl_seat->pending_x_cursor = cursor;
+
+    if (xwl_seat->x_cursor_timer == NULL) {
+        xwl_seat->x_cursor_timer = TimerSet(xwl_seat->x_cursor_timer,
+                                            0, DELAYED_X_CURSOR_TIMEOUT,
+                                            &xwl_set_cursor_timer_callback,
+                                            xwl_seat);
+    }
+}
+
+static void
+xwl_set_cursor(DeviceIntPtr device,
+               ScreenPtr screen, CursorPtr cursor, int x, int y)
+{
+    struct xwl_seat *xwl_seat;
+    Bool cursor_visibility_changed;
+
+    xwl_seat = device->public.devicePrivate;
+    if (xwl_seat == NULL)
+        return;
+
+    cursor_visibility_changed = !!xwl_seat->x_cursor ^ !!cursor;
+
+    if (!cursor_visibility_changed) {
+        /* Cursor remains shown or hidden, apply the change immediately */
+        xwl_set_cursor_free_timer(xwl_seat);
+        xwl_seat->x_cursor = cursor;
+        xwl_seat_update_all_cursors(xwl_seat);
+        return;
+    }
+
+    xwl_seat->pending_x_cursor = cursor;
+    if (cursor) {
+        /* Cursor is being shown, delay the change until moved or timed out */
+        xwl_set_cursor_delayed(xwl_seat, cursor);
+    } else {
+        /* Cursor is being hidden, apply the change immediately */
+        xwl_seat_update_cursor_visibility(xwl_seat);
+    }
+}
+
+static void
+xwl_move_cursor(DeviceIntPtr device, ScreenPtr screen, int x, int y)
+{
+    struct xwl_seat *xwl_seat;
+
+    xwl_seat = device->public.devicePrivate;
+    if (xwl_seat == NULL)
+        return;
+
+    xwl_set_cursor_free_timer(xwl_seat);
+
+    if (xwl_seat->pending_x_cursor)
+        xwl_seat_update_cursor_visibility(xwl_seat);
+}
+
+static Bool
+xwl_device_cursor_initialize(DeviceIntPtr device, ScreenPtr screen)
+{
+    return TRUE;
+}
+
+static void
+xwl_device_cursor_cleanup(DeviceIntPtr device, ScreenPtr screen)
+{
+    struct xwl_seat *xwl_seat;
+
+    xwl_seat = device->public.devicePrivate;
+    if (xwl_seat)
+        xwl_set_cursor_free_timer(xwl_seat);
+}
+
+static miPointerSpriteFuncRec xwl_pointer_sprite_funcs = {
+    xwl_realize_cursor,
+    xwl_unrealize_cursor,
+    xwl_set_cursor,
+    xwl_move_cursor,
+    xwl_device_cursor_initialize,
+    xwl_device_cursor_cleanup
+};
+
+static Bool
+xwl_cursor_off_screen(ScreenPtr *ppScreen, int *x, int *y)
+{
+    return FALSE;
+}
+
+static void
+xwl_cross_screen(ScreenPtr pScreen, Bool entering)
+{
+}
+
+static void
+xwl_pointer_warp_cursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
+{
+    miPointerWarpCursor(pDev, pScreen, x, y);
+}
+
+static miPointerScreenFuncRec xwl_pointer_screen_funcs = {
+    xwl_cursor_off_screen,
+    xwl_cross_screen,
+    xwl_pointer_warp_cursor
+};
+
+Bool
+xwl_screen_init_cursor(struct xwl_screen *xwl_screen)
+{
+    if (!dixRegisterPrivateKey(&xwl_cursor_private_key, PRIVATE_CURSOR_BITS, 0))
+        return FALSE;
+
+    return miPointerInitialize(xwl_screen->screen,
+                               &xwl_pointer_sprite_funcs,
+                               &xwl_pointer_screen_funcs, TRUE);
+}
diff --git a/hw/xwayland/xwayland-cursor.h b/hw/xwayland/xwayland-cursor.h
new file mode 100644
index 000000000..76b5b49b6
--- /dev/null
+++ b/hw/xwayland/xwayland-cursor.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2011 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_CURSOR_H
+#define XWAYLAND_CURSOR_H
+
+#include <xwayland-config.h>
+#include <xwayland-types.h>
+#include <xwayland-input.h>
+
+Bool xwl_cursor_clear_frame_cb(struct xwl_cursor *xwl_cursor);
+void xwl_cursor_release(struct xwl_cursor *xwl_cursor);
+void xwl_tablet_tool_set_cursor(struct xwl_tablet_tool *tool);
+void xwl_seat_set_cursor(struct xwl_seat *xwl_seat);
+Bool xwl_screen_init_cursor(struct xwl_screen *xwl_screen);
+
+#endif /* XWAYLAND_CURSOR_H */
diff --git a/hw/xwayland/xwayland-cvt.c b/hw/xwayland/xwayland-cvt.c
new file mode 100644
index 000000000..ba8cbc9d1
--- /dev/null
+++ b/hw/xwayland/xwayland-cvt.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2005-2006 Luc Verhaegen.
+ * Copyright © 2021 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <string.h>
+#include <randrstr.h>
+#include <libxcvt/libxcvt.h>
+
+#include "xwayland-cvt.h"
+
+RRModePtr
+xwayland_cvt(int hdisplay, int vdisplay, float vrefresh, Bool reduced,
+             Bool interlaced)
+{
+    struct libxcvt_mode_info *libxcvt_mode_info;
+    char name[128];
+    xRRModeInfo modeinfo;
+
+    libxcvt_mode_info =
+        libxcvt_gen_mode_info(hdisplay, vdisplay, vrefresh, reduced, interlaced);
+
+    memset(&modeinfo, 0, sizeof modeinfo);
+    modeinfo.width      = libxcvt_mode_info->hdisplay;
+    modeinfo.height     = libxcvt_mode_info->vdisplay;
+    modeinfo.dotClock   = libxcvt_mode_info->dot_clock * 1000.0;
+    modeinfo.hSyncStart = libxcvt_mode_info->hsync_start;
+    modeinfo.hSyncEnd   = libxcvt_mode_info->hsync_end;
+    modeinfo.hTotal     = libxcvt_mode_info->htotal;
+    modeinfo.vSyncStart = libxcvt_mode_info->vsync_start;
+    modeinfo.vSyncEnd   = libxcvt_mode_info->vsync_end;
+    modeinfo.vTotal     = libxcvt_mode_info->vtotal;
+    modeinfo.modeFlags  = libxcvt_mode_info->mode_flags;
+
+    free(libxcvt_mode_info);
+
+    snprintf(name, sizeof name, "%dx%d",
+             modeinfo.width, modeinfo.height);
+    modeinfo.nameLength = strlen(name);
+
+    return RRModeGet(&modeinfo, name);
+}
diff --git a/hw/xwayland/xwayland-cvt.h b/hw/xwayland/xwayland-cvt.h
new file mode 100644
index 000000000..64ff41e35
--- /dev/null
+++ b/hw/xwayland/xwayland-cvt.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2005-2006 Luc Verhaegen.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef XWAYLAND_CVT_H
+#define XWAYLAND_CVT_H
+
+#include <xwayland-config.h>
+
+#include <dix.h>
+#include <randrstr.h>
+
+RRModePtr xwayland_cvt(int HDisplay, int VDisplay,
+                       float VRefresh, Bool Reduced, Bool Interlaced);
+
+#endif /* XWAYLAND_CVT_H */
diff --git a/hw/xwayland/xwayland-drm-lease.c b/hw/xwayland/xwayland-drm-lease.c
new file mode 100644
index 000000000..d623b4b79
--- /dev/null
+++ b/hw/xwayland/xwayland-drm-lease.c
@@ -0,0 +1,442 @@
+/*
+ * Copyright © 2020 Drew Devault
+ * Copyright © 2021 Xaver Hugl
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#ifdef WITH_LIBDRM
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+#endif
+
+#include "xwayland-drm-lease.h"
+#include "xwayland-screen.h"
+#include "xwayland-output.h"
+
+static void
+drm_lease_handle_lease_fd(void *data,
+                          struct wp_drm_lease_v1 *wp_drm_lease_v1,
+                          int32_t lease_fd)
+{
+    struct xwl_drm_lease *lease = (struct xwl_drm_lease *)data;
+
+    lease->fd = lease_fd;
+    AttendClient(lease->client);
+}
+
+static void
+drm_lease_handle_finished(void *data,
+                          struct wp_drm_lease_v1 *wp_drm_lease_v1)
+{
+    struct xwl_drm_lease *lease = (struct xwl_drm_lease *)data;
+    struct xwl_output *output;
+    int i;
+
+    if (lease->fd >= 0) {
+        RRTerminateLease(lease->rrLease);
+    } else {
+        AttendClient(lease->client);
+        for (i = 0; i < lease->rrLease->numOutputs; ++i) {
+            output = lease->rrLease->outputs[i]->devPrivate;
+            output->lease = NULL;
+        }
+    }
+}
+
+static struct wp_drm_lease_v1_listener drm_lease_listener = {
+    .lease_fd = drm_lease_handle_lease_fd,
+    .finished = drm_lease_handle_finished,
+};
+
+void
+xwl_randr_get_lease(ClientPtr client, ScreenPtr screen, RRLeasePtr *rrLease, int *fd)
+{
+    struct xwl_screen *xwl_screen;
+    struct xwl_drm_lease *lease;
+    xwl_screen = xwl_screen_get(screen);
+
+    xorg_list_for_each_entry(lease, &xwl_screen->drm_leases, link) {
+        if (lease->client == client) {
+            *rrLease = lease->rrLease;
+            *fd = lease->fd;
+            if (lease->fd < 0)
+                xorg_list_del(&lease->link);
+            return;
+        }
+    }
+    *rrLease = NULL;
+    *fd = -1;
+}
+
+int
+xwl_randr_request_lease(ClientPtr client, ScreenPtr screen, RRLeasePtr rrLease)
+{
+    struct xwl_screen *xwl_screen;
+    struct wp_drm_lease_request_v1 *req;
+    struct xwl_drm_lease *lease_private;
+    struct xwl_drm_lease_device *lease_device = NULL;
+    struct xwl_drm_lease_device *device_data;
+    struct xwl_output *output;
+    int i;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    if (xorg_list_is_empty(&xwl_screen->drm_lease_devices)) {
+        ErrorF("Attempted to create DRM lease without wp_drm_lease_device_v1\n");
+        return BadMatch;
+    }
+
+    xorg_list_for_each_entry(device_data, &xwl_screen->drm_lease_devices, link) {
+        Bool connectors_of_device = FALSE;
+        for (i = 0; i < rrLease->numOutputs; ++i) {
+            output = rrLease->outputs[i]->devPrivate;
+            if (output->lease_device == device_data) {
+                connectors_of_device = TRUE;
+                break;
+            }
+        }
+        if (connectors_of_device) {
+            if (lease_device != NULL) {
+                ErrorF("Attempted to create DRM lease from multiple devices\n");
+                return BadValue;
+            }
+            lease_device = device_data;
+        }
+    }
+
+    for (i = 0; i < rrLease->numOutputs; ++i) {
+        output = rrLease->outputs[i]->devPrivate;
+        if (!output || !output->lease_connector || output->lease) {
+            return BadValue;
+        }
+    }
+
+    req = wp_drm_lease_device_v1_create_lease_request(
+            lease_device->drm_lease_device);
+    lease_private = calloc(1, sizeof(struct xwl_drm_lease));
+    for (i = 0; i < rrLease->numOutputs; ++i) {
+        output = rrLease->outputs[i]->devPrivate;
+        output->lease = lease_private;
+        wp_drm_lease_request_v1_request_connector(req, output->lease_connector);
+    }
+    lease_private->fd = -1;
+    lease_private->lease = wp_drm_lease_request_v1_submit(req);
+    lease_private->rrLease = rrLease;
+    lease_private->client = client;
+    rrLease->devPrivate = lease_private;
+
+    wp_drm_lease_v1_add_listener(lease_private->lease,
+                                  &drm_lease_listener, lease_private);
+    xorg_list_add(&lease_private->link, &xwl_screen->drm_leases);
+
+    ResetCurrentRequest(client);
+    client->sequence--;
+    IgnoreClient(client);
+
+    return Success;
+}
+
+void
+xwl_randr_terminate_lease(ScreenPtr screen, RRLeasePtr lease)
+{
+    struct xwl_drm_lease *lease_private = lease->devPrivate;
+
+    if (lease_private) {
+        xorg_list_del(&lease_private->link);
+        if (lease_private->fd >= 0)
+            close(lease_private->fd);
+        wp_drm_lease_v1_destroy(lease_private->lease);
+        free(lease_private);
+        lease->devPrivate = NULL;
+    }
+
+    RRLeaseTerminated(lease);
+}
+
+static void
+lease_connector_handle_name(void *data,
+                            struct wp_drm_lease_connector_v1 *wp_drm_lease_connector_v1,
+                            const char *name)
+{
+    /* This space is deliberately left blank */
+}
+
+static void
+lease_connector_handle_description(void *data,
+                                   struct wp_drm_lease_connector_v1 *wp_drm_lease_connector_v1,
+                                   const char *description)
+{
+    /* This space is deliberately left blank */
+}
+
+static RRModePtr *
+xwl_get_rrmodes_from_connector_id(int drm, int32_t connector_id, int *nmode, int *npref)
+{
+#ifdef WITH_LIBDRM
+    drmModeConnectorPtr conn;
+    drmModeModeInfoPtr kmode;
+    RRModePtr *rrmodes;
+    int pref, i;
+
+    *nmode = *npref = 0;
+
+    conn = drmModeGetConnectorCurrent(drm, connector_id);
+    if (!conn) {
+        ErrorF("drmModeGetConnector for connector %d failed\n", connector_id);
+        return NULL;
+    }
+    rrmodes = xallocarray(conn->count_modes, sizeof(RRModePtr));
+    if (!rrmodes) {
+        ErrorF("Failed to allocate connector modes\n");
+        drmModeFreeConnector(conn);
+        return NULL;
+    }
+
+    /* This spaghetti brought to you courtesey of xf86RandrR12.c
+     * It adds preferred modes first, then non-preferred modes */
+    for (pref = 1; pref >= 0; pref--) {
+        for (i = 0; i < conn->count_modes; ++i) {
+            kmode = &conn->modes[i];
+            if ((pref != 0) == ((kmode->type & DRM_MODE_TYPE_PREFERRED) != 0)) {
+                xRRModeInfo modeInfo;
+                RRModePtr rrmode;
+
+                modeInfo.nameLength = strlen(kmode->name);
+
+                modeInfo.width = kmode->hdisplay;
+                modeInfo.dotClock = kmode->clock * 1000;
+                modeInfo.hSyncStart = kmode->hsync_start;
+                modeInfo.hSyncEnd = kmode->hsync_end;
+                modeInfo.hTotal = kmode->htotal;
+                modeInfo.hSkew = kmode->hskew;
+
+                modeInfo.height = kmode->vdisplay;
+                modeInfo.vSyncStart = kmode->vsync_start;
+                modeInfo.vSyncEnd = kmode->vsync_end;
+                modeInfo.vTotal = kmode->vtotal;
+                modeInfo.modeFlags = kmode->flags;
+
+                rrmode = RRModeGet(&modeInfo, kmode->name);
+                if (rrmode) {
+                    rrmodes[*nmode] = rrmode;
+                    *nmode = *nmode + 1;
+                    *npref = *npref + pref;
+                }
+            }
+        }
+    }
+    /* workaround: there could be no preferred mode that got added */
+    if (*nmode > 0 && *npref == 0)
+        *npref = 1;
+
+    drmModeFreeConnector(conn);
+    return rrmodes;
+#else
+    *nmode = *npref = 0;
+    return NULL;
+#endif
+}
+
+static void
+lease_connector_handle_connector_id(void *data,
+                                    struct wp_drm_lease_connector_v1 *wp_drm_lease_connector_v1,
+                                    uint32_t connector_id)
+{
+    struct xwl_output *output;
+    Atom name;
+    INT32 value;
+    int err;
+    int nmode, npref;
+    RRModePtr *rrmodes;
+
+    value = connector_id;
+    output = (struct xwl_output *)data;
+    name = MakeAtom("CONNECTOR_ID", 12, TRUE);
+
+    if (name != BAD_RESOURCE) {
+        err = RRConfigureOutputProperty(output->randr_output, name,
+                                        FALSE, FALSE, TRUE,
+                                        1, &value);
+        if (err != 0) {
+            ErrorF("RRConfigureOutputProperty error, %d\n", err);
+            return;
+        }
+        err = RRChangeOutputProperty(output->randr_output, name,
+                                     XA_INTEGER, 32, PropModeReplace, 1,
+                                     &value, FALSE, FALSE);
+        if (err != 0) {
+            ErrorF("RRChangeOutputProperty error, %d\n", err);
+            return;
+        }
+    }
+    rrmodes = xwl_get_rrmodes_from_connector_id(output->lease_device->drm_read_only_fd,
+                                                connector_id, &nmode, &npref);
+
+    if (rrmodes != NULL)
+        RROutputSetModes(output->randr_output, rrmodes, nmode, npref);
+
+    free(rrmodes);
+}
+
+static void
+lease_connector_handle_done(void *data,
+                            struct wp_drm_lease_connector_v1 *wp_drm_lease_connector_v1)
+{
+    /* This space is deliberately left blank */
+}
+
+static void
+lease_connector_handle_withdrawn(void *data,
+                                 struct wp_drm_lease_connector_v1 *wp_drm_lease_connector_v1)
+{
+    xwl_output_remove(data);
+}
+
+static const struct wp_drm_lease_connector_v1_listener lease_connector_listener = {
+    .name = lease_connector_handle_name,
+    .description = lease_connector_handle_description,
+    .connector_id = lease_connector_handle_connector_id,
+    .withdrawn = lease_connector_handle_withdrawn,
+    .done = lease_connector_handle_done,
+};
+
+static void
+drm_lease_device_handle_drm_fd(void *data,
+                               struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1,
+                               int fd)
+{
+    ((struct xwl_drm_lease_device *)data)->drm_read_only_fd = fd;
+}
+
+static void
+drm_lease_device_handle_connector(void *data,
+                                  struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1,
+                                  struct wp_drm_lease_connector_v1 *connector)
+{
+    struct xwl_drm_lease_device *lease_device = data;
+    struct xwl_screen *xwl_screen = lease_device->xwl_screen;
+    struct xwl_output *xwl_output;
+    char name[256];
+
+    xwl_output = calloc(1, sizeof *xwl_output);
+    if (xwl_output == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    snprintf(name, sizeof name, "XWAYLAND%d",
+             xwl_screen_get_next_output_serial(xwl_screen));
+
+    xwl_output->lease_device = lease_device;
+    xwl_output->xwl_screen = xwl_screen;
+    xwl_output->lease_connector = connector;
+    xwl_output->randr_crtc = RRCrtcCreate(xwl_screen->screen, xwl_output);
+    if (!xwl_output->randr_crtc) {
+        ErrorF("Failed creating RandR CRTC\n");
+        goto err;
+    }
+    RRCrtcSetRotations(xwl_output->randr_crtc, ALL_ROTATIONS);
+    xwl_output->randr_output = RROutputCreate(xwl_screen->screen,
+                                              name, strlen(name), xwl_output);
+    if (!xwl_output->randr_output) {
+        ErrorF("Failed creating RandR Output\n");
+        goto err;
+    }
+
+    RRCrtcGammaSetSize(xwl_output->randr_crtc, 256);
+    RROutputSetCrtcs(xwl_output->randr_output, &xwl_output->randr_crtc, 1);
+    RROutputSetConnection(xwl_output->randr_output, RR_Connected);
+    RROutputSetNonDesktop(xwl_output->randr_output, TRUE);
+    xwl_output->randr_output->devPrivate = xwl_output;
+
+    wp_drm_lease_connector_v1_add_listener(connector,
+                                            &lease_connector_listener,
+                                            xwl_output);
+
+    xorg_list_append(&xwl_output->link, &xwl_screen->output_list);
+    return;
+
+err:
+    if (xwl_output->randr_crtc)
+        RRCrtcDestroy(xwl_output->randr_crtc);
+    free(xwl_output);
+}
+
+static void
+drm_lease_device_handle_released(void *data,
+                                 struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1)
+{
+    struct xwl_drm_lease_device *lease_device = data;
+    xwl_screen_destroy_drm_lease_device(lease_device->xwl_screen, wp_drm_lease_device_v1);
+}
+
+static void
+drm_lease_device_handle_done(void *data,
+                             struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1)
+{
+    /* This space is deliberately left blank */
+}
+
+static const struct wp_drm_lease_device_v1_listener drm_lease_device_listener = {
+    .drm_fd = drm_lease_device_handle_drm_fd,
+    .connector = drm_lease_device_handle_connector,
+    .released = drm_lease_device_handle_released,
+    .done = drm_lease_device_handle_done,
+};
+
+void
+xwl_screen_add_drm_lease_device(struct xwl_screen *xwl_screen, uint32_t id)
+{
+    struct wp_drm_lease_device_v1 *lease_device = wl_registry_bind(
+        xwl_screen->registry, id, &wp_drm_lease_device_v1_interface, 1);
+    struct xwl_drm_lease_device *device_data = malloc(sizeof(struct xwl_drm_lease_device));
+
+    device_data->drm_lease_device = lease_device;
+    device_data->xwl_screen = xwl_screen;
+    device_data->drm_read_only_fd = -1;
+    device_data->id = id;
+    xorg_list_add(&device_data->link, &xwl_screen->drm_lease_devices);
+    wp_drm_lease_device_v1_add_listener(lease_device,
+                                         &drm_lease_device_listener,
+                                         device_data);
+}
+
+void
+xwl_screen_destroy_drm_lease_device(struct xwl_screen *xwl_screen,
+                                    struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1)
+{
+    struct xwl_drm_lease_device *device_data;
+
+    xorg_list_for_each_entry(device_data, &xwl_screen->drm_lease_devices, link) {
+        if (device_data->drm_lease_device == wp_drm_lease_device_v1) {
+            wp_drm_lease_device_v1_destroy(wp_drm_lease_device_v1);
+            xorg_list_del(&device_data->link);
+            if (device_data->drm_read_only_fd >= 0)
+                close(device_data->drm_read_only_fd);
+            free(device_data);
+            return;
+        }
+    }
+}
diff --git a/hw/xwayland/xwayland-drm-lease.h b/hw/xwayland/xwayland-drm-lease.h
new file mode 100644
index 000000000..aa5aed63c
--- /dev/null
+++ b/hw/xwayland/xwayland-drm-lease.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright © 2020 Drew Devault
+ * Copyright © 2021 Xaver Hugl
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_DRM_LEASE_H
+#define XWAYLAND_DRM_LEASE_H
+
+#include <X11/Xatom.h>
+#include <randrstr.h>
+
+#include "xwayland-types.h"
+#include "list.h"
+
+#include "drm-lease-v1-client-protocol.h"
+
+struct xwl_drm_lease_device {
+    struct xorg_list link;
+    struct wp_drm_lease_device_v1 *drm_lease_device;
+    int drm_read_only_fd;
+    struct xwl_screen *xwl_screen;
+    uint32_t id;
+};
+
+struct xwl_queued_drm_lease_device {
+    struct xorg_list link;
+    uint32_t id;
+};
+
+struct xwl_drm_lease {
+    struct xorg_list link;
+    struct wp_drm_lease_v1 *lease;
+    RRLeasePtr rrLease;
+    ClientPtr client;
+    int fd;
+};
+
+int xwl_randr_request_lease(ClientPtr client, ScreenPtr screen, RRLeasePtr rrLease);
+void xwl_randr_get_lease(ClientPtr client, ScreenPtr screen, RRLeasePtr *rrLease, int *fd);
+void xwl_randr_terminate_lease(ScreenPtr screen, RRLeasePtr lease);
+
+void xwl_screen_add_drm_lease_device(struct xwl_screen *xwl_screen, uint32_t id);
+void xwl_screen_destroy_drm_lease_device(struct xwl_screen *xwl_screen,
+                                         struct wp_drm_lease_device_v1 *wp_drm_lease_device_v1);
+
+#endif /* XWAYLAND_DRM_LEASE_H */
diff --git a/hw/xwayland/xwayland-glamor-eglstream.c b/hw/xwayland/xwayland-glamor-eglstream.c
new file mode 100644
index 000000000..c911ed987
--- /dev/null
+++ b/hw/xwayland/xwayland-glamor-eglstream.c
@@ -0,0 +1,1124 @@
+/*
+ * Copyright © 2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including
+ * the next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Lyude Paul <lyude@redhat.com>
+ *
+ */
+
+#include <xwayland-config.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#define EGL_NO_X11
+#include <glamor_egl.h>
+#include <glamor.h>
+#include <glamor_priv.h>
+#include <glamor_transform.h>
+#include <glamor_transfer.h>
+
+#include <xf86drm.h>
+#include <dri3.h>
+#include <drm_fourcc.h>
+
+#include <epoxy/egl.h>
+
+#include "xwayland-glamor.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+
+#include "wayland-eglstream-client-protocol.h"
+#include "wayland-eglstream-controller-client-protocol.h"
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+
+struct xwl_eglstream_private {
+    EGLDeviceEXT egl_device;
+    struct wl_eglstream_display *display;
+    struct wl_eglstream_controller *controller;
+    uint32_t display_caps;
+
+    EGLConfig config;
+
+    Bool have_egl_damage;
+    Bool have_egl_stream_flush;
+
+    GLint blit_prog;
+    GLuint blit_vao;
+    GLuint blit_vbo;
+    GLuint blit_is_rgba_pos;
+};
+
+enum xwl_pixmap_type {
+    XWL_PIXMAP_EGLSTREAM, /* Pixmaps created by glamor. */
+    XWL_PIXMAP_DMA_BUF, /* Pixmaps allocated through DRI3. */
+};
+
+struct xwl_pixmap {
+    enum xwl_pixmap_type type;
+    /* add any new <= 4-byte member here to avoid holes on 64-bit */
+    struct xwl_screen *xwl_screen;
+    struct wl_buffer *buffer;
+    struct wl_callback *pending_cb;
+    Bool wait_for_buffer_release;
+
+    /* XWL_PIXMAP_EGLSTREAM. */
+    EGLStreamKHR stream;
+    EGLSurface surface;
+
+    /* XWL_PIXMAP_DMA_BUF. */
+    EGLImage image;
+};
+
+static DevPrivateKeyRec xwl_eglstream_private_key;
+
+static inline struct xwl_eglstream_private *
+xwl_eglstream_get(struct xwl_screen *xwl_screen)
+{
+    return dixLookupPrivate(&xwl_screen->screen->devPrivates,
+                            &xwl_eglstream_private_key);
+}
+
+static GLuint
+xwl_eglstream_build_glsl_prog(GLuint vs, GLuint fs)
+{
+    GLint ok;
+    GLuint prog;
+
+    prog = glCreateProgram();
+    glAttachShader(prog, vs);
+    glAttachShader(prog, fs);
+
+    glLinkProgram(prog);
+    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
+    if (!ok) {
+        GLchar *info;
+        GLint size;
+
+        glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &size);
+        info = malloc(size);
+
+        glGetProgramInfoLog(prog, size, NULL, info);
+        ErrorF("Failed to link: %s\n", info);
+        FatalError("GLSL link failure\n");
+    }
+
+    return prog;
+}
+
+static void
+xwl_eglstream_cleanup(struct xwl_screen *xwl_screen)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+
+    if (xwl_eglstream->display)
+        wl_eglstream_display_destroy(xwl_eglstream->display);
+    if (xwl_eglstream->controller)
+        wl_eglstream_controller_destroy(xwl_eglstream->controller);
+    if (xwl_eglstream->blit_prog) {
+        glDeleteProgram(xwl_eglstream->blit_prog);
+        glDeleteBuffers(1, &xwl_eglstream->blit_vbo);
+    }
+
+    free(xwl_eglstream);
+}
+
+static Bool
+xwl_glamor_egl_supports_device_probing(void)
+{
+    return epoxy_has_egl_extension(NULL, "EGL_EXT_device_base");
+}
+
+static void **
+xwl_glamor_egl_get_devices(int *num_devices)
+{
+    EGLDeviceEXT *devices, *tmp;
+    Bool ret;
+    int drm_dev_count = 0;
+    int i;
+
+    if (!xwl_glamor_egl_supports_device_probing())
+        return NULL;
+
+    /* Get the number of devices */
+    ret = eglQueryDevicesEXT(0, NULL, num_devices);
+    if (!ret || *num_devices < 1)
+        return NULL;
+
+    devices = calloc(*num_devices, sizeof(EGLDeviceEXT));
+    if (!devices)
+        return NULL;
+
+    ret = eglQueryDevicesEXT(*num_devices, devices, num_devices);
+    if (!ret)
+        goto error;
+
+    /* We're only ever going to care about devices that support
+     * EGL_EXT_device_drm, so filter out the ones that don't
+     */
+    for (i = 0; i < *num_devices; i++) {
+        const char *extension_str =
+            eglQueryDeviceStringEXT(devices[i], EGL_EXTENSIONS);
+
+        if (!epoxy_extension_in_string(extension_str, "EGL_EXT_device_drm"))
+            continue;
+
+        devices[drm_dev_count++] = devices[i];
+    }
+    if (!drm_dev_count)
+        goto error;
+
+    *num_devices = drm_dev_count;
+    tmp = realloc(devices, sizeof(EGLDeviceEXT) * drm_dev_count);
+    if (!tmp)
+        goto error;
+
+    devices = tmp;
+
+    return devices;
+
+error:
+    free(devices);
+
+    return NULL;
+}
+
+static Bool
+xwl_glamor_egl_device_has_egl_extensions(void *device,
+                                         const char **ext_list, size_t size)
+{
+    EGLDisplay egl_display;
+    int i;
+    Bool has_exts = TRUE;
+
+    egl_display = glamor_egl_get_display(EGL_PLATFORM_DEVICE_EXT, device);
+    if (!egl_display || !eglInitialize(egl_display, NULL, NULL))
+        return FALSE;
+
+    for (i = 0; i < size; i++) {
+        if (!epoxy_has_egl_extension(egl_display, ext_list[i])) {
+            has_exts = FALSE;
+            break;
+        }
+    }
+
+    eglTerminate(egl_display);
+    return has_exts;
+}
+
+static void
+xwl_eglstream_destroy_pixmap_stream(struct xwl_pixmap *xwl_pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_pixmap->xwl_screen;
+
+    /* If we're using this stream in the current egl context, unbind it so the
+     * driver doesn't keep it around until the next eglMakeCurrent()
+     * don't have to keep it around until something else changes the surface
+     */
+    xwl_glamor_egl_make_current(xwl_screen);
+    if (eglGetCurrentSurface(EGL_READ) == xwl_pixmap->surface ||
+        eglGetCurrentSurface(EGL_DRAW) == xwl_pixmap->surface) {
+        eglMakeCurrent(xwl_screen->egl_display,
+                       EGL_NO_SURFACE, EGL_NO_SURFACE,
+                       xwl_screen->egl_context);
+    }
+
+    if (xwl_pixmap->surface != EGL_NO_SURFACE)
+        eglDestroySurface(xwl_screen->egl_display, xwl_pixmap->surface);
+
+    if (xwl_pixmap->stream != EGL_NO_STREAM_KHR)
+        eglDestroyStreamKHR(xwl_screen->egl_display, xwl_pixmap->stream);
+
+    if (xwl_pixmap->buffer)
+        wl_buffer_destroy(xwl_pixmap->buffer);
+
+    if (xwl_pixmap->image != EGL_NO_IMAGE_KHR)
+        eglDestroyImageKHR(xwl_screen->egl_display, xwl_pixmap->image);
+
+    free(xwl_pixmap);
+}
+
+static void
+xwl_eglstream_destroy_pending_cb(PixmapPtr pixmap)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap && xwl_pixmap->pending_cb) {
+        wl_callback_destroy(xwl_pixmap->pending_cb);
+        xwl_pixmap->pending_cb = NULL;
+    }
+}
+
+static Bool
+xwl_glamor_eglstream_destroy_pixmap(PixmapPtr pixmap)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap && pixmap->refcnt == 1) {
+        xwl_eglstream_destroy_pending_cb(pixmap);
+        xwl_eglstream_destroy_pixmap_stream(xwl_pixmap);
+        xwl_pixmap_del_buffer_release_cb(pixmap);
+    }
+    return glamor_destroy_pixmap(pixmap);
+}
+
+static struct wl_buffer *
+xwl_glamor_eglstream_get_wl_buffer_for_pixmap(PixmapPtr pixmap)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (!xwl_pixmap)
+        return NULL;
+
+    return xwl_pixmap->buffer;
+}
+
+static const char *
+xwl_eglstream_get_error_str(EGLint error)
+{
+    switch (error) {
+    case EGL_BAD_PARAMETER:
+        return "EGL_BAD_PARAMETER";
+    case EGL_BAD_ATTRIBUTE:
+        return "EGL_BAD_ATTRIBUTE";
+    case EGL_BAD_MATCH:
+        return "EGL_BAD_MATCH";
+    case EGL_BAD_ACCESS:
+        return "EGL_BAD_ACCESS";
+    case EGL_BAD_STATE_KHR:
+        return "EGL_BAD_STATE_KHR";
+    case EGL_BAD_STREAM_KHR:
+        return "EGL_BAD_STREAM_KHR";
+    case EGL_BAD_DISPLAY:
+        return "EGL_BAD_DISPLAY";
+    case EGL_NOT_INITIALIZED:
+        return "EGL_NOT_INITIALIZED";
+    default:
+        return "Unknown error";
+    }
+}
+
+static const char *
+xwl_eglstream_get_stream_state_str(EGLint state)
+{
+    switch (state) {
+    case EGL_STREAM_STATE_CREATED_KHR:
+        return "EGL_STREAM_STATE_CREATED_KHR";
+    case EGL_STREAM_STATE_CONNECTING_KHR:
+        return "EGL_STREAM_STATE_CONNECTING_KHR";
+    case EGL_STREAM_STATE_EMPTY_KHR:
+        return "EGL_STREAM_STATE_EMPTY_KHR";
+    case EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR:
+        return "EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR";
+    case EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR:
+        return "EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR";
+    case EGL_STREAM_STATE_DISCONNECTED_KHR:
+        return "EGL_STREAM_STATE_DISCONNECTED_KHR";
+    default:
+        return "Unknown state";
+    }
+}
+
+static EGLint
+xwl_eglstream_get_state(EGLDisplay egl_display, EGLStreamKHR egl_stream)
+{
+    EGLint state;
+
+    eglQueryStreamKHR(egl_display, egl_stream, EGL_STREAM_STATE_KHR, &state);
+    if (!eglQueryStreamKHR(egl_display, egl_stream,
+                           EGL_STREAM_STATE_KHR, &state)) {
+        EGLint state_error = eglGetError();
+        ErrorF("eglstream: Failed to query state - error 0x%X: %s\n",
+               state_error, xwl_eglstream_get_error_str(state_error));
+        return EGL_FALSE;
+    }
+
+    return state;
+}
+
+
+static void
+xwl_eglstream_print_error(EGLDisplay egl_display,
+                          EGLStreamKHR egl_stream, EGLint error)
+{
+    ErrorF("eglstream: error 0x%X: %s\n", error,
+           xwl_eglstream_get_error_str(error));
+
+    if (error == EGL_BAD_STATE_KHR) {
+        EGLint state = xwl_eglstream_get_state(egl_display, egl_stream);
+        ErrorF("eglstream: stream state 0x%X: %s\n", state,
+               xwl_eglstream_get_stream_state_str(state));
+    }
+}
+
+static void
+xwl_eglstream_consumer_ready_callback(void *data,
+                                      struct wl_callback *callback,
+                                      uint32_t time)
+{
+    PixmapPtr pixmap = data;
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+    struct xwl_screen *xwl_screen = xwl_pixmap->xwl_screen;
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+
+    xwl_eglstream_destroy_pending_cb(pixmap);
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    xwl_pixmap->surface = eglCreateStreamProducerSurfaceKHR(
+        xwl_screen->egl_display, xwl_eglstream->config,
+        xwl_pixmap->stream, (int[]) {
+            EGL_WIDTH,  pixmap->drawable.width,
+            EGL_HEIGHT, pixmap->drawable.height,
+            EGL_NONE
+        });
+
+    if (xwl_pixmap->surface == EGL_NO_SURFACE) {
+        ErrorF("eglstream: Failed to create EGLSurface for pixmap\n");
+        xwl_eglstream_print_error(xwl_screen->egl_display,
+                                  xwl_pixmap->stream, eglGetError());
+    } else {
+        DebugF("eglstream: completes eglstream for pixmap %p, congrats!\n",
+               pixmap);
+    }
+}
+
+static const struct wl_callback_listener consumer_ready_listener = {
+    xwl_eglstream_consumer_ready_callback
+};
+
+static void
+xwl_eglstream_buffer_release_callback(void *data)
+{
+    PixmapPtr pixmap = data;
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    assert(xwl_pixmap);
+
+    if (xwl_pixmap->wait_for_buffer_release) {
+        xwl_pixmap->wait_for_buffer_release = FALSE;
+        /* drop the reference we took in the ready callback, freeing if necessary */
+        dixDestroyPixmap(pixmap, 0);
+    }
+}
+
+static const struct wl_buffer_listener xwl_eglstream_buffer_release_listener = {
+    xwl_pixmap_buffer_release_cb,
+};
+
+static void
+xwl_eglstream_create_pixmap_and_stream(struct xwl_screen *xwl_screen,
+                                       WindowPtr window, PixmapPtr pixmap)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+    struct xwl_pixmap *xwl_pixmap;
+    struct xwl_window *xwl_window = xwl_window_from_window(window);
+    struct wl_array stream_attribs;
+    int stream_fd = -1;
+
+    xwl_pixmap = calloc(1, sizeof(*xwl_pixmap));
+    if (!xwl_pixmap)
+        FatalError("Not enough memory to create pixmap\n");
+    xwl_pixmap_set_private(pixmap, xwl_pixmap);
+
+    xwl_pixmap->type = XWL_PIXMAP_EGLSTREAM;
+    xwl_pixmap->image = EGL_NO_IMAGE;
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    xwl_pixmap->wait_for_buffer_release = FALSE;
+    xwl_pixmap->xwl_screen = xwl_screen;
+    xwl_pixmap->surface = EGL_NO_SURFACE;
+    xwl_pixmap->stream = eglCreateStreamKHR(xwl_screen->egl_display, NULL);
+    if (xwl_pixmap->stream == EGL_NO_STREAM_KHR) {
+        ErrorF("eglstream: Couldn't create EGL stream.\n");
+        goto fail;
+    }
+    stream_fd = eglGetStreamFileDescriptorKHR(xwl_screen->egl_display,
+                                              xwl_pixmap->stream);
+    if (stream_fd == EGL_NO_FILE_DESCRIPTOR_KHR) {
+        ErrorF("eglstream: Couldn't get EGL stream file descriptor.\n");
+        goto fail;
+    }
+
+    wl_array_init(&stream_attribs);
+    xwl_pixmap->buffer =
+        wl_eglstream_display_create_stream(xwl_eglstream->display,
+                                           pixmap->drawable.width,
+                                           pixmap->drawable.height,
+                                           stream_fd,
+                                           WL_EGLSTREAM_HANDLE_TYPE_FD,
+                                           &stream_attribs);
+    if (!xwl_pixmap->buffer) {
+        ErrorF("eglstream: Failed to create buffer\n");
+        goto fail;
+    }
+
+    wl_buffer_add_listener(xwl_pixmap->buffer,
+                           &xwl_eglstream_buffer_release_listener,
+                           pixmap);
+
+    xwl_pixmap_set_buffer_release_cb(pixmap,
+                                     xwl_eglstream_buffer_release_callback,
+                                     pixmap);
+
+    wl_eglstream_controller_attach_eglstream_consumer(
+        xwl_eglstream->controller, xwl_window->surface, xwl_pixmap->buffer);
+
+    xwl_pixmap->pending_cb = wl_display_sync(xwl_screen->display);
+    wl_callback_add_listener(xwl_pixmap->pending_cb, &consumer_ready_listener,
+                             pixmap);
+fail:
+    if (stream_fd >= 0)
+        close(stream_fd);
+}
+
+static Bool
+xwl_glamor_eglstream_allow_commits(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    PixmapPtr pixmap =
+        (*xwl_screen->screen->GetWindowPixmap)(xwl_window->window);
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap) {
+        if (xwl_pixmap->pending_cb) {
+            /* Wait for the compositor to finish connecting the consumer for
+             * this eglstream */
+            return FALSE;
+        }
+
+        if (xwl_pixmap->surface != EGL_NO_SURFACE ||
+            xwl_pixmap->type == XWL_PIXMAP_DMA_BUF) {
+            return TRUE;
+        }
+
+        /* The pending stream got removed, we have a xwl_pixmap and
+         * yet we do not have a surface.
+         * So something went wrong with the surface creation, retry.
+         */
+         xwl_eglstream_destroy_pixmap_stream(xwl_pixmap);
+    }
+
+    /* Glamor pixmap has no backing stream yet; begin making one and disallow
+     * commits until then
+     */
+    xwl_eglstream_create_pixmap_and_stream(xwl_screen, xwl_window->window,
+                                           pixmap);
+
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_eglstream_post_damage(struct xwl_window *xwl_window,
+                                 PixmapPtr pixmap, RegionPtr region)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+    BoxPtr box = RegionExtents(region);
+    EGLint egl_damage[] = {
+        box->x1,           box->y1,
+        box->x2 - box->x1, box->y2 - box->y1
+    };
+    GLint saved_vao;
+    int status;
+
+    if (xwl_pixmap->type != XWL_PIXMAP_EGLSTREAM)
+        /* This can happen if a client does X11 rendering on a
+         * flipping OpenGL or Vulkan window. In that case, we don't
+         * need to do the copy below.
+         */
+        return TRUE;
+
+    /* Unbind the framebuffer BEFORE binding the EGLSurface, otherwise we
+     * won't actually draw to it
+     */
+    xwl_glamor_egl_make_current(xwl_screen);
+    glamor_set_alu(xwl_screen->screen, GXcopy);
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+    if (eglGetCurrentSurface(EGL_READ) != xwl_pixmap->surface ||
+        eglGetCurrentSurface(EGL_DRAW) != xwl_pixmap->surface)
+        eglMakeCurrent(xwl_screen->egl_display,
+                       xwl_pixmap->surface, xwl_pixmap->surface,
+                       xwl_screen->egl_context);
+
+    /* Save current GL state */
+    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &saved_vao);
+
+    /* Setup our GL state */
+    glUseProgram(xwl_eglstream->blit_prog);
+    glViewport(0, 0, pixmap->drawable.width, pixmap->drawable.height);
+    glActiveTexture(GL_TEXTURE0);
+    glBindVertexArray(xwl_eglstream->blit_vao);
+    glBindTexture(GL_TEXTURE_2D, glamor_get_pixmap_texture(pixmap));
+
+    glUniform1i(xwl_eglstream->blit_is_rgba_pos,
+                pixmap->drawable.depth >= 32);
+
+    status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if (status != GL_FRAMEBUFFER_COMPLETE) {
+        ErrorF("eglstream: Framebuffer incomplete 0x%X, not posting damage\n", status);
+        status = FALSE;
+        goto out;
+    }
+
+    /* Blit rendered image into EGLStream surface */
+    glDrawBuffer(GL_BACK);
+    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+    if (xwl_eglstream->have_egl_damage)
+        status = eglSwapBuffersWithDamageKHR(xwl_screen->egl_display,
+                                             xwl_pixmap->surface,
+                                             egl_damage, 1);
+    else
+        status = eglSwapBuffers(xwl_screen->egl_display,
+                                xwl_pixmap->surface);
+
+    if (!status) {
+        ErrorF("eglstream: buffer swap failed, not posting damage\n");
+        goto out;
+    }
+
+#ifdef EGL_NV_stream_flush
+    if (xwl_eglstream->have_egl_stream_flush)
+        /* block until stream state is updated on the compositor's side */
+        eglStreamFlushNV(xwl_screen->egl_display,
+                         xwl_pixmap->stream);
+#endif
+
+    if (!xwl_pixmap->wait_for_buffer_release) {
+        /* hang onto the pixmap until the compositor has released it */
+        pixmap->refcnt++;
+        xwl_pixmap->wait_for_buffer_release = TRUE;
+    }
+
+out:
+    /* Restore previous state */
+    glBindVertexArray(saved_vao);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    return status;
+}
+
+static Bool
+xwl_glamor_eglstream_check_flip(PixmapPtr pixmap)
+{
+    return xwl_pixmap_get(pixmap)->type == XWL_PIXMAP_DMA_BUF;
+}
+
+static void
+xwl_eglstream_display_handle_caps(void *data,
+                                  struct wl_eglstream_display *disp,
+                                  int32_t caps)
+{
+    xwl_eglstream_get(data)->display_caps = caps;
+}
+
+static void
+xwl_eglstream_display_handle_swapinterval_override(void *data,
+                                                   struct wl_eglstream_display *disp,
+                                                   int32_t swapinterval,
+                                                   struct wl_buffer *stream)
+{
+}
+
+const struct wl_eglstream_display_listener eglstream_display_listener = {
+    .caps = xwl_eglstream_display_handle_caps,
+    .swapinterval_override = xwl_eglstream_display_handle_swapinterval_override,
+};
+
+static Bool
+xwl_glamor_eglstream_init_wl_registry(struct xwl_screen *xwl_screen,
+                                      struct wl_registry *wl_registry,
+                                      uint32_t id, const char *name,
+                                      uint32_t version)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+
+    if (strcmp(name, "wl_eglstream_display") == 0) {
+        xwl_eglstream->display = wl_registry_bind(
+            wl_registry, id, &wl_eglstream_display_interface, version);
+
+        wl_eglstream_display_add_listener(xwl_eglstream->display,
+                                          &eglstream_display_listener,
+                                          xwl_screen);
+        return TRUE;
+    } else if (strcmp(name, "wl_eglstream_controller") == 0) {
+        xwl_eglstream->controller = wl_registry_bind(
+            wl_registry, id, &wl_eglstream_controller_interface, version);
+        return TRUE;
+    } else if (strcmp(name, "zwp_linux_dmabuf_v1") == 0) {
+        xwl_screen_set_dmabuf_interface(xwl_screen, id, version);
+        return TRUE;
+    }
+
+    /* no match */
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_eglstream_has_wl_interfaces(struct xwl_screen *xwl_screen)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+
+    if (xwl_eglstream->display == NULL) {
+        LogMessageVerb(X_INFO, 3,
+                       "glamor: 'wl_eglstream_display' not supported\n");
+        return FALSE;
+    }
+
+    if (xwl_eglstream->controller == NULL) {
+        LogMessageVerb(X_INFO, 3,
+                       "glamor: 'wl_eglstream_controller' not supported\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static inline void
+xwl_eglstream_init_shaders(struct xwl_screen *xwl_screen)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+    GLint fs, vs, attrib;
+    GLuint vbo;
+
+    const char *blit_vs_src =
+        "attribute vec2 texcoord;\n"
+        "attribute vec2 position;\n"
+        "varying vec2 t;\n"
+        "void main() {\n"
+        "    t = texcoord;\n"
+        "    gl_Position = vec4(position, 0, 1);\n"
+        "}";
+
+    const char *blit_fs_src =
+        "varying vec2 t;\n"
+        "uniform sampler2D s;\n"
+        "uniform bool is_rgba;\n"
+        "void main() {\n"
+        "    if (is_rgba)\n"
+        "        gl_FragColor = texture2D(s, t);\n"
+        "    else\n"
+        "        gl_FragColor = vec4(texture2D(s, t).rgb, 1.0);\n"
+        "}";
+
+    static const float position[] = {
+        /* position */
+        -1, -1,
+         1, -1,
+         1,  1,
+        -1,  1,
+        /* texcoord */
+         0,  1,
+         1,  1,
+         1,  0,
+         0,  0,
+    };
+
+    vs = glamor_compile_glsl_prog(GL_VERTEX_SHADER, blit_vs_src);
+    fs = glamor_compile_glsl_prog(GL_FRAGMENT_SHADER, blit_fs_src);
+
+    xwl_eglstream->blit_prog = xwl_eglstream_build_glsl_prog(vs, fs);
+    glDeleteShader(vs);
+    glDeleteShader(fs);
+
+    /* Create the blitter's vao */
+    glGenVertexArrays(1, &xwl_eglstream->blit_vao);
+    glBindVertexArray(xwl_eglstream->blit_vao);
+
+    /* Set the data for both position and texcoord in the vbo */
+    glGenBuffers(1, &vbo);
+    glBindBuffer(GL_ARRAY_BUFFER, vbo);
+    glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);
+    xwl_eglstream->blit_vbo = vbo;
+
+    /* Define each shader attribute's data location in our vbo */
+    attrib = glGetAttribLocation(xwl_eglstream->blit_prog, "position");
+    glVertexAttribPointer(attrib, 2, GL_FLOAT, TRUE, 0, NULL);
+    glEnableVertexAttribArray(attrib);
+
+    attrib = glGetAttribLocation(xwl_eglstream->blit_prog, "texcoord");
+    glVertexAttribPointer(attrib, 2, GL_FLOAT, TRUE, 0,
+                          (void*)(sizeof(float) * 8));
+    glEnableVertexAttribArray(attrib);
+
+    /* Save the location of uniforms we'll set later */
+    xwl_eglstream->blit_is_rgba_pos =
+        glGetUniformLocation(xwl_eglstream->blit_prog, "is_rgba");
+}
+
+static int
+xwl_dri3_open_client(ClientPtr client,
+                     ScreenPtr screen,
+                     RRProviderPtr provider,
+                     int *pfd)
+{
+    /* Not supported with this backend. */
+    return BadImplementation;
+}
+
+static PixmapPtr
+xwl_dri3_pixmap_from_fds(ScreenPtr screen,
+                         CARD8 num_fds, const int *fds,
+                         CARD16 width, CARD16 height,
+                         const CARD32 *strides, const CARD32 *offsets,
+                         CARD8 depth, CARD8 bpp,
+                         uint64_t modifier)
+{
+    PixmapPtr pixmap;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_pixmap *xwl_pixmap;
+    unsigned int texture;
+    EGLint image_attribs[48];
+    uint32_t mod_hi = modifier >> 32, mod_lo = modifier & 0xffffffff, format;
+    int attrib = 0, i;
+    struct zwp_linux_buffer_params_v1 *params;
+
+    format = wl_drm_format_for_depth(depth);
+    if (!xwl_glamor_is_modifier_supported(xwl_screen, format, modifier)) {
+        ErrorF("glamor: unsupported format modifier\n");
+        return NULL;
+    }
+
+    xwl_pixmap = calloc(1, sizeof (*xwl_pixmap));
+    if (!xwl_pixmap)
+        return NULL;
+    xwl_pixmap->type = XWL_PIXMAP_DMA_BUF;
+    xwl_pixmap->xwl_screen = xwl_screen;
+
+    xwl_pixmap->buffer = NULL;
+    xwl_pixmap->stream = EGL_NO_STREAM_KHR;
+    xwl_pixmap->surface = EGL_NO_SURFACE;
+
+    params = zwp_linux_dmabuf_v1_create_params(xwl_screen->dmabuf);
+    for (i = 0; i < num_fds; i++) {
+        zwp_linux_buffer_params_v1_add(params, fds[i], i,
+                                       offsets[i], strides[i],
+                                       mod_hi, mod_lo);
+    }
+    xwl_pixmap->buffer =
+        zwp_linux_buffer_params_v1_create_immed(params, width, height,
+                                                format, 0);
+    zwp_linux_buffer_params_v1_destroy(params);
+
+
+    image_attribs[attrib++] = EGL_WIDTH;
+    image_attribs[attrib++] = width;
+    image_attribs[attrib++] = EGL_HEIGHT;
+    image_attribs[attrib++] = height;
+    image_attribs[attrib++] = EGL_LINUX_DRM_FOURCC_EXT;
+    image_attribs[attrib++] = drm_format_for_depth(depth, bpp);
+
+    if (num_fds > 0) {
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE0_FD_EXT;
+        image_attribs[attrib++] = fds[0];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+        image_attribs[attrib++] = offsets[0];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+        image_attribs[attrib++] = strides[0];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT;
+        image_attribs[attrib++] = mod_hi;
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT;
+        image_attribs[attrib++] = mod_lo;
+    }
+    if (num_fds > 1) {
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE1_FD_EXT;
+        image_attribs[attrib++] = fds[1];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE1_OFFSET_EXT;
+        image_attribs[attrib++] = offsets[1];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE1_PITCH_EXT;
+        image_attribs[attrib++] = strides[1];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT;
+        image_attribs[attrib++] = mod_hi;
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT;
+        image_attribs[attrib++] = mod_lo;
+    }
+    if (num_fds > 2) {
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE2_FD_EXT;
+        image_attribs[attrib++] = fds[2];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE2_OFFSET_EXT;
+        image_attribs[attrib++] = offsets[2];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE2_PITCH_EXT;
+        image_attribs[attrib++] = strides[2];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT;
+        image_attribs[attrib++] = mod_hi;
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT;
+        image_attribs[attrib++] = mod_lo;
+    }
+    if (num_fds > 3) {
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE3_FD_EXT;
+        image_attribs[attrib++] = fds[3];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE3_OFFSET_EXT;
+        image_attribs[attrib++] = offsets[3];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE3_PITCH_EXT;
+        image_attribs[attrib++] = strides[3];
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE3_MODIFIER_HI_EXT;
+        image_attribs[attrib++] = mod_hi;
+        image_attribs[attrib++] = EGL_DMA_BUF_PLANE3_MODIFIER_LO_EXT;
+        image_attribs[attrib++] = mod_lo;
+    }
+    image_attribs[attrib++] = EGL_NONE;
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    /* eglCreateImageKHR will close fds */
+    xwl_pixmap->image = eglCreateImageKHR(xwl_screen->egl_display,
+                                          EGL_NO_CONTEXT,
+                                          EGL_LINUX_DMA_BUF_EXT,
+                                          NULL, image_attribs);
+    if (xwl_pixmap->image == EGL_NO_IMAGE_KHR) {
+        ErrorF("eglCreateImageKHR failed!\n");
+        if (xwl_pixmap->buffer)
+            wl_buffer_destroy(xwl_pixmap->buffer);
+        free(xwl_pixmap);
+        return NULL;
+    }
+
+    glGenTextures(1, &texture);
+    glBindTexture(GL_TEXTURE_2D, texture);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, xwl_pixmap->image);
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    pixmap = glamor_create_pixmap(screen, width, height, depth,
+                                  GLAMOR_CREATE_PIXMAP_NO_TEXTURE);
+    glamor_set_pixmap_texture(pixmap, texture);
+    glamor_set_pixmap_type(pixmap, GLAMOR_TEXTURE_DRM);
+    wl_buffer_add_listener(xwl_pixmap->buffer,
+                           &xwl_eglstream_buffer_release_listener,
+                           pixmap);
+    xwl_pixmap_set_private(pixmap, xwl_pixmap);
+
+    return pixmap;
+}
+
+static const dri3_screen_info_rec xwl_dri3_info = {
+    .version = 2,
+    .open = NULL,
+    .pixmap_from_fds = xwl_dri3_pixmap_from_fds,
+    .fds_from_pixmap = NULL,
+    .open_client = xwl_dri3_open_client,
+    .get_formats = xwl_glamor_get_formats,
+    .get_modifiers = xwl_glamor_get_modifiers,
+    .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+};
+
+static Bool
+xwl_glamor_eglstream_init_egl(struct xwl_screen *xwl_screen)
+{
+    struct xwl_eglstream_private *xwl_eglstream =
+        xwl_eglstream_get(xwl_screen);
+    EGLConfig config;
+    const EGLint attrib_list[] = {
+        EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR,
+        EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
+        EGL_CONTEXT_MAJOR_VERSION_KHR,
+        GLAMOR_GL_CORE_VER_MAJOR,
+        EGL_CONTEXT_MINOR_VERSION_KHR,
+        GLAMOR_GL_CORE_VER_MINOR,
+        EGL_CONTEXT_PRIORITY_LEVEL_IMG, EGL_CONTEXT_PRIORITY_HIGH_IMG,
+        EGL_NONE
+    };
+    const EGLint config_attribs[] = {
+        EGL_SURFACE_TYPE, EGL_STREAM_BIT_KHR,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_RED_SIZE, 8,
+        EGL_GREEN_SIZE, 8,
+        EGL_BLUE_SIZE, 8,
+        EGL_ALPHA_SIZE, 8,
+        EGL_NONE,
+    };
+    int n;
+
+    xwl_screen->egl_display = glamor_egl_get_display(
+        EGL_PLATFORM_DEVICE_EXT, xwl_eglstream->egl_device);
+    if (!xwl_screen->egl_display)
+        goto error;
+
+    if (!eglInitialize(xwl_screen->egl_display, NULL, NULL)) {
+        xwl_screen->egl_display = NULL;
+        goto error;
+    }
+
+    if (!epoxy_has_egl_extension(xwl_screen->egl_display,
+                                 "EGL_IMG_context_priority")) {
+        ErrorF("EGL_IMG_context_priority not available\n");
+        goto error;
+    }
+
+    eglChooseConfig(xwl_screen->egl_display, config_attribs, &config, 1, &n);
+    if (!n) {
+        ErrorF("No acceptable EGL configs found\n");
+        goto error;
+    }
+
+    xwl_eglstream->config = config;
+#if 0
+    xwl_screen->formats =
+        XWL_FORMAT_RGB565 | XWL_FORMAT_XRGB8888 | XWL_FORMAT_ARGB8888;
+#endif
+
+    eglBindAPI(EGL_OPENGL_API);
+    xwl_screen->egl_context = eglCreateContext(xwl_screen->egl_display,
+                                               EGL_NO_CONFIG_KHR,
+                                               EGL_NO_CONTEXT,
+                                               attrib_list);
+    if (xwl_screen->egl_context == EGL_NO_CONTEXT) {
+        ErrorF("Failed to create main EGL context: 0x%x\n", eglGetError());
+        goto error;
+    }
+
+    if (!eglMakeCurrent(xwl_screen->egl_display,
+                        EGL_NO_SURFACE, EGL_NO_SURFACE,
+                        xwl_screen->egl_context)) {
+        ErrorF("Failed to make EGL context current\n");
+        goto error;
+    }
+
+    xwl_eglstream->have_egl_damage =
+        epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "EGL_KHR_swap_buffers_with_damage");
+    if (!xwl_eglstream->have_egl_damage)
+        ErrorF("Driver lacks EGL_KHR_swap_buffers_with_damage, performance "
+               "will be affected\n");
+
+#ifdef EGL_NV_stream_flush
+    xwl_eglstream->have_egl_stream_flush =
+        epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "EGL_NV_stream_flush");
+#else
+    xwl_eglstream->have_egl_stream_flush = FALSE;
+#endif /* EGL_NV_stream_flush */
+
+    if (!xwl_eglstream->have_egl_stream_flush)
+        ErrorF("EGL_NV_stream_flush not available, "
+               "this may cause visible corruption.\n");
+
+    xwl_eglstream_init_shaders(xwl_screen);
+
+    if (epoxy_has_gl_extension("GL_OES_EGL_image")) {
+        if (dri3_screen_init(xwl_screen->screen, &xwl_dri3_info))
+            xwl_screen->glvnd_vendor = "nvidia";
+        else
+            ErrorF("DRI3 initialization failed. Performance will be affected.\n");
+    } else {
+        ErrorF("Driver lacks GL_OES_EGL_image, performance will be affected.\n");
+    }
+
+    return TRUE;
+error:
+    xwl_eglstream_cleanup(xwl_screen);
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_eglstream_init_screen(struct xwl_screen *xwl_screen)
+{
+    ScreenPtr screen = xwl_screen->screen;
+
+    /* We can just let glamor handle CreatePixmap */
+    screen->DestroyPixmap = xwl_glamor_eglstream_destroy_pixmap;
+
+    return TRUE;
+}
+
+static EGLDeviceEXT
+xwl_eglstream_get_device(struct xwl_screen *xwl_screen)
+{
+    void **devices = NULL;
+    const char *exts[] = {
+        "EGL_KHR_stream",
+        "EGL_KHR_stream_producer_eglsurface",
+    };
+    int num_devices, i;
+    EGLDeviceEXT device = EGL_NO_DEVICE_EXT;
+
+    /* No device specified by the user, so find one ourselves */
+    devices = xwl_glamor_egl_get_devices(&num_devices);
+    if (!devices)
+        goto out;
+
+    for (i = 0; i < num_devices; i++) {
+        if (xwl_glamor_egl_device_has_egl_extensions(devices[i], exts,
+                                                     ARRAY_SIZE(exts))) {
+            device = devices[i];
+            break;
+        }
+    }
+
+    free(devices);
+out:
+    if (!device)
+        LogMessageVerb(X_INFO, 3, "glamor: No eglstream capable devices found\n");
+    return device;
+}
+
+void
+xwl_glamor_init_eglstream(struct xwl_screen *xwl_screen)
+{
+    struct xwl_eglstream_private *xwl_eglstream;
+    EGLDeviceEXT egl_device;
+
+    xwl_screen->eglstream_backend.is_available = FALSE;
+    egl_device = xwl_eglstream_get_device(xwl_screen);
+    if (egl_device == EGL_NO_DEVICE_EXT)
+        return;
+
+    if (!dixRegisterPrivateKey(&xwl_eglstream_private_key, PRIVATE_SCREEN, 0))
+        return;
+
+    xwl_eglstream = calloc(1, sizeof(*xwl_eglstream));
+    if (!xwl_eglstream) {
+        ErrorF("Failed to allocate memory required to init EGLStream support\n");
+        return;
+    }
+
+    dixSetPrivate(&xwl_screen->screen->devPrivates,
+                  &xwl_eglstream_private_key, xwl_eglstream);
+
+    xwl_eglstream->egl_device = egl_device;
+
+    xwl_screen->eglstream_backend.init_egl = xwl_glamor_eglstream_init_egl;
+    xwl_screen->eglstream_backend.init_wl_registry = xwl_glamor_eglstream_init_wl_registry;
+    xwl_screen->eglstream_backend.has_wl_interfaces = xwl_glamor_eglstream_has_wl_interfaces;
+    xwl_screen->eglstream_backend.init_screen = xwl_glamor_eglstream_init_screen;
+    xwl_screen->eglstream_backend.get_wl_buffer_for_pixmap = xwl_glamor_eglstream_get_wl_buffer_for_pixmap;
+    xwl_screen->eglstream_backend.post_damage = xwl_glamor_eglstream_post_damage;
+    xwl_screen->eglstream_backend.allow_commits = xwl_glamor_eglstream_allow_commits;
+    xwl_screen->eglstream_backend.check_flip = xwl_glamor_eglstream_check_flip;
+    xwl_screen->eglstream_backend.get_main_device = NULL;
+    xwl_screen->eglstream_backend.is_available = TRUE;
+    xwl_screen->eglstream_backend.backend_flags = XWL_EGL_BACKEND_NO_FLAG;
+}
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
new file mode 100644
index 000000000..205d2feb3
--- /dev/null
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -0,0 +1,1153 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ * Copyright © 2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including
+ * the next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Lyude Paul <lyude@redhat.com>
+ *
+ */
+
+#include <xwayland-config.h>
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <xf86drm.h>
+#include <drm_fourcc.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#define EGL_NO_X11
+#include <gbm.h>
+#include <glamor_egl.h>
+
+#include <glamor.h>
+#include <glamor_context.h>
+#include <dri3.h>
+#include "drm-client-protocol.h"
+
+#include "xwayland-glamor.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-screen.h"
+
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+
+struct xwl_gbm_private {
+    dev_t device;
+    char *device_name;
+    struct gbm_device *gbm;
+    struct wl_drm *drm;
+    int drm_fd;
+    int fd_render_node;
+    Bool drm_authenticated;
+    uint32_t capabilities;
+    int dmabuf_capable;
+};
+
+struct xwl_pixmap {
+    struct wl_buffer *buffer;
+    EGLImage image;
+    unsigned int texture;
+    struct gbm_bo *bo;
+};
+
+static DevPrivateKeyRec xwl_gbm_private_key;
+static DevPrivateKeyRec xwl_auth_state_private_key;
+
+static inline struct xwl_gbm_private *
+xwl_gbm_get(struct xwl_screen *xwl_screen)
+{
+    return dixLookupPrivate(&xwl_screen->screen->devPrivates,
+                            &xwl_gbm_private_key);
+}
+
+static uint32_t
+gbm_format_for_depth(int depth)
+{
+    switch (depth) {
+    case 16:
+        return GBM_FORMAT_RGB565;
+    case 24:
+        return GBM_FORMAT_XRGB8888;
+    case 30:
+        return GBM_FORMAT_ARGB2101010;
+    default:
+        ErrorF("unexpected depth: %d\n", depth);
+    case 32:
+        return GBM_FORMAT_ARGB8888;
+    }
+}
+
+static char
+is_device_path_render_node (const char *device_path)
+{
+    char is_render_node;
+    int fd;
+
+    fd = open(device_path, O_RDWR | O_CLOEXEC);
+    if (fd < 0)
+        return 0;
+
+    is_render_node = (drmGetNodeTypeFromFd(fd) == DRM_NODE_RENDER);
+    close(fd);
+
+    return is_render_node;
+}
+
+static PixmapPtr
+xwl_glamor_gbm_create_pixmap_for_bo(ScreenPtr screen, struct gbm_bo *bo,
+                                    int depth)
+{
+    PixmapPtr pixmap;
+    struct xwl_pixmap *xwl_pixmap;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+#ifdef GBM_BO_FD_FOR_PLANE
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    uint64_t modifier = gbm_bo_get_modifier(bo);
+    const int num_planes = gbm_bo_get_plane_count(bo);
+    int fds[GBM_MAX_PLANES];
+    int plane;
+    int attr_num = 0;
+    EGLint img_attrs[64] = {0};
+    enum PlaneAttrs {
+        PLANE_FD,
+        PLANE_OFFSET,
+        PLANE_PITCH,
+        PLANE_MODIFIER_LO,
+        PLANE_MODIFIER_HI,
+        NUM_PLANE_ATTRS
+    };
+    static const EGLint planeAttrs[][NUM_PLANE_ATTRS] = {
+        {
+            EGL_DMA_BUF_PLANE0_FD_EXT,
+            EGL_DMA_BUF_PLANE0_OFFSET_EXT,
+            EGL_DMA_BUF_PLANE0_PITCH_EXT,
+            EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT,
+            EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT,
+        },
+        {
+            EGL_DMA_BUF_PLANE1_FD_EXT,
+            EGL_DMA_BUF_PLANE1_OFFSET_EXT,
+            EGL_DMA_BUF_PLANE1_PITCH_EXT,
+            EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT,
+            EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT,
+        },
+        {
+            EGL_DMA_BUF_PLANE2_FD_EXT,
+            EGL_DMA_BUF_PLANE2_OFFSET_EXT,
+            EGL_DMA_BUF_PLANE2_PITCH_EXT,
+            EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT,
+            EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT,
+        },
+        {
+            EGL_DMA_BUF_PLANE3_FD_EXT,
+            EGL_DMA_BUF_PLANE3_OFFSET_EXT,
+            EGL_DMA_BUF_PLANE3_PITCH_EXT,
+            EGL_DMA_BUF_PLANE3_MODIFIER_LO_EXT,
+            EGL_DMA_BUF_PLANE3_MODIFIER_HI_EXT,
+        },
+    };
+
+    for (plane = 0; plane < num_planes; plane++) fds[plane] = -1;
+#endif
+
+    xwl_pixmap = calloc(1, sizeof(*xwl_pixmap));
+    if (xwl_pixmap == NULL)
+        return NULL;
+
+    pixmap = glamor_create_pixmap(screen,
+                                  gbm_bo_get_width(bo),
+                                  gbm_bo_get_height(bo),
+                                  depth,
+                                  GLAMOR_CREATE_PIXMAP_NO_TEXTURE);
+    if (!pixmap) {
+        free(xwl_pixmap);
+        return NULL;
+    }
+
+    xwl_glamor_egl_make_current(xwl_screen);
+    xwl_pixmap->bo = bo;
+    xwl_pixmap->buffer = NULL;
+
+#ifdef GBM_BO_FD_FOR_PLANE
+    if (xwl_gbm->dmabuf_capable) {
+#define ADD_ATTR(attrs, num, attr)                                      \
+        do {                                                            \
+            assert(((num) + 1) < (sizeof(attrs) / sizeof((attrs)[0]))); \
+            (attrs)[(num)++] = (attr);                                  \
+        } while (0)
+        ADD_ATTR(img_attrs, attr_num, EGL_WIDTH);
+        ADD_ATTR(img_attrs, attr_num, gbm_bo_get_width(bo));
+        ADD_ATTR(img_attrs, attr_num, EGL_HEIGHT);
+        ADD_ATTR(img_attrs, attr_num, gbm_bo_get_height(bo));
+        ADD_ATTR(img_attrs, attr_num, EGL_LINUX_DRM_FOURCC_EXT);
+        ADD_ATTR(img_attrs, attr_num, gbm_bo_get_format(bo));
+
+        for (plane = 0; plane < num_planes; plane++) {
+            fds[plane] = gbm_bo_get_fd_for_plane(bo, plane);
+            ADD_ATTR(img_attrs, attr_num, planeAttrs[plane][PLANE_FD]);
+            ADD_ATTR(img_attrs, attr_num, fds[plane]);
+            ADD_ATTR(img_attrs, attr_num, planeAttrs[plane][PLANE_OFFSET]);
+            ADD_ATTR(img_attrs, attr_num, gbm_bo_get_offset(bo, plane));
+            ADD_ATTR(img_attrs, attr_num, planeAttrs[plane][PLANE_PITCH]);
+            ADD_ATTR(img_attrs, attr_num, gbm_bo_get_stride_for_plane(bo, plane));
+            ADD_ATTR(img_attrs, attr_num, planeAttrs[plane][PLANE_MODIFIER_LO]);
+            ADD_ATTR(img_attrs, attr_num, (uint32_t)(modifier & 0xFFFFFFFFULL));
+            ADD_ATTR(img_attrs, attr_num, planeAttrs[plane][PLANE_MODIFIER_HI]);
+            ADD_ATTR(img_attrs, attr_num, (uint32_t)(modifier >> 32ULL));
+        }
+        ADD_ATTR(img_attrs, attr_num, EGL_NONE);
+#undef ADD_ATTR
+
+        xwl_pixmap->image = eglCreateImageKHR(xwl_screen->egl_display,
+                                              EGL_NO_CONTEXT,
+                                              EGL_LINUX_DMA_BUF_EXT,
+                                              NULL,
+                                              img_attrs);
+
+        for (plane = 0; plane < num_planes; plane++) {
+            close(fds[plane]);
+            fds[plane] = -1;
+        }
+    }
+    else
+#endif
+    {
+        xwl_pixmap->image = eglCreateImageKHR(xwl_screen->egl_display,
+                                              xwl_screen->egl_context,
+                                              EGL_NATIVE_PIXMAP_KHR,
+                                              xwl_pixmap->bo, NULL);
+    }
+
+    if (xwl_pixmap->image == EGL_NO_IMAGE_KHR)
+      goto error;
+
+    glGenTextures(1, &xwl_pixmap->texture);
+    glBindTexture(GL_TEXTURE_2D, xwl_pixmap->texture);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, xwl_pixmap->image);
+    if (eglGetError() != EGL_SUCCESS)
+      goto error;
+
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    if (!glamor_set_pixmap_texture(pixmap, xwl_pixmap->texture))
+      goto error;
+
+    glamor_set_pixmap_type(pixmap, GLAMOR_TEXTURE_DRM);
+    xwl_pixmap_set_private(pixmap, xwl_pixmap);
+
+    return pixmap;
+
+error:
+    if (xwl_pixmap->image != EGL_NO_IMAGE_KHR)
+      eglDestroyImageKHR(xwl_screen->egl_display, xwl_pixmap->image);
+    if (pixmap)
+      glamor_destroy_pixmap(pixmap);
+    free(xwl_pixmap);
+
+    return NULL;
+}
+
+static PixmapPtr
+xwl_glamor_gbm_create_pixmap(ScreenPtr screen,
+                             int width, int height, int depth,
+                             unsigned int hint)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    struct gbm_bo *bo;
+    PixmapPtr pixmap = NULL;
+
+    if (width > 0 && height > 0 && depth >= 15 &&
+        (hint == CREATE_PIXMAP_USAGE_BACKING_PIXMAP ||
+         hint == CREATE_PIXMAP_USAGE_SHARED ||
+         (xwl_screen->rootless && hint == 0))) {
+        uint32_t format = gbm_format_for_depth(depth);
+
+#ifdef GBM_BO_WITH_MODIFIERS
+        if (xwl_gbm->dmabuf_capable) {
+            uint32_t num_modifiers;
+            uint64_t *modifiers = NULL;
+
+            xwl_glamor_get_modifiers(screen, format, &num_modifiers, &modifiers);
+            bo = gbm_bo_create_with_modifiers(xwl_gbm->gbm, width, height,
+                                              format, modifiers, num_modifiers);
+            free(modifiers);
+        }
+        else
+#endif
+        {
+            bo = gbm_bo_create(xwl_gbm->gbm, width, height, format,
+                               GBM_BO_USE_RENDERING);
+        }
+
+        if (bo) {
+            pixmap = xwl_glamor_gbm_create_pixmap_for_bo(screen, bo, depth);
+
+            if (!pixmap) {
+                gbm_bo_destroy(bo);
+            }
+            else if (xwl_screen->rootless && hint == CREATE_PIXMAP_USAGE_BACKING_PIXMAP) {
+                glamor_clear_pixmap(pixmap);
+            }
+        }
+    }
+
+    if (!pixmap)
+        pixmap = glamor_create_pixmap(screen, width, height, depth, hint);
+
+    return pixmap;
+}
+
+static Bool
+xwl_glamor_gbm_destroy_pixmap(PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap && pixmap->refcnt == 1) {
+        xwl_pixmap_del_buffer_release_cb(pixmap);
+        if (xwl_pixmap->buffer)
+            wl_buffer_destroy(xwl_pixmap->buffer);
+
+        eglDestroyImageKHR(xwl_screen->egl_display, xwl_pixmap->image);
+        if (xwl_pixmap->bo)
+           gbm_bo_destroy(xwl_pixmap->bo);
+        free(xwl_pixmap);
+    }
+
+    return glamor_destroy_pixmap(pixmap);
+}
+
+static const struct wl_buffer_listener xwl_glamor_gbm_buffer_listener = {
+    xwl_pixmap_buffer_release_cb,
+};
+
+static struct wl_buffer *
+xwl_glamor_gbm_get_wl_buffer_for_pixmap(PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    unsigned short width = pixmap->drawable.width;
+    unsigned short height = pixmap->drawable.height;
+    uint32_t format;
+    int num_planes;
+    int prime_fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    uint64_t modifier;
+    int i;
+#ifndef GBM_BO_FD_FOR_PLANE
+    int32_t first_handle;
+#endif
+
+    if (xwl_pixmap == NULL)
+       return NULL;
+
+    if (xwl_pixmap->buffer) {
+        /* Buffer already exists. */
+        return xwl_pixmap->buffer;
+    }
+
+    if (!xwl_pixmap->bo)
+       return NULL;
+
+    format = wl_drm_format_for_depth(pixmap->drawable.depth);
+
+#ifdef GBM_BO_WITH_MODIFIERS
+    num_planes = gbm_bo_get_plane_count(xwl_pixmap->bo);
+    modifier = gbm_bo_get_modifier(xwl_pixmap->bo);
+    for (i = 0; i < num_planes; i++) {
+#ifdef GBM_BO_FD_FOR_PLANE
+        prime_fds[i] = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, i);
+#else
+        union gbm_bo_handle plane_handle;
+
+        plane_handle = gbm_bo_get_handle_for_plane(xwl_pixmap->bo, i);
+        if (i == 0)
+            first_handle = plane_handle.s32;
+
+        /* If all planes point to the same object as the first plane, i.e. they
+         * all have the same handle, we can fall back to the non-planar
+         * gbm_bo_get_fd without losing information. If they point to different
+         * objects we are out of luck and need to give up.
+         */
+        if (first_handle == plane_handle.s32)
+            prime_fds[i] = gbm_bo_get_fd(xwl_pixmap->bo);
+        else
+            prime_fds[i] = -1;
+#endif
+        if (prime_fds[i] == -1) {
+            while (--i >= 0)
+                close(prime_fds[i]);
+            return NULL;
+        }
+        strides[i] = gbm_bo_get_stride_for_plane(xwl_pixmap->bo, i);
+        offsets[i] = gbm_bo_get_offset(xwl_pixmap->bo, i);
+    }
+#else
+    num_planes = 1;
+    modifier = DRM_FORMAT_MOD_INVALID;
+    prime_fds[0] = gbm_bo_get_fd(xwl_pixmap->bo);
+    if (prime_fds[0] == -1)
+        return NULL;
+    strides[0] = gbm_bo_get_stride(xwl_pixmap->bo);
+    offsets[0] = 0;
+#endif
+
+    if (xwl_screen->dmabuf &&
+        xwl_glamor_is_modifier_supported(xwl_screen, format, modifier)) {
+        struct zwp_linux_buffer_params_v1 *params;
+
+        params = zwp_linux_dmabuf_v1_create_params(xwl_screen->dmabuf);
+        for (i = 0; i < num_planes; i++) {
+            zwp_linux_buffer_params_v1_add(params, prime_fds[i], i,
+                                           offsets[i], strides[i],
+                                           modifier >> 32, modifier & 0xffffffff);
+        }
+
+        xwl_pixmap->buffer =
+           zwp_linux_buffer_params_v1_create_immed(params, width, height,
+                                                   format, 0);
+        zwp_linux_buffer_params_v1_destroy(params);
+    } else if (num_planes == 1) {
+        xwl_pixmap->buffer =
+            wl_drm_create_prime_buffer(xwl_gbm->drm, prime_fds[0], width, height,
+                                       format,
+                                       0, gbm_bo_get_stride(xwl_pixmap->bo),
+                                       0, 0,
+                                       0, 0);
+    }
+
+    for (i = 0; i < num_planes; i++)
+        close(prime_fds[i]);
+
+    /* Add our listener now */
+    wl_buffer_add_listener(xwl_pixmap->buffer,
+                           &xwl_glamor_gbm_buffer_listener, pixmap);
+
+    return xwl_pixmap->buffer;
+}
+
+static void
+xwl_glamor_gbm_cleanup(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (xwl_gbm->device_name)
+        free(xwl_gbm->device_name);
+    if (xwl_gbm->drm_fd)
+        close(xwl_gbm->drm_fd);
+    if (xwl_gbm->drm)
+        wl_drm_destroy(xwl_gbm->drm);
+    if (xwl_gbm->gbm)
+        gbm_device_destroy(xwl_gbm->gbm);
+
+    free(xwl_gbm);
+}
+
+struct xwl_auth_state {
+    int fd;
+    ClientPtr client;
+    struct wl_callback *callback;
+};
+
+static void
+free_xwl_auth_state(ClientPtr pClient, struct xwl_auth_state *state)
+{
+    dixSetPrivate(&pClient->devPrivates, &xwl_auth_state_private_key, NULL);
+    if (state) {
+        wl_callback_destroy(state->callback);
+        free(state);
+    }
+}
+
+static void
+xwl_auth_state_client_callback(CallbackListPtr *pcbl, void *unused, void *data)
+{
+    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
+    ClientPtr pClient = clientinfo->client;
+    struct xwl_auth_state *state;
+
+    switch (pClient->clientState) {
+    case ClientStateGone:
+    case ClientStateRetained:
+        state = dixLookupPrivate(&pClient->devPrivates,
+                                 &xwl_auth_state_private_key);
+        free_xwl_auth_state(pClient, state);
+        break;
+    default:
+        break;
+    }
+}
+
+static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+    struct xwl_auth_state *state = data;
+    ClientPtr client = state->client;
+
+    /* if the client is gone, the callback is cancelled so it's safe to
+     * assume the client is still in ClientStateRunning at this point...
+     */
+    dri3_send_open_reply(client, state->fd);
+    AttendClient(client);
+    free_xwl_auth_state(client, state);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+static int
+xwl_dri3_open_client(ClientPtr client,
+                     ScreenPtr screen,
+                     RRProviderPtr provider,
+                     int *pfd)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    struct xwl_auth_state *state;
+    drm_magic_t magic;
+    int fd;
+
+    fd = open(xwl_gbm->device_name, O_RDWR | O_CLOEXEC);
+    if (fd < 0)
+        return BadAlloc;
+    if (xwl_gbm->fd_render_node) {
+        *pfd = fd;
+        return Success;
+    }
+
+    state = malloc(sizeof *state);
+    if (state == NULL) {
+        close(fd);
+        return BadAlloc;
+    }
+
+    state->client = client;
+    state->fd = fd;
+
+    if (drmGetMagic(state->fd, &magic) < 0) {
+        close(state->fd);
+        free(state);
+        return BadMatch;
+    }
+
+    wl_drm_authenticate(xwl_gbm->drm, magic);
+    state->callback = wl_display_sync(xwl_screen->display);
+    wl_callback_add_listener(state->callback, &sync_listener, state);
+    dixSetPrivate(&client->devPrivates, &xwl_auth_state_private_key, state);
+
+    IgnoreClient(client);
+
+    return Success;
+}
+
+_X_EXPORT PixmapPtr
+glamor_pixmap_from_fds(ScreenPtr screen, CARD8 num_fds, const int *fds,
+                       CARD16 width, CARD16 height,
+                       const CARD32 *strides, const CARD32 *offsets,
+                       CARD8 depth, CARD8 bpp, uint64_t modifier)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    struct gbm_bo *bo = NULL;
+    PixmapPtr pixmap;
+    int i;
+
+    if (width == 0 || height == 0 || num_fds == 0 ||
+        depth < 15 || bpp != BitsPerPixel(depth) ||
+        strides[0] < width * bpp / 8)
+       goto error;
+
+    if (xwl_gbm->dmabuf_capable && modifier != DRM_FORMAT_MOD_INVALID) {
+#ifdef GBM_BO_WITH_MODIFIERS
+       struct gbm_import_fd_modifier_data data;
+
+       data.width = width;
+       data.height = height;
+       data.num_fds = num_fds;
+       data.format = gbm_format_for_depth(depth);
+       data.modifier = modifier;
+       for (i = 0; i < num_fds; i++) {
+          data.fds[i] = fds[i];
+          data.strides[i] = strides[i];
+          data.offsets[i] = offsets[i];
+       }
+       bo = gbm_bo_import(xwl_gbm->gbm, GBM_BO_IMPORT_FD_MODIFIER, &data,
+                          GBM_BO_USE_RENDERING);
+#endif
+    } else if (num_fds == 1) {
+       struct gbm_import_fd_data data;
+
+       data.fd = fds[0];
+       data.width = width;
+       data.height = height;
+       data.stride = strides[0];
+       data.format = gbm_format_for_depth(depth);
+       bo = gbm_bo_import(xwl_gbm->gbm, GBM_BO_IMPORT_FD, &data,
+                          GBM_BO_USE_RENDERING);
+    } else {
+       goto error;
+    }
+
+    if (bo == NULL)
+       goto error;
+
+    pixmap = xwl_glamor_gbm_create_pixmap_for_bo(screen, bo, depth);
+    if (pixmap == NULL) {
+       gbm_bo_destroy(bo);
+       goto error;
+    }
+
+    return pixmap;
+
+error:
+    return NULL;
+}
+
+_X_EXPORT int
+glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
+                           uint32_t *strides, uint32_t *offsets,
+                           uint64_t *modifier)
+{
+    struct xwl_pixmap *xwl_pixmap;
+#ifdef GBM_BO_WITH_MODIFIERS
+#ifndef GBM_BO_FD_FOR_PLANE
+    int32_t first_handle;
+#endif
+    uint32_t num_fds;
+    int i;
+#endif
+
+    xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap == NULL)
+       return 0;
+
+    if (!xwl_pixmap->bo)
+       return 0;
+
+#ifdef GBM_BO_WITH_MODIFIERS
+    num_fds = gbm_bo_get_plane_count(xwl_pixmap->bo);
+    *modifier = gbm_bo_get_modifier(xwl_pixmap->bo);
+
+    for (i = 0; i < num_fds; i++) {
+#ifdef GBM_BO_FD_FOR_PLANE
+        fds[i] = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, i);
+#else
+        union gbm_bo_handle plane_handle;
+
+        plane_handle = gbm_bo_get_handle_for_plane(xwl_pixmap->bo, i);
+        if (i == 0)
+            first_handle = plane_handle.s32;
+
+        /* If all planes point to the same object as the first plane, i.e. they
+         * all have the same handle, we can fall back to the non-planar
+         * gbm_bo_get_fd without losing information. If they point to different
+         * objects we are out of luck and need to give up.
+         */
+        if (first_handle == plane_handle.s32)
+            fds[i] = gbm_bo_get_fd(xwl_pixmap->bo);
+        else
+            fds[i] = -1;
+#endif
+        if (fds[i] == -1) {
+            while (--i >= 0)
+                close(fds[i]);
+            return 0;
+        }
+        strides[i] = gbm_bo_get_stride_for_plane(xwl_pixmap->bo, i);
+        offsets[i] = gbm_bo_get_offset(xwl_pixmap->bo, i);
+    }
+
+    return num_fds;
+#else
+    *modifier = DRM_FORMAT_MOD_INVALID;
+    fds[0] = gbm_bo_get_fd(xwl_pixmap->bo);
+    if (fds[0] == -1)
+        return 0;
+    strides[0] = gbm_bo_get_stride(xwl_pixmap->bo);
+    offsets[0] = 0;
+    return 1;
+#endif
+}
+
+/* Not actually used, just defined here so there's something for
+ * _glamor_egl_fds_from_pixmap() to link against
+ */
+_X_EXPORT int
+glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
+                          CARD16 *stride, CARD32 *size)
+{
+    return -1;
+}
+
+static const dri3_screen_info_rec xwl_dri3_info = {
+    .version = 2,
+    .open = NULL,
+    .pixmap_from_fds = glamor_pixmap_from_fds,
+    .fds_from_pixmap = glamor_fds_from_pixmap,
+    .open_client = xwl_dri3_open_client,
+    .get_formats = xwl_glamor_get_formats,
+    .get_modifiers = xwl_glamor_get_modifiers,
+    .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+};
+
+static const char *
+get_render_node_path_for_device(const drmDevicePtr drm_device,
+                                const char *device_path)
+{
+    char *render_node_path = NULL;
+    char device_found = 0;
+    int i;
+
+    for (i = 0; i < DRM_NODE_MAX; i++) {
+        if ((drm_device->available_nodes & (1 << i)) == 0)
+           continue;
+
+        if (!strcmp (device_path, drm_device->nodes[i]))
+            device_found = 1;
+
+        if (is_device_path_render_node(drm_device->nodes[i]))
+            render_node_path = drm_device->nodes[i];
+
+        if (device_found && render_node_path)
+            return render_node_path;
+    }
+
+    return NULL;
+}
+
+static char *
+get_render_node_path(const char *device_path)
+{
+    drmDevicePtr *devices = NULL;
+    char *render_node_path = NULL;
+    int i, n_devices, max_devices;
+
+    max_devices = drmGetDevices2(0, NULL, 0);
+    if (max_devices <= 0)
+        goto out;
+
+    devices = calloc(max_devices, sizeof(drmDevicePtr));
+    if (!devices)
+        goto out;
+
+    n_devices = drmGetDevices2(0, devices, max_devices);
+    if (n_devices < 0)
+        goto out;
+
+    for (i = 0; i < n_devices; i++) {
+       const char *node_path = get_render_node_path_for_device(devices[i],
+                                                               device_path);
+       if (node_path) {
+           render_node_path = strdup(node_path);
+           break;
+       }
+    }
+
+out:
+    free(devices);
+    return render_node_path;
+}
+
+static void
+xwl_drm_handle_device(void *data, struct wl_drm *drm, const char *device)
+{
+   struct xwl_screen *xwl_screen = data;
+   struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+   drm_magic_t magic;
+   char *render_node_path = NULL;
+   struct stat stat;
+
+   if (!is_device_path_render_node(device))
+       render_node_path = get_render_node_path(device);
+
+   if (render_node_path)
+       xwl_gbm->device_name = render_node_path;
+   else
+       xwl_gbm->device_name = strdup(device);
+
+   if (!xwl_gbm->device_name) {
+       xwl_glamor_gbm_cleanup(xwl_screen);
+       return;
+   }
+
+   xwl_gbm->drm_fd = open(xwl_gbm->device_name, O_RDWR | O_CLOEXEC);
+   if (xwl_gbm->drm_fd == -1) {
+       ErrorF("wayland-egl: could not open %s (%s)\n",
+              xwl_gbm->device_name, strerror(errno));
+       xwl_glamor_gbm_cleanup(xwl_screen);
+       return;
+   }
+
+   if (fstat(xwl_gbm->drm_fd, &stat)) {
+       ErrorF("wayland-egl: Could not stat file %s (%s)\n",
+              xwl_gbm->device_name, strerror(errno));
+       return;
+   }
+   xwl_gbm->device = stat.st_rdev;
+
+   if (drmGetNodeTypeFromFd(xwl_gbm->drm_fd) == DRM_NODE_RENDER) {
+       xwl_gbm->fd_render_node = 1;
+       xwl_screen->expecting_event--;
+   } else {
+       drmGetMagic(xwl_gbm->drm_fd, &magic);
+       wl_drm_authenticate(xwl_gbm->drm, magic);
+   }
+}
+
+static void
+xwl_drm_handle_format(void *data, struct wl_drm *drm, uint32_t format)
+{
+}
+
+static void
+xwl_drm_handle_authenticated(void *data, struct wl_drm *drm)
+{
+    struct xwl_screen *xwl_screen = data;
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    xwl_gbm->drm_authenticated = TRUE;
+    xwl_screen->expecting_event--;
+}
+
+static void
+xwl_drm_handle_capabilities(void *data, struct wl_drm *drm, uint32_t value)
+{
+    xwl_gbm_get(data)->capabilities = value;
+}
+
+static const struct wl_drm_listener xwl_drm_listener = {
+    xwl_drm_handle_device,
+    xwl_drm_handle_format,
+    xwl_drm_handle_authenticated,
+    xwl_drm_handle_capabilities
+};
+
+Bool
+xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
+                             uint32_t id, uint32_t version)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (version < 2)
+        return FALSE;
+
+    xwl_gbm->drm =
+        wl_registry_bind(xwl_screen->registry, id, &wl_drm_interface, 2);
+    wl_drm_add_listener(xwl_gbm->drm, &xwl_drm_listener, xwl_screen);
+    xwl_screen->expecting_event++;
+
+    return TRUE;
+}
+
+static Bool
+xwl_glamor_gbm_init_wl_registry(struct xwl_screen *xwl_screen,
+                                struct wl_registry *wl_registry,
+                                uint32_t id, const char *name,
+                                uint32_t version)
+{
+    if (strcmp(name, "wl_drm") == 0) {
+        xwl_screen_set_drm_interface(xwl_screen, id, version);
+        return TRUE;
+    } else if (strcmp(name, "zwp_linux_dmabuf_v1") == 0) {
+        xwl_screen_set_dmabuf_interface(xwl_screen, id, version);
+        return TRUE;
+    }
+
+    /* no match */
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_gbm_has_egl_extension(void)
+{
+    return (epoxy_has_egl_extension(NULL, "EGL_MESA_platform_gbm") ||
+            epoxy_has_egl_extension(NULL, "EGL_KHR_platform_gbm"));
+}
+
+static Bool
+xwl_glamor_gbm_has_wl_interfaces(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (xwl_gbm->drm == NULL) {
+        LogMessageVerb(X_INFO, 3, "glamor: 'wl_drm' not supported\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static Bool
+xwl_glamor_try_to_make_context_current(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->egl_context == EGL_NO_CONTEXT)
+        return FALSE;
+
+    return eglMakeCurrent(xwl_screen->egl_display, EGL_NO_SURFACE,
+                          EGL_NO_SURFACE, xwl_screen->egl_context);
+}
+
+static void
+xwl_glamor_maybe_destroy_context(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->egl_context == EGL_NO_CONTEXT)
+        return;
+
+   eglMakeCurrent(xwl_screen->egl_display, EGL_NO_SURFACE,
+                  EGL_NO_SURFACE, EGL_NO_CONTEXT);
+   eglDestroyContext(xwl_screen->egl_display, xwl_screen->egl_context);
+   xwl_screen->egl_context = EGL_NO_CONTEXT;
+}
+
+static Bool
+xwl_glamor_try_big_gl_api(struct xwl_screen *xwl_screen)
+{
+    static const EGLint config_attribs_core[] = {
+        EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR,
+        EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
+        EGL_CONTEXT_MAJOR_VERSION_KHR,
+        GLAMOR_GL_CORE_VER_MAJOR,
+        EGL_CONTEXT_MINOR_VERSION_KHR,
+        GLAMOR_GL_CORE_VER_MINOR,
+        EGL_NONE
+    };
+    int gl_version;
+
+    eglBindAPI(EGL_OPENGL_API);
+
+    xwl_screen->egl_context =
+        eglCreateContext(xwl_screen->egl_display, EGL_NO_CONFIG_KHR,
+                         EGL_NO_CONTEXT, config_attribs_core);
+
+    if (xwl_screen->egl_context == EGL_NO_CONTEXT)
+        xwl_screen->egl_context =
+            eglCreateContext(xwl_screen->egl_display, EGL_NO_CONFIG_KHR,
+                             EGL_NO_CONTEXT, NULL);
+
+    if (!xwl_glamor_try_to_make_context_current(xwl_screen)) {
+        ErrorF("Failed to make EGL context current with GL\n");
+        xwl_glamor_maybe_destroy_context(xwl_screen);
+        return FALSE;
+    }
+
+    /* glamor needs at least GL 2.1, if the GL version is less than 2.1,
+     * drop the context we created, it's useless.
+     */
+    gl_version = epoxy_gl_version();
+    if (gl_version < 21) {
+        ErrorF("Supported GL version is not sufficient (required 21, found %i)\n",
+               gl_version);
+        xwl_glamor_maybe_destroy_context(xwl_screen);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static Bool
+xwl_glamor_try_gles_api(struct xwl_screen *xwl_screen)
+{
+    const EGLint gles_attribs[] = {
+        EGL_CONTEXT_CLIENT_VERSION,
+        2,
+        EGL_NONE,
+    };
+
+    eglBindAPI(EGL_OPENGL_ES_API);
+
+    xwl_screen->egl_context = eglCreateContext(xwl_screen->egl_display,
+                                               EGL_NO_CONFIG_KHR,
+                                               EGL_NO_CONTEXT, gles_attribs);
+
+    if (!xwl_glamor_try_to_make_context_current(xwl_screen)) {
+        ErrorF("Failed to make EGL context current with GLES2\n");
+        xwl_glamor_maybe_destroy_context(xwl_screen);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static Bool
+xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    EGLint major, minor;
+    const GLubyte *renderer;
+    const char *gbm_backend_name;
+
+    if (!xwl_gbm->fd_render_node && !xwl_gbm->drm_authenticated) {
+        ErrorF("Failed to get wl_drm, disabling Glamor and DRI3\n");
+	return FALSE;
+    }
+
+    xwl_gbm->gbm = gbm_create_device(xwl_gbm->drm_fd);
+    if (!xwl_gbm->gbm) {
+        ErrorF("couldn't create gbm device\n");
+        goto error;
+    }
+
+    xwl_screen->egl_display = glamor_egl_get_display(EGL_PLATFORM_GBM_MESA,
+                                                     xwl_gbm->gbm);
+    if (xwl_screen->egl_display == EGL_NO_DISPLAY) {
+        ErrorF("glamor_egl_get_display() failed\n");
+        goto error;
+    }
+
+    if (!eglInitialize(xwl_screen->egl_display, &major, &minor)) {
+        ErrorF("eglInitialize() failed\n");
+        goto error;
+    }
+
+    if (!xwl_glamor_try_big_gl_api(xwl_screen) &&
+        !xwl_glamor_try_gles_api(xwl_screen)) {
+        ErrorF("Cannot use neither GL nor GLES2\n");
+        goto error;
+    }
+
+    renderer = glGetString(GL_RENDERER);
+    if (!renderer) {
+        ErrorF("glGetString() returned NULL, your GL is broken\n");
+        goto error;
+    }
+    if (strstr((const char *)renderer, "softpipe")) {
+        ErrorF("Refusing to try glamor on softpipe\n");
+        goto error;
+    }
+    if (!strncmp("llvmpipe", (const char *)renderer, strlen("llvmpipe"))) {
+        ErrorF("Refusing to try glamor on llvmpipe\n");
+        goto error;
+    }
+
+    if (!epoxy_has_gl_extension("GL_OES_EGL_image")) {
+        ErrorF("GL_OES_EGL_image not available\n");
+        goto error;
+    }
+
+    if (epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "EXT_image_dma_buf_import") &&
+        epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "EXT_image_dma_buf_import_modifiers"))
+       xwl_gbm->dmabuf_capable = TRUE;
+
+    gbm_backend_name = gbm_device_get_backend_name(xwl_gbm->gbm);
+    /* Mesa uses "drm" as backend name, in that case, just do nothing */
+    if (gbm_backend_name && strcmp(gbm_backend_name, "drm") != 0)
+        xwl_screen->glvnd_vendor = gbm_backend_name;
+
+    return TRUE;
+error:
+    if (xwl_screen->egl_display != EGL_NO_DISPLAY) {
+        xwl_glamor_maybe_destroy_context(xwl_screen);
+        eglTerminate(xwl_screen->egl_display);
+        xwl_screen->egl_display = EGL_NO_DISPLAY;
+    }
+
+    xwl_glamor_gbm_cleanup(xwl_screen);
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_gbm_init_screen(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (!dri3_screen_init(xwl_screen->screen, &xwl_dri3_info)) {
+        ErrorF("Failed to initialize dri3\n");
+        goto error;
+    }
+
+    if (xwl_gbm->fd_render_node)
+        goto skip_drm_auth;
+
+    if (!dixRegisterPrivateKey(&xwl_auth_state_private_key, PRIVATE_CLIENT,
+                               0)) {
+        ErrorF("Failed to register private key\n");
+        goto error;
+    }
+
+    if (!AddCallback(&ClientStateCallback, xwl_auth_state_client_callback,
+                     NULL)) {
+        ErrorF("Failed to add client state callback\n");
+        goto error;
+    }
+
+skip_drm_auth:
+    xwl_screen->screen->CreatePixmap = xwl_glamor_gbm_create_pixmap;
+    xwl_screen->screen->DestroyPixmap = xwl_glamor_gbm_destroy_pixmap;
+
+    return TRUE;
+error:
+    xwl_glamor_gbm_cleanup(xwl_screen);
+    return FALSE;
+}
+
+static dev_t xwl_gbm_get_main_device(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    return xwl_gbm->device;
+}
+
+void
+xwl_glamor_init_gbm(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm;
+
+    xwl_screen->gbm_backend.is_available = FALSE;
+
+    if (!xwl_glamor_gbm_has_egl_extension())
+        return;
+
+    if (!dixRegisterPrivateKey(&xwl_gbm_private_key, PRIVATE_SCREEN, 0))
+        return;
+
+    xwl_gbm = calloc(sizeof(*xwl_gbm), 1);
+    if (!xwl_gbm) {
+        ErrorF("glamor: Not enough memory to setup GBM, disabling\n");
+        return;
+    }
+
+    dixSetPrivate(&xwl_screen->screen->devPrivates, &xwl_gbm_private_key,
+                  xwl_gbm);
+
+    xwl_screen->gbm_backend.init_wl_registry = xwl_glamor_gbm_init_wl_registry;
+    xwl_screen->gbm_backend.has_wl_interfaces = xwl_glamor_gbm_has_wl_interfaces;
+    xwl_screen->gbm_backend.init_egl = xwl_glamor_gbm_init_egl;
+    xwl_screen->gbm_backend.init_screen = xwl_glamor_gbm_init_screen;
+    xwl_screen->gbm_backend.get_wl_buffer_for_pixmap = xwl_glamor_gbm_get_wl_buffer_for_pixmap;
+    xwl_screen->gbm_backend.check_flip = NULL;
+    xwl_screen->gbm_backend.get_main_device = xwl_gbm_get_main_device;
+    xwl_screen->gbm_backend.is_available = TRUE;
+    xwl_screen->gbm_backend.backend_flags = XWL_EGL_BACKEND_NEEDS_BUFFER_FLUSH |
+                                            XWL_EGL_BACKEND_NEEDS_N_BUFFERING;
+}
diff --git a/hw/xwayland/xwayland-glamor-xv.c b/hw/xwayland/xwayland-glamor-xv.c
new file mode 100644
index 000000000..23e7100e4
--- /dev/null
+++ b/hw/xwayland/xwayland-glamor-xv.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
+ * Copyright © 2013 Red Hat
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2016 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *      Olivier Fourdan <ofourdan@redhat.com>
+ *
+ * Derived from the glamor_xf86_xv, ephyr_glamor_xv and xf86xv
+ * implementations
+ */
+
+#include <xwayland-config.h>
+
+#include "glamor_priv.h"
+
+#include <X11/extensions/Xv.h>
+
+#include "xwayland-glamor.h"
+
+#define NUM_FORMATS    3
+#define NUM_PORTS      16
+#define ADAPTOR_NAME   "glamor textured video"
+#define ENCODER_NAME   "XV_IMAGE"
+
+static DevPrivateKeyRec xwlXvScreenPrivateKeyRec;
+#define xwlXvScreenPrivateKey (&xwlXvScreenPrivateKeyRec)
+
+typedef struct {
+    XvAdaptorPtr glxv_adaptor; /* We have only one adaptor, glamor Xv */
+    glamor_port_private *port_privates;
+
+    CloseScreenProcPtr CloseScreen;
+} xwlXvScreenRec, *xwlXvScreenPtr;
+
+typedef struct {
+    char depth;
+    short class;
+} xwlVideoFormatRec, *xwlVideoFormatPtr;
+
+static xwlVideoFormatRec Formats[NUM_FORMATS] = {
+    {15, TrueColor},
+    {16, TrueColor},
+    {24, TrueColor}
+};
+
+static int
+xwl_glamor_xv_stop_video(XvPortPtr   pPort,
+                         DrawablePtr pDraw)
+{
+    glamor_port_private *gpp = (glamor_port_private *) (pPort->devPriv.ptr);
+
+    if (pDraw->type != DRAWABLE_WINDOW)
+        return BadAlloc;
+
+    glamor_xv_stop_video(gpp);
+
+    return Success;
+}
+
+static int
+xwl_glamor_xv_set_port_attribute(XvPortPtr pPort,
+                                 Atom      attribute,
+                                 INT32     value)
+{
+    glamor_port_private *gpp = (glamor_port_private *) (pPort->devPriv.ptr);
+
+    return glamor_xv_set_port_attribute(gpp, attribute, value);
+}
+
+static int
+xwl_glamor_xv_get_port_attribute(XvPortPtr pPort,
+                                 Atom      attribute,
+                                 INT32    *pValue)
+{
+    glamor_port_private *gpp = (glamor_port_private *) (pPort->devPriv.ptr);
+
+    return glamor_xv_get_port_attribute(gpp, attribute, pValue);
+}
+
+static int
+xwl_glamor_xv_query_best_size(XvPortPtr     pPort,
+                              CARD8         motion,
+                              CARD16        vid_w,
+                              CARD16        vid_h,
+                              CARD16        drw_w,
+                              CARD16        drw_h,
+                              unsigned int *p_w,
+                              unsigned int *p_h)
+{
+    *p_w = drw_w;
+    *p_h = drw_h;
+
+    return Success;
+}
+
+static int
+xwl_glamor_xv_query_image_attributes(XvPortPtr  pPort,
+                                     XvImagePtr format,
+                                     CARD16    *width,
+                                     CARD16    *height,
+                                     int       *pitches,
+                                     int       *offsets)
+{
+    return glamor_xv_query_image_attributes(format->id,
+                                            width,
+                                            height,
+                                            pitches,
+                                            offsets);
+}
+
+static int
+xwl_glamor_xv_put_image(DrawablePtr    pDrawable,
+                        XvPortPtr      pPort,
+                        GCPtr          pGC,
+                        INT16          src_x,
+                        INT16          src_y,
+                        CARD16         src_w,
+                        CARD16         src_h,
+                        INT16          drw_x,
+                        INT16          drw_y,
+                        CARD16         drw_w,
+                        CARD16         drw_h,
+                        XvImagePtr     format,
+                        unsigned char *data,
+                        Bool           sync,
+                        CARD16         width,
+                        CARD16         height)
+{
+    glamor_port_private *gpp = (glamor_port_private *) (pPort->devPriv.ptr);
+
+    RegionRec WinRegion;
+    RegionRec ClipRegion;
+    BoxRec WinBox;
+    int ret = Success;
+
+    if (pDrawable->type != DRAWABLE_WINDOW)
+        return BadWindow;
+
+    WinBox.x1 = pDrawable->x + drw_x;
+    WinBox.y1 = pDrawable->y + drw_y;
+    WinBox.x2 = WinBox.x1 + drw_w;
+    WinBox.y2 = WinBox.y1 + drw_h;
+
+    RegionInit(&WinRegion, &WinBox, 1);
+    RegionInit(&ClipRegion, NullBox, 1);
+    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);
+
+    if (RegionNotEmpty(&ClipRegion))
+        ret = glamor_xv_put_image(gpp,
+                                  pDrawable,
+                                  src_x,
+                                  src_y,
+                                  pDrawable->x + drw_x,
+                                  pDrawable->y + drw_y,
+                                  src_w,
+                                  src_h,
+                                  drw_w,
+                                  drw_h,
+                                  format->id,
+                                  data,
+                                  width,
+                                  height,
+                                  sync,
+                                  &ClipRegion);
+
+     RegionUninit(&WinRegion);
+     RegionUninit(&ClipRegion);
+
+     return ret;
+
+}
+
+static Bool
+xwl_glamor_xv_add_formats(XvAdaptorPtr pa)
+{
+    ScreenPtr pScreen;
+    XvFormatPtr pFormat, pf;
+    VisualPtr pVisual;
+    int numFormat;
+    int totFormat;
+    int numVisuals;
+    int i;
+
+    totFormat = NUM_FORMATS;
+    pFormat = xnfcalloc(totFormat, sizeof(XvFormatRec));
+    pScreen = pa->pScreen;
+    for (pf = pFormat, i = 0, numFormat = 0; i < NUM_FORMATS; i++) {
+        numVisuals = pScreen->numVisuals;
+        pVisual = pScreen->visuals;
+
+        while (numVisuals--) {
+           if ((pVisual->class == Formats[i].class) &&
+               (pVisual->nplanes == Formats[i].depth)) {
+                    if (numFormat >= totFormat) {
+                        void *moreSpace;
+
+                        totFormat *= 2;
+                        moreSpace = xnfreallocarray(pFormat, totFormat,
+                                                    sizeof(XvFormatRec));
+                        pFormat = moreSpace;
+                        pf = pFormat + numFormat;
+                    }
+
+                    pf->visual = pVisual->vid;
+                    pf->depth = Formats[i].depth;
+
+                    pf++;
+                    numFormat++;
+                }
+            pVisual++;
+        }
+    }
+    pa->nFormats = numFormat;
+    pa->pFormats = pFormat;
+
+    return numFormat != 0;
+}
+
+static Bool
+xwl_glamor_xv_add_ports(XvAdaptorPtr pa)
+{
+    XvPortPtr pPorts, pp;
+    xwlXvScreenPtr xwlXvScreen;
+    unsigned long PortResource = 0;
+    int nPorts;
+    int i;
+
+    pPorts = xnfcalloc(NUM_PORTS, sizeof(XvPortRec));
+    xwlXvScreen = dixLookupPrivate(&(pa->pScreen)->devPrivates,
+                                   xwlXvScreenPrivateKey);
+    xwlXvScreen->port_privates = xnfcalloc(NUM_PORTS,
+                                           sizeof(glamor_port_private));
+
+    PortResource = XvGetRTPort();
+    for (pp = pPorts, i = 0, nPorts = 0; i < NUM_PORTS; i++) {
+        if (!(pp->id = FakeClientID(0)))
+            continue;
+
+        pp->pAdaptor = pa;
+
+        glamor_xv_init_port(&xwlXvScreen->port_privates[i]);
+        pp->devPriv.ptr = &xwlXvScreen->port_privates[i];
+
+        if (AddResource(pp->id, PortResource, pp)) {
+            pp++;
+            nPorts++;
+        }
+    }
+
+    pa->base_id = pPorts->id;
+    pa->nPorts = nPorts;
+    pa->pPorts = pPorts;
+
+    return nPorts != 0;
+}
+
+static void
+xwl_glamor_xv_add_attributes(XvAdaptorPtr pa)
+{
+    int i;
+
+    pa->pAttributes = xnfcalloc(glamor_xv_num_attributes, sizeof(XvAttributeRec));
+    memcpy(pa->pAttributes, glamor_xv_attributes,
+           glamor_xv_num_attributes * sizeof(XvAttributeRec));
+
+    for (i = 0; i < glamor_xv_num_attributes; i++)
+        pa->pAttributes[i].name = strdup(glamor_xv_attributes[i].name);
+
+    pa->nAttributes = glamor_xv_num_attributes;
+}
+
+static void
+xwl_glamor_xv_add_images(XvAdaptorPtr pa)
+{
+    pa->pImages = xnfcalloc(glamor_xv_num_images, sizeof(XvImageRec));
+    memcpy(pa->pImages, glamor_xv_images, glamor_xv_num_images * sizeof(XvImageRec));
+
+    pa->nImages = glamor_xv_num_images;
+}
+
+static void
+xwl_glamor_xv_add_encodings(XvAdaptorPtr pa)
+{
+    XvEncodingPtr pe;
+    GLint texsize;
+
+    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &texsize);
+
+    pe = xnfcalloc(1, sizeof(XvEncodingRec));
+    pe->id = 0;
+    pe->pScreen = pa->pScreen;
+    pe->name = strdup(ENCODER_NAME);
+    pe->width = texsize;
+    pe->height = texsize;
+    pe->rate.numerator = 1;
+    pe->rate.denominator = 1;
+
+    pa->pEncodings = pe;
+    pa->nEncodings = 1;
+}
+
+static Bool
+xwl_glamor_xv_add_adaptors(ScreenPtr pScreen)
+{
+    DevPrivateKey XvScreenKey;
+    XvScreenPtr XvScreen;
+    xwlXvScreenPtr xwlXvScreen;
+    XvAdaptorPtr pa;
+
+    if (XvScreenInit(pScreen) != Success)
+        return FALSE;
+
+    XvScreenKey = XvGetScreenKey();
+    XvScreen = dixLookupPrivate(&(pScreen)->devPrivates, XvScreenKey);
+
+    XvScreen->nAdaptors = 0;
+    XvScreen->pAdaptors = NULL;
+
+    pa = xnfcalloc(1, sizeof(XvAdaptorRec));
+    pa->pScreen = pScreen;
+    pa->type = (unsigned char) (XvInputMask | XvImageMask);
+    pa->ddStopVideo = xwl_glamor_xv_stop_video;
+    pa->ddPutImage = xwl_glamor_xv_put_image;
+    pa->ddSetPortAttribute = xwl_glamor_xv_set_port_attribute;
+    pa->ddGetPortAttribute = xwl_glamor_xv_get_port_attribute;
+    pa->ddQueryBestSize = xwl_glamor_xv_query_best_size;
+    pa->ddQueryImageAttributes = xwl_glamor_xv_query_image_attributes;
+    pa->name = strdup(ADAPTOR_NAME);
+
+    xwl_glamor_xv_add_encodings(pa);
+    xwl_glamor_xv_add_images(pa);
+    xwl_glamor_xv_add_attributes(pa);
+    if (!xwl_glamor_xv_add_formats(pa))
+        goto failed;
+    if (!xwl_glamor_xv_add_ports(pa))
+        goto failed;
+
+    /* We're good now with out Xv adaptor */
+    XvScreen->nAdaptors = 1;
+    XvScreen->pAdaptors = pa;
+
+    xwlXvScreen = dixLookupPrivate(&(pa->pScreen)->devPrivates,
+                                   xwlXvScreenPrivateKey);
+    xwlXvScreen->glxv_adaptor = pa;
+
+    return TRUE;
+
+failed:
+    XvFreeAdaptor(pa);
+    free(pa);
+
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_xv_close_screen(ScreenPtr pScreen)
+{
+    xwlXvScreenPtr xwlXvScreen;
+
+    xwlXvScreen = dixLookupPrivate(&(pScreen)->devPrivates,
+                                   xwlXvScreenPrivateKey);
+
+    if (xwlXvScreen->glxv_adaptor) {
+        XvFreeAdaptor(xwlXvScreen->glxv_adaptor);
+        free(xwlXvScreen->glxv_adaptor);
+    }
+    free(xwlXvScreen->port_privates);
+
+    pScreen->CloseScreen = xwlXvScreen->CloseScreen;
+
+    return pScreen->CloseScreen(pScreen);
+}
+
+Bool
+xwl_glamor_xv_init(ScreenPtr pScreen)
+{
+    xwlXvScreenPtr xwlXvScreen;
+
+    if (!dixRegisterPrivateKey(xwlXvScreenPrivateKey, PRIVATE_SCREEN,
+                               sizeof(xwlXvScreenRec)))
+        return FALSE;
+
+    xwlXvScreen = dixLookupPrivate(&(pScreen)->devPrivates,
+                                    xwlXvScreenPrivateKey);
+
+    xwlXvScreen->port_privates = NULL;
+    xwlXvScreen->glxv_adaptor = NULL;
+    xwlXvScreen->CloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = xwl_glamor_xv_close_screen;
+
+    glamor_xv_core_init(pScreen);
+
+    return xwl_glamor_xv_add_adaptors(pScreen);
+}
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
new file mode 100644
index 000000000..6c7784efb
--- /dev/null
+++ b/hw/xwayland/xwayland-glamor.c
@@ -0,0 +1,918 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#define EGL_NO_X11
+#include <glamor_egl.h>
+
+#include <glamor.h>
+#include <glamor_context.h>
+#ifdef GLXEXT
+#include "glx_extinit.h"
+#endif
+
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "drm-client-protocol.h"
+#include <drm_fourcc.h>
+
+#include "xwayland-glamor.h"
+#include "xwayland-glx.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+
+#include <sys/mman.h>
+
+static void
+glamor_egl_make_current(struct glamor_context *glamor_ctx)
+{
+    eglMakeCurrent(glamor_ctx->display, EGL_NO_SURFACE,
+                   EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    if (!eglMakeCurrent(glamor_ctx->display,
+                        EGL_NO_SURFACE, EGL_NO_SURFACE,
+                        glamor_ctx->ctx))
+        FatalError("Failed to make EGL context current\n");
+}
+
+void
+xwl_glamor_egl_make_current(struct xwl_screen *xwl_screen)
+{
+    EGLContext ctx = xwl_screen->glamor_ctx->ctx;
+    
+    if (lastGLContext == ctx)
+        return;
+
+    lastGLContext = ctx;
+    xwl_screen->glamor_ctx->make_current(xwl_screen->glamor_ctx);
+}
+
+void
+glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+
+    glamor_enable_dri3(screen);
+    glamor_ctx->ctx = xwl_screen->egl_context;
+    glamor_ctx->display = xwl_screen->egl_display;
+
+    glamor_ctx->make_current = glamor_egl_make_current;
+
+    xwl_screen->glamor_ctx = glamor_ctx;
+}
+
+Bool
+xwl_glamor_check_flip(PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+
+    if (!xwl_glamor_pixmap_get_wl_buffer(pixmap))
+        return FALSE;
+
+    if (xwl_screen->egl_backend->check_flip)
+        return xwl_screen->egl_backend->check_flip(pixmap);
+
+    return TRUE;
+}
+
+static Bool
+xwl_glamor_is_modifier_supported_in_formats(struct xwl_format *formats, int num_formats,
+                                            uint32_t format, uint64_t modifier)
+{
+    struct xwl_format *xwl_format = NULL;
+    int i;
+
+    for (i = 0; i < num_formats; i++) {
+        if (formats[i].format == format) {
+            xwl_format = &formats[i];
+            break;
+        }
+    }
+
+    if (xwl_format) {
+        for (i = 0; i < xwl_format->num_modifiers; i++) {
+            if (xwl_format->modifiers[i] == modifier) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+
+static Bool
+xwl_feedback_is_modifier_supported(struct xwl_dmabuf_feedback *xwl_feedback,
+                                   uint32_t format, uint64_t modifier)
+{
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        struct xwl_device_formats *dev_formats = &xwl_feedback->dev_formats[i];
+
+        if (xwl_glamor_is_modifier_supported_in_formats(dev_formats->formats,
+                                                        dev_formats->num_formats,
+                                                        format, modifier))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+Bool
+xwl_glamor_is_modifier_supported(struct xwl_screen *xwl_screen,
+                                 uint32_t format, uint64_t modifier)
+{
+    struct xwl_window *xwl_window;
+
+    /*
+     * If we are using dmabuf v4, then we need to check in the main
+     * device and per-window format lists. For older protocol
+     * versions we can just check the list returned by the dmabuf.modifier
+     * events in xwl_screen
+     */
+    if (xwl_screen->dmabuf_protocol_version < 4) {
+        return xwl_glamor_is_modifier_supported_in_formats(xwl_screen->formats,
+                                                           xwl_screen->num_formats,
+                                                           format, modifier);
+    }
+
+    if (xwl_feedback_is_modifier_supported(&xwl_screen->default_feedback, format, modifier))
+        return TRUE;
+
+    xorg_list_for_each_entry(xwl_window, &xwl_screen->window_list, link_window) {
+        if (xwl_feedback_is_modifier_supported(&xwl_window->feedback, format, modifier))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+uint32_t
+wl_drm_format_for_depth(int depth)
+{
+    switch (depth) {
+    case 15:
+        return WL_DRM_FORMAT_XRGB1555;
+    case 16:
+        return WL_DRM_FORMAT_RGB565;
+    case 24:
+        return WL_DRM_FORMAT_XRGB8888;
+    case 30:
+        return WL_DRM_FORMAT_ARGB2101010;
+    default:
+        ErrorF("unexpected depth: %d\n", depth);
+    case 32:
+        return WL_DRM_FORMAT_ARGB8888;
+    }
+}
+
+static dev_t
+xwl_screen_get_main_dev(struct xwl_screen *xwl_screen)
+{
+    /*
+     * If we have gbm then get our main device from it. Otherwise use what
+     * the compositor told us.
+     */
+    if (xwl_screen->gbm_backend.is_available)
+        return xwl_screen->gbm_backend.get_main_device(xwl_screen);
+    else
+        return xwl_screen->default_feedback.main_dev;
+}
+
+static Bool
+xwl_get_formats(struct xwl_format *format_array, int format_array_len,
+               uint32_t *num_formats, uint32_t **formats)
+{
+    *num_formats = 0;
+    *formats = NULL;
+
+    if (format_array_len == 0)
+       return TRUE;
+
+    *formats = calloc(format_array_len, sizeof(CARD32));
+    if (*formats == NULL)
+        return FALSE;
+
+    for (int i = 0; i < format_array_len; i++)
+       (*formats)[i] = format_array[i].format;
+    *num_formats = format_array_len;
+
+    return TRUE;
+}
+
+static Bool
+xwl_get_formats_for_device(struct xwl_dmabuf_feedback *xwl_feedback, dev_t device,
+                           uint32_t *num_formats, uint32_t **formats)
+{
+    uint32_t *ret = NULL;
+    uint32_t count = 0;
+
+    /* go through all matching sets of tranches for the window's device */
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        if (xwl_feedback->dev_formats[i].drm_dev == device) {
+            struct xwl_device_formats *dev_formats = &xwl_feedback->dev_formats[i];
+
+            /* Append the formats from this tranche to the list */
+            ret = xnfreallocarray(ret, count + dev_formats->num_formats, sizeof(CARD32));
+
+            for (int j = 0; j < dev_formats->num_formats; j++) {
+                bool found = false;
+
+                /* Check if this format is already present in the list */
+                for (int k = 0; k < count; k++) {
+                    if (ret[k] == dev_formats->formats[j].format) {
+                        found = true;
+                        break;
+                    }
+                }
+
+                /* If this format has not yet been added, do so now */
+                if (!found)
+                    ret[count++] = dev_formats->formats[j].format;
+            }
+        }
+    }
+
+    *num_formats = count;
+    *formats = ret;
+
+    return TRUE;
+}
+
+Bool
+xwl_glamor_get_formats(ScreenPtr screen,
+                       CARD32 *num_formats, CARD32 **formats)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+
+    /* Explicitly zero the count as the caller may ignore the return value */
+    *num_formats = 0;
+
+    if (!xwl_screen->dmabuf)
+        return FALSE;
+
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        dev_t main_dev = xwl_screen_get_main_dev(xwl_screen);
+
+        return xwl_get_formats_for_device(&xwl_screen->default_feedback, main_dev,
+                                          num_formats, formats);
+    }
+
+    return xwl_get_formats(xwl_screen->formats, xwl_screen->num_formats,
+                           num_formats, formats);
+}
+
+static Bool
+xwl_get_modifiers_for_format(struct xwl_format *format_array, int num_formats,
+                             uint32_t format, uint32_t *num_modifiers, uint64_t **modifiers)
+{
+    struct xwl_format *xwl_format = NULL;
+    int i;
+
+    *num_modifiers = 0;
+    *modifiers = NULL;
+
+    if (num_formats == 0)
+       return TRUE;
+
+    for (i = 0; i < num_formats; i++) {
+       if (format_array[i].format == format) {
+          xwl_format = &format_array[i];
+          break;
+       }
+    }
+
+    if (!xwl_format ||
+        (xwl_format->num_modifiers == 1 &&
+         xwl_format->modifiers[0] == DRM_FORMAT_MOD_INVALID))
+        return FALSE;
+
+    *modifiers = calloc(xwl_format->num_modifiers, sizeof(uint64_t));
+    if (*modifiers == NULL)
+        return FALSE;
+
+    for (i = 0; i < xwl_format->num_modifiers; i++)
+       (*modifiers)[i] = xwl_format->modifiers[i];
+    *num_modifiers = xwl_format->num_modifiers;
+
+    return TRUE;
+}
+
+static Bool
+xwl_get_modifiers_for_device(struct xwl_dmabuf_feedback *feedback, dev_t device,
+                             uint32_t format, uint32_t *num_modifiers,
+                             uint64_t **modifiers)
+{
+    /* Now try to find a matching set of tranches for the window's device */
+    for (int i = 0; i < feedback->dev_formats_len; i++) {
+        struct xwl_device_formats *dev_formats = &feedback->dev_formats[i];
+
+        if (dev_formats->drm_dev == device &&
+            xwl_get_modifiers_for_format(dev_formats->formats, dev_formats->num_formats,
+                                         format, num_modifiers, modifiers))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+Bool
+xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
+                         uint32_t *num_modifiers, uint64_t **modifiers)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    dev_t main_dev;
+
+    /* Explicitly zero the count as the caller may ignore the return value */
+    *num_modifiers = 0;
+    *modifiers = NULL;
+
+    if (!xwl_screen->dmabuf)
+        return FALSE;
+
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        main_dev = xwl_screen_get_main_dev(xwl_screen);
+
+        return xwl_get_modifiers_for_device(&xwl_screen->default_feedback, main_dev,
+                                            format, num_modifiers, modifiers);
+    } else {
+        return xwl_get_modifiers_for_format(xwl_screen->formats, xwl_screen->num_formats,
+                                            format, num_modifiers, modifiers);
+    }
+}
+
+Bool
+xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
+                                  uint32_t *num_modifiers, uint64_t **modifiers)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(drawable->pScreen);
+    struct xwl_window *xwl_window;
+    dev_t main_dev;
+
+    *num_modifiers = 0;
+    *modifiers = NULL;
+
+    /* We can only return per-drawable modifiers if the compositor supports feedback */
+    if (xwl_screen->dmabuf_protocol_version < 4)
+        return TRUE;
+
+    if (drawable->type != DRAWABLE_WINDOW || !xwl_screen->dmabuf)
+        return FALSE;
+
+    xwl_window = xwl_window_from_window((WindowPtr)drawable);
+
+    /* couldn't find drawable for window */
+    if (!xwl_window)
+        return FALSE;
+
+    main_dev = xwl_screen_get_main_dev(xwl_screen);
+
+    return xwl_get_modifiers_for_device(&xwl_window->feedback, main_dev,
+                                        format, num_modifiers, modifiers);
+
+}
+
+static void
+xwl_dmabuf_handle_format(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
+                         uint32_t format)
+{
+}
+
+static void
+xwl_add_format_and_mod_to_list(struct xwl_format **formats,
+                               uint32_t *num_formats,
+                               uint32_t format,
+                               uint64_t modifier)
+{
+    struct xwl_format *xwl_format = NULL;
+    int i;
+
+    for (i = 0; i < *num_formats; i++) {
+        if ((*formats)[i].format == format) {
+            xwl_format = &(*formats)[i];
+            break;
+        }
+    }
+
+    if (xwl_format == NULL) {
+        (*num_formats)++;
+        *formats = xnfrealloc(*formats, *num_formats * sizeof(*xwl_format));
+        xwl_format = &(*formats)[*num_formats - 1];
+        xwl_format->format = format;
+        xwl_format->num_modifiers = 0;
+        xwl_format->modifiers = NULL;
+    }
+
+    for (i = 0; i < xwl_format->num_modifiers; i++) {
+        /* don't add it if the modifier already exists */
+        if (xwl_format->modifiers[i] == modifier)
+            return;
+    }
+
+    xwl_format->num_modifiers++;
+    xwl_format->modifiers = xnfrealloc(xwl_format->modifiers,
+                                       xwl_format->num_modifiers * sizeof(uint64_t));
+    xwl_format->modifiers[xwl_format->num_modifiers - 1]  = modifier;
+}
+
+static void
+xwl_dmabuf_handle_modifier(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
+                           uint32_t format, uint32_t modifier_hi,
+                           uint32_t modifier_lo)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    xwl_add_format_and_mod_to_list(&xwl_screen->formats, &xwl_screen->num_formats,
+                                   format,
+                                   ((uint64_t)modifier_hi << 32 | (uint64_t)modifier_lo));
+}
+
+static const struct zwp_linux_dmabuf_v1_listener xwl_dmabuf_listener = {
+    .format = xwl_dmabuf_handle_format,
+    .modifier = xwl_dmabuf_handle_modifier
+};
+
+/*
+ * We need to check if the compositor is resending all of the tranche
+ * information. Each tranche event will call this method to see
+ * if the existing format info should be cleared before refilling.
+ */
+static void
+xwl_check_reset_tranche_info(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    if (!xwl_feedback->feedback_done)
+        return;
+
+    xwl_feedback->feedback_done = false;
+
+    xwl_dmabuf_feedback_clear_dev_formats(xwl_feedback);
+}
+
+static void
+xwl_dmabuf_feedback_main_device(void *data,
+                                struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                struct wl_array *dev)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    assert(dev->size == sizeof(dev_t));
+    memcpy(&xwl_feedback->main_dev, dev->data, sizeof(dev_t));
+}
+
+static void
+xwl_dmabuf_feedback_tranche_target_device(void *data,
+                                          struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                          struct wl_array *dev)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    assert(dev->size == sizeof(dev_t));
+    memcpy(&xwl_feedback->tmp_tranche.drm_dev, dev->data, sizeof(dev_t));
+}
+
+static void
+xwl_dmabuf_feedback_tranche_flags(void *data,
+                                  struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                  uint32_t flags)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    if (flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
+        xwl_feedback->tmp_tranche.supports_scanout = true;
+}
+
+static void
+xwl_dmabuf_feedback_tranche_formats(void *data,
+                                    struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                    struct wl_array *indices)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    struct xwl_device_formats *tranche = &xwl_feedback->tmp_tranche;
+    uint16_t *index;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    wl_array_for_each(index, indices) {
+        if (*index >= xwl_feedback->format_table.len) {
+            ErrorF("linux_dmabuf_feedback.tranche_formats: Index given to us by the compositor"
+                   " is too large to fit in the format table\n");
+            continue;
+        }
+
+        /* Look up this format/mod in the format table */
+        struct xwl_format_table_entry *entry = &xwl_feedback->format_table.entry[*index];
+
+        /* Add it to the in-progress tranche */
+        xwl_add_format_and_mod_to_list(&tranche->formats, &tranche->num_formats,
+                                       entry->format,
+                                       entry->modifier);
+    }
+}
+
+static void
+xwl_append_to_tranche(struct xwl_device_formats *dst, struct xwl_device_formats *src)
+{
+    struct xwl_format *format;
+
+    for (int i = 0; i < src->num_formats; i++) {
+        format = &src->formats[i];
+
+        for (int j = 0; j < format->num_modifiers; j++)
+            xwl_add_format_and_mod_to_list(&dst->formats, &dst->num_formats,
+                                           format->format,
+                                           format->modifiers[j]);
+    }
+}
+
+static void
+xwl_dmabuf_feedback_tranche_done(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    struct xwl_device_formats *tranche;
+    int appended = false;
+
+    /*
+     * No need to call xwl_check_reset_tranche_info, the other events should have been
+     * triggered first
+     */
+
+    /*
+     * First check if there is an existing tranche for this device+flags combo. We
+     * will combine it with this tranche, since we can only send one modifier list
+     * in DRI3 but the compositor may report multiple tranches per device (KDE
+     * does this)
+     */
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        tranche = &xwl_feedback->dev_formats[i];
+        if (tranche->drm_dev == xwl_feedback->tmp_tranche.drm_dev &&
+            tranche->supports_scanout == xwl_feedback->tmp_tranche.supports_scanout) {
+            appended = true;
+
+            /* Add all format/mods to this tranche */
+            xwl_append_to_tranche(tranche, &xwl_feedback->tmp_tranche);
+
+            /* Now free our temp tranche's allocations */
+            xwl_device_formats_destroy(&xwl_feedback->tmp_tranche);
+
+            break;
+        }
+    }
+
+    if (!appended) {
+        xwl_feedback->dev_formats_len++;
+        xwl_feedback->dev_formats = xnfrealloc(xwl_feedback->dev_formats,
+                                               sizeof(struct xwl_device_formats) *
+                                               xwl_feedback->dev_formats_len);
+
+        /* copy the temporary tranche into the official array */
+        memcpy(&xwl_feedback->dev_formats[xwl_feedback->dev_formats_len - 1],
+               &xwl_feedback->tmp_tranche,
+               sizeof(struct xwl_device_formats));
+    }
+
+    /* reset the tranche */
+    memset(&xwl_feedback->tmp_tranche, 0, sizeof(struct xwl_device_formats));
+}
+
+static void
+xwl_dmabuf_feedback_done(void *data, struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_feedback->feedback_done = true;
+    xwl_feedback->unprocessed_feedback_pending = true;
+}
+
+static void
+xwl_dmabuf_feedback_format_table(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                 int32_t fd, uint32_t size)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    /* Unmap the old table */
+    if (xwl_feedback->format_table.entry) {
+        munmap(xwl_feedback->format_table.entry,
+               xwl_feedback->format_table.len * sizeof(struct xwl_format_table_entry));
+    }
+
+    assert(size % sizeof(struct xwl_format_table_entry) == 0);
+    xwl_feedback->format_table.len = size / sizeof(struct xwl_format_table_entry);
+    xwl_feedback->format_table.entry = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    close(fd);
+
+    if (xwl_feedback->format_table.entry == MAP_FAILED) {
+        ErrorF("linux_dmabuf_feedback.format_table: Could not map the format"
+               " table: Compositor bug or out of resources\n");
+        xwl_feedback->format_table.len = 0;
+    }
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener xwl_dmabuf_feedback_listener = {
+    .done = xwl_dmabuf_feedback_done,
+    .format_table = xwl_dmabuf_feedback_format_table,
+    .main_device = xwl_dmabuf_feedback_main_device,
+    .tranche_done = xwl_dmabuf_feedback_tranche_done,
+    .tranche_target_device = xwl_dmabuf_feedback_tranche_target_device,
+    .tranche_formats = xwl_dmabuf_feedback_tranche_formats,
+    .tranche_flags = xwl_dmabuf_feedback_tranche_flags,
+};
+
+Bool
+xwl_dmabuf_setup_feedback_for_window(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    xwl_window->feedback.dmabuf_feedback =
+        zwp_linux_dmabuf_v1_get_surface_feedback(xwl_screen->dmabuf, xwl_window->surface);
+
+    if (!xwl_window->feedback.dmabuf_feedback)
+        return FALSE;
+
+    zwp_linux_dmabuf_feedback_v1_add_listener(xwl_window->feedback.dmabuf_feedback,
+                                              &xwl_dmabuf_feedback_listener,
+                                              &xwl_window->feedback);
+
+    return TRUE;
+}
+
+Bool
+xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
+                                uint32_t id, uint32_t version)
+{
+    /* We either support versions 3 or 4. 4 is needed for dmabuf feedback */
+    int supported_version = version >= 4 ? 4 : 3;
+
+    if (version < 3)
+        return FALSE;
+
+    xwl_screen->dmabuf =
+        wl_registry_bind(xwl_screen->registry, id, &zwp_linux_dmabuf_v1_interface, supported_version);
+    xwl_screen->dmabuf_protocol_version = supported_version;
+    zwp_linux_dmabuf_v1_add_listener(xwl_screen->dmabuf, &xwl_dmabuf_listener, xwl_screen);
+
+    /* If the compositor supports it, request the default feedback hints */
+    if (version >= 4) {
+        xwl_screen->default_feedback.dmabuf_feedback =
+            zwp_linux_dmabuf_v1_get_default_feedback(xwl_screen->dmabuf);
+        if (!xwl_screen->default_feedback.dmabuf_feedback)
+            return FALSE;
+
+        zwp_linux_dmabuf_feedback_v1_add_listener(xwl_screen->default_feedback.dmabuf_feedback,
+                                                  &xwl_dmabuf_feedback_listener,
+                                                  &xwl_screen->default_feedback);
+    }
+
+    return TRUE;
+}
+
+void
+xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
+                            struct wl_registry *registry,
+                            uint32_t id, const char *interface,
+                            uint32_t version)
+{
+    if (xwl_screen->gbm_backend.is_available &&
+        xwl_screen->gbm_backend.init_wl_registry(xwl_screen,
+                                                 registry,
+                                                 id,
+                                                 interface,
+                                                 version)) {
+        /* no-op */
+    } else if (xwl_screen->eglstream_backend.is_available &&
+               xwl_screen->eglstream_backend.init_wl_registry(xwl_screen,
+                                                              registry,
+                                                              id,
+                                                              interface,
+                                                              version)) {
+        /* no-op */
+    }
+}
+
+Bool
+xwl_glamor_has_wl_interfaces(struct xwl_screen *xwl_screen,
+                            struct xwl_egl_backend *xwl_egl_backend)
+{
+    return xwl_egl_backend->has_wl_interfaces(xwl_screen);
+}
+
+struct wl_buffer *
+xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+
+    if (xwl_screen->egl_backend->get_wl_buffer_for_pixmap)
+        return xwl_screen->egl_backend->get_wl_buffer_for_pixmap(pixmap);
+
+    return NULL;
+}
+
+Bool
+xwl_glamor_post_damage(struct xwl_window *xwl_window,
+                       PixmapPtr pixmap, RegionPtr region)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (xwl_screen->egl_backend->post_damage)
+        return xwl_screen->egl_backend->post_damage(xwl_window, pixmap, region);
+
+    return TRUE;
+}
+
+Bool
+xwl_glamor_allow_commits(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (xwl_screen->egl_backend->allow_commits)
+        return xwl_screen->egl_backend->allow_commits(xwl_window);
+    else
+        return TRUE;
+}
+
+static Bool
+xwl_glamor_create_screen_resources(ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    int ret;
+
+    screen->CreateScreenResources = xwl_screen->CreateScreenResources;
+    ret = (*screen->CreateScreenResources) (screen);
+    xwl_screen->CreateScreenResources = screen->CreateScreenResources;
+    screen->CreateScreenResources = xwl_glamor_create_screen_resources;
+
+    if (!ret)
+        return ret;
+
+    if (xwl_screen->rootless) {
+        screen->devPrivate =
+            fbCreatePixmap(screen, 0, 0, screen->rootDepth, 0);
+    }
+    else {
+        screen->devPrivate = screen->CreatePixmap(
+            screen, screen->width, screen->height, screen->rootDepth,
+            CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    }
+
+    SetRootClip(screen, xwl_screen->root_clip_mode);
+
+    return screen->devPrivate != NULL;
+}
+
+int
+glamor_egl_fd_name_from_pixmap(ScreenPtr screen,
+                               PixmapPtr pixmap,
+                               CARD16 *stride, CARD32 *size)
+{
+    return 0;
+}
+
+Bool
+xwl_glamor_needs_buffer_flush(struct xwl_screen *xwl_screen)
+{
+    if (!xwl_screen->glamor || !xwl_screen->egl_backend)
+        return FALSE;
+
+    return (xwl_screen->egl_backend->backend_flags &
+                XWL_EGL_BACKEND_NEEDS_BUFFER_FLUSH);
+}
+
+Bool
+xwl_glamor_needs_n_buffering(struct xwl_screen *xwl_screen)
+{
+    /* wl_shm benefits from n-buffering */
+    if (!xwl_screen->glamor || !xwl_screen->egl_backend)
+        return TRUE;
+
+    return (xwl_screen->egl_backend->backend_flags &
+                XWL_EGL_BACKEND_NEEDS_N_BUFFERING);
+}
+
+void
+xwl_glamor_init_backends(struct xwl_screen *xwl_screen, Bool use_eglstream)
+{
+#ifdef GLAMOR_HAS_GBM
+    xwl_glamor_init_gbm(xwl_screen);
+    if (!xwl_screen->gbm_backend.is_available && !use_eglstream)
+        ErrorF("xwayland glamor: GBM backend (default) is not available\n");
+#endif
+#ifdef XWL_HAS_EGLSTREAM
+    xwl_glamor_init_eglstream(xwl_screen);
+    if (!xwl_screen->eglstream_backend.is_available && use_eglstream)
+        ErrorF("xwayland glamor: EGLStream backend requested but not available\n");
+#endif
+}
+
+static Bool
+xwl_glamor_select_gbm_backend(struct xwl_screen *xwl_screen)
+{
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_screen->gbm_backend.is_available &&
+        xwl_glamor_has_wl_interfaces(xwl_screen, &xwl_screen->gbm_backend)) {
+        xwl_screen->egl_backend = &xwl_screen->gbm_backend;
+        LogMessageVerb(X_INFO, 3, "glamor: Using GBM backend\n");
+        return TRUE;
+    }
+    else
+        LogMessageVerb(X_INFO, 3,
+                       "Missing Wayland requirements for glamor GBM backend\n");
+#endif
+
+    return FALSE;
+}
+
+static Bool
+xwl_glamor_select_eglstream_backend(struct xwl_screen *xwl_screen)
+{
+#ifdef XWL_HAS_EGLSTREAM
+    if (xwl_screen->eglstream_backend.is_available &&
+        xwl_glamor_has_wl_interfaces(xwl_screen, &xwl_screen->eglstream_backend)) {
+        xwl_screen->egl_backend = &xwl_screen->eglstream_backend;
+        LogMessageVerb(X_INFO, 3, "glamor: Using EGLStream backend\n");
+        return TRUE;
+    }
+    else
+        LogMessageVerb(X_INFO, 3,
+                       "Missing Wayland requirements for glamor EGLStream backend\n");
+#endif
+
+    return FALSE;
+}
+
+void
+xwl_glamor_select_backend(struct xwl_screen *xwl_screen, Bool use_eglstream)
+{
+    if (!xwl_glamor_select_eglstream_backend(xwl_screen)) {
+        if (!use_eglstream)
+            xwl_glamor_select_gbm_backend(xwl_screen);
+    }
+}
+
+Bool
+xwl_glamor_init(struct xwl_screen *xwl_screen)
+{
+    ScreenPtr screen = xwl_screen->screen;
+    const char *no_glamor_env;
+
+    no_glamor_env = getenv("XWAYLAND_NO_GLAMOR");
+    if (no_glamor_env && *no_glamor_env != '0') {
+        ErrorF("Disabling glamor and dri3 support, XWAYLAND_NO_GLAMOR is set\n");
+        return FALSE;
+    }
+
+    if (!xwl_screen->egl_backend->init_egl(xwl_screen)) {
+        ErrorF("EGL setup failed, disabling glamor\n");
+        return FALSE;
+    }
+
+    if (!glamor_init(xwl_screen->screen, GLAMOR_USE_EGL_SCREEN)) {
+        ErrorF("Failed to initialize glamor\n");
+        return FALSE;
+    }
+
+    if (!xwl_screen->egl_backend->init_screen(xwl_screen)) {
+        ErrorF("EGL backend init_screen() failed, disabling glamor\n");
+        return FALSE;
+    }
+
+    xwl_screen->CreateScreenResources = screen->CreateScreenResources;
+    screen->CreateScreenResources = xwl_glamor_create_screen_resources;
+
+#ifdef XV
+    if (!xwl_glamor_xv_init(screen))
+        ErrorF("Failed to initialize glamor Xv extension\n");
+#endif
+
+#ifdef GLXEXT
+    GlxPushProvider(&glamor_provider);
+#endif
+
+    return TRUE;
+}
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
new file mode 100644
index 000000000..ed9ec40de
--- /dev/null
+++ b/hw/xwayland/xwayland-glamor.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_GLAMOR_H
+#define XWAYLAND_GLAMOR_H
+
+#include <xwayland-config.h>
+
+#include <wayland-client.h>
+
+#include "xwayland-types.h"
+
+typedef enum _xwl_egl_backend_flags {
+    XWL_EGL_BACKEND_NO_FLAG = 0,
+    XWL_EGL_BACKEND_NEEDS_BUFFER_FLUSH = (1 << 0),
+    XWL_EGL_BACKEND_NEEDS_N_BUFFERING = (1 << 1),
+} xwl_egl_backend_flags;
+
+struct xwl_egl_backend {
+    /* Set by the backend if available */
+    Bool is_available;
+
+    /* Features and requirements set by the backend */
+    xwl_egl_backend_flags backend_flags;
+
+    /* Called once for each interface in the global registry. Backends
+     * should use this to bind to any wayland interfaces they need.
+     */
+    Bool (*init_wl_registry)(struct xwl_screen *xwl_screen,
+                             struct wl_registry *wl_registry,
+                             uint32_t id, const char *name,
+                             uint32_t version);
+
+    /* Check that the required Wayland interfaces are available.
+     */
+    Bool (*has_wl_interfaces)(struct xwl_screen *xwl_screen);
+
+    /* Called before glamor has been initialized. Backends should setup a
+     * valid, glamor compatible EGL context in this hook.
+     */
+    Bool (*init_egl)(struct xwl_screen *xwl_screen);
+
+    /* Called after glamor has been initialized, and after all of the
+     * common Xwayland DDX hooks have been connected. Backends should use
+     * this to setup any required wraps around X server callbacks like
+     * CreatePixmap.
+     */
+    Bool (*init_screen)(struct xwl_screen *xwl_screen);
+
+    /* Called by Xwayland to retrieve a pointer to a valid wl_buffer for
+     * the given window/pixmap combo so that damage to the pixmap may be
+     * displayed on-screen. Backends should use this to create a new
+     * wl_buffer for a currently buffer-less pixmap, or simply return the
+     * pixmap they've prepared beforehand.
+     */
+    struct wl_buffer *(*get_wl_buffer_for_pixmap)(PixmapPtr pixmap);
+
+    /* Called by Xwayland to perform any pre-wl_surface damage routines
+     * that are required by the backend. If your backend is poorly
+     * designed and lacks the ability to render directly to a surface,
+     * you should implement blitting from the glamor pixmap to the wayland
+     * pixmap here. Otherwise, this callback is optional.
+     */
+    Bool (*post_damage)(struct xwl_window *xwl_window,
+                        PixmapPtr pixmap, RegionPtr region);
+
+    /* Called by Xwayland to confirm with the egl backend that the given
+     * pixmap is completely setup and ready for display on-screen. This
+     * callback is optional.
+     */
+    Bool (*allow_commits)(struct xwl_window *xwl_window);
+
+    /* Called by Xwayland to check whether the given pixmap can be
+     * presented by xwl_present_flip. If not implemented, assumed TRUE.
+     */
+    Bool (*check_flip)(PixmapPtr pixmap);
+
+    /* Called to get the dev_t of the primary GPU that this backend
+     * is set up on.
+     */
+    dev_t (*get_main_device)(struct xwl_screen *xwl_screen);
+};
+
+#ifdef XWL_HAS_GLAMOR
+
+void xwl_glamor_init_backends(struct xwl_screen *xwl_screen,
+                              Bool use_eglstream);
+void xwl_glamor_select_backend(struct xwl_screen *xwl_screen,
+                               Bool use_eglstream);
+Bool xwl_glamor_init(struct xwl_screen *xwl_screen);
+
+Bool xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
+                                  uint32_t id, uint32_t version);
+Bool xwl_dmabuf_setup_feedback_for_window(struct xwl_window *xwl_window);
+Bool xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
+                                     uint32_t id, uint32_t version);
+struct wl_buffer *xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap);
+void xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
+                                 struct wl_registry *registry,
+                                 uint32_t id, const char *interface,
+                                 uint32_t version);
+Bool xwl_glamor_has_wl_interfaces(struct xwl_screen *xwl_screen,
+                                 struct xwl_egl_backend *xwl_egl_backend);
+Bool xwl_glamor_post_damage(struct xwl_window *xwl_window,
+                            PixmapPtr pixmap, RegionPtr region);
+Bool xwl_glamor_allow_commits(struct xwl_window *xwl_window);
+void xwl_glamor_egl_make_current(struct xwl_screen *xwl_screen);
+Bool xwl_glamor_needs_buffer_flush(struct xwl_screen *xwl_screen);
+Bool xwl_glamor_needs_n_buffering(struct xwl_screen *xwl_screen);
+Bool xwl_glamor_is_modifier_supported(struct xwl_screen *xwl_screen,
+                                      uint32_t format, uint64_t modifier);
+uint32_t wl_drm_format_for_depth(int depth);
+Bool xwl_glamor_get_formats(ScreenPtr screen,
+                            CARD32 *num_formats, CARD32 **formats);
+Bool xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
+                              uint32_t *num_modifiers, uint64_t **modifiers);
+Bool xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
+                                       uint32_t *num_modifiers, uint64_t **modifiers);
+Bool xwl_glamor_check_flip(PixmapPtr pixmap);
+
+#ifdef XV
+/* glamor Xv Adaptor */
+Bool xwl_glamor_xv_init(ScreenPtr pScreen);
+#endif /* XV */
+
+#endif /* XWL_HAS_GLAMOR */
+
+#ifdef GLAMOR_HAS_GBM
+void xwl_glamor_init_gbm(struct xwl_screen *xwl_screen);
+#else
+static inline void xwl_glamor_init_gbm(struct xwl_screen *xwl_screen)
+{
+}
+#endif
+
+#ifdef XWL_HAS_EGLSTREAM
+void xwl_glamor_init_eglstream(struct xwl_screen *xwl_screen);
+#else
+static inline void xwl_glamor_init_eglstream(struct xwl_screen *xwl_screen)
+{
+}
+#endif
+
+#endif /* XWAYLAND_GLAMOR_H */
diff --git a/hw/xwayland/xwayland-glx.c b/hw/xwayland/xwayland-glx.c
new file mode 100644
index 000000000..4689b9ed6
--- /dev/null
+++ b/hw/xwayland/xwayland-glx.c
@@ -0,0 +1,421 @@
+/*
+ * Copyright © 2019 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Adam Jackson <ajax@redhat.com>
+ */
+
+/*
+ * Sets up GLX capabilities based on the EGL capabilities of the glamor
+ * renderer for the screen. Without this you will get whatever swrast
+ * can do, which often does not include things like multisample visuals.
+ */
+
+#include <xwayland-config.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#define EGL_NO_X11
+// #include <EGL/egl.h>
+#include <epoxy/egl.h>
+#include "glxserver.h"
+#include "glxutil.h"
+#include "compint.h"
+#include <X11/extensions/composite.h>
+#include "glamor_context.h"
+#include "glamor.h"
+
+#include "xwayland-screen.h"
+
+/* Can't get these from <GL/glx.h> since it pulls in client headers */
+#define GLX_RGBA_BIT		0x00000001
+#define GLX_WINDOW_BIT		0x00000001
+#define GLX_PIXMAP_BIT		0x00000002
+#define GLX_PBUFFER_BIT		0x00000004
+#define GLX_NONE                0x8000
+#define GLX_SLOW_CONFIG         0x8001
+#define GLX_TRUE_COLOR		0x8002
+#define GLX_DIRECT_COLOR	0x8003
+#define GLX_NON_CONFORMANT_CONFIG 0x800D
+#define GLX_DONT_CARE           0xFFFFFFFF
+#define GLX_RGBA_FLOAT_BIT_ARB  0x00000004
+#define GLX_SWAP_UNDEFINED_OML  0x8063
+
+struct egl_config {
+    __GLXconfig base;
+    EGLConfig config;
+};
+
+struct egl_screen {
+    __GLXscreen base;
+    EGLDisplay display;
+    EGLConfig *configs;
+};
+
+static void
+egl_screen_destroy(__GLXscreen *_screen)
+{
+    struct egl_screen *screen = (struct egl_screen *)_screen;
+
+    /* XXX do we leak the fbconfig list? */
+
+    free(screen->configs);
+    __glXScreenDestroy(_screen);
+    free(_screen);
+}
+
+static void
+egl_drawable_destroy(__GLXdrawable *draw)
+{
+    free(draw);
+}
+
+static GLboolean
+egl_drawable_swap_buffers(ClientPtr client, __GLXdrawable *draw)
+{
+    return GL_FALSE;
+}
+
+static void
+egl_drawable_copy_sub_buffer(__GLXdrawable *draw, int x, int y, int w, int h)
+{
+}
+
+static void
+egl_drawable_wait_x(__GLXdrawable *draw)
+{
+    glamor_block_handler(draw->pDraw->pScreen);
+}
+
+static void
+egl_drawable_wait_gl(__GLXdrawable *draw)
+{
+}
+
+static __GLXdrawable *
+egl_create_glx_drawable(ClientPtr client, __GLXscreen *screen,
+                        DrawablePtr draw, XID drawid, int type,
+                        XID glxdrawid, __GLXconfig *modes)
+{
+    __GLXdrawable *ret;
+
+    ret = calloc(1, sizeof *ret);
+    if (!ret)
+        return NULL;
+
+    if (!__glXDrawableInit(ret, screen, draw, type, glxdrawid, modes)) {
+        free(ret);
+        return NULL;
+    }
+
+    ret->destroy = egl_drawable_destroy;
+    ret->swapBuffers = egl_drawable_swap_buffers;
+    ret->copySubBuffer = egl_drawable_copy_sub_buffer;
+    ret->waitX = egl_drawable_wait_x;
+    ret->waitGL = egl_drawable_wait_gl;
+
+    return ret;
+}
+
+/*
+ * TODO:
+ *
+ * - bindToTextureTargets is suspicious
+ * - better channel mask setup
+ * - drawable type masks is suspicious
+ */
+static struct egl_config *
+translate_eglconfig(struct egl_screen *screen, EGLConfig hc,
+                    struct egl_config *chain, Bool direct_color,
+                    Bool double_buffer, Bool duplicate_for_composite,
+                    Bool srgb_only)
+{
+    EGLint value;
+    struct egl_config *c = calloc(1, sizeof *c);
+
+    if (!c)
+        return chain;
+
+    /* constants.  changing these requires (at least) new EGL extensions */
+    c->base.stereoMode = GL_FALSE;
+    c->base.numAuxBuffers = 0;
+    c->base.level = 0;
+    c->base.transparentAlpha = 0;
+    c->base.transparentIndex = 0;
+    c->base.transparentPixel = GLX_NONE;
+    c->base.visualSelectGroup = 0;
+    c->base.indexBits = 0;
+    c->base.optimalPbufferWidth = 0;
+    c->base.optimalPbufferHeight = 0;
+    c->base.bindToMipmapTexture = 0;
+    c->base.bindToTextureTargets = GLX_DONT_CARE;
+    c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;
+
+    /* this is... suspect */
+    c->base.drawableType = GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
+
+    /* hmm */
+    c->base.bindToTextureRgb = GL_TRUE;
+    c->base.bindToTextureRgba = GL_TRUE;
+
+    /*
+     * glx conformance failure: there's no such thing as accumulation
+     * buffers in EGL.  they should be emulable with shaders and fbos,
+     * but i'm pretty sure nobody's using this feature since it's
+     * entirely software.  note that glx conformance merely requires
+     * that an accum buffer _exist_, not a minimum bitness.
+     */
+    c->base.accumRedBits = 0;
+    c->base.accumGreenBits = 0;
+    c->base.accumBlueBits = 0;
+    c->base.accumAlphaBits = 0;
+
+    /* parametric state */
+    if (direct_color)
+        c->base.visualType = GLX_DIRECT_COLOR;
+    else
+        c->base.visualType = GLX_TRUE_COLOR;
+
+    if (double_buffer)
+        c->base.doubleBufferMode = GL_TRUE;
+    else
+        c->base.doubleBufferMode = GL_FALSE;
+
+    /* direct-mapped state */
+#define GET(attr, slot) \
+    eglGetConfigAttrib(screen->display, hc, attr, &c->base.slot)
+    GET(EGL_RED_SIZE, redBits);
+    GET(EGL_GREEN_SIZE, greenBits);
+    GET(EGL_BLUE_SIZE, blueBits);
+    GET(EGL_ALPHA_SIZE, alphaBits);
+    GET(EGL_BUFFER_SIZE, rgbBits);
+    GET(EGL_DEPTH_SIZE, depthBits);
+    GET(EGL_STENCIL_SIZE, stencilBits);
+    GET(EGL_TRANSPARENT_RED_VALUE, transparentRed);
+    GET(EGL_TRANSPARENT_GREEN_VALUE, transparentGreen);
+    GET(EGL_TRANSPARENT_BLUE_VALUE, transparentBlue);
+    GET(EGL_SAMPLE_BUFFERS, sampleBuffers);
+    GET(EGL_SAMPLES, samples);
+    if (c->base.renderType & GLX_PBUFFER_BIT) {
+        GET(EGL_MAX_PBUFFER_WIDTH, maxPbufferWidth);
+        GET(EGL_MAX_PBUFFER_HEIGHT, maxPbufferHeight);
+        GET(EGL_MAX_PBUFFER_PIXELS, maxPbufferPixels);
+    }
+#undef GET
+
+    /* derived state: config caveats */
+    eglGetConfigAttrib(screen->display, hc, EGL_CONFIG_CAVEAT, &value);
+    if (value == EGL_NONE)
+        c->base.visualRating = GLX_NONE;
+    else if (value == EGL_SLOW_CONFIG)
+        c->base.visualRating = GLX_SLOW_CONFIG;
+    else if (value == EGL_NON_CONFORMANT_CONFIG)
+        c->base.visualRating = GLX_NON_CONFORMANT_CONFIG;
+    /* else panic */
+
+    /* derived state: float configs */
+    c->base.renderType = GLX_RGBA_BIT;
+    if (eglGetConfigAttrib(screen->display, hc, EGL_COLOR_COMPONENT_TYPE_EXT,
+                           &value) == EGL_TRUE) {
+        if (value == EGL_COLOR_COMPONENT_TYPE_FLOAT_EXT) {
+            c->base.renderType = GLX_RGBA_FLOAT_BIT_ARB;
+        }
+        /* else panic */
+    }
+
+    /* derived state: sRGB. EGL doesn't put this in the fbconfig at all,
+     * it's a property of the surface specified at creation time, so we have
+     * to infer it from the GL's extensions. only makes sense at 8bpc though.
+     */
+    if (srgb_only) {
+        if (c->base.redBits == 8) {
+            c->base.sRGBCapable = GL_TRUE;
+        } else {
+            free(c);
+            return chain;
+        }
+    }
+
+    /* map to the backend's config */
+    c->config = hc;
+
+    /*
+     * XXX do something less ugly
+     */
+    if (c->base.renderType == GLX_RGBA_BIT) {
+        if (c->base.redBits == 5 &&
+            (c->base.rgbBits == 15 || c->base.rgbBits == 16)) {
+            c->base.blueMask  = 0x0000001f;
+            if (c->base.alphaBits) {
+                c->base.greenMask = 0x000003e0;
+                c->base.redMask   = 0x00007c00;
+                c->base.alphaMask = 0x00008000;
+            } else {
+                c->base.greenMask = 0x000007e0;
+                c->base.redMask   = 0x0000f800;
+                c->base.alphaMask = 0x00000000;
+            }
+        }
+        else if (c->base.redBits == 8 &&
+            (c->base.rgbBits == 24 || c->base.rgbBits == 32)) {
+            c->base.blueMask  = 0x000000ff;
+            c->base.greenMask = 0x0000ff00;
+            c->base.redMask   = 0x00ff0000;
+            if (c->base.alphaBits)
+                /* assume all remaining bits are alpha */
+                c->base.alphaMask = 0xff000000;
+        }
+        else if (c->base.redBits == 10 &&
+            (c->base.rgbBits == 30 || c->base.rgbBits == 32)) {
+            c->base.blueMask  = 0x000003ff;
+            c->base.greenMask = 0x000ffc00;
+            c->base.redMask   = 0x3ff00000;
+            if (c->base.alphaBits)
+                /* assume all remaining bits are alpha */
+                c->base.alphaMask = 0xc000000;
+        }
+    }
+
+    /*
+     * Here we decide which fbconfigs will be duplicated for compositing.
+     * fgbconfigs marked with duplicatedForComp will be reserved for
+     * compositing visuals.
+     * It might look strange to do this decision this late when translation
+     * from an EGLConfig is already done, but using the EGLConfig
+     * accessor functions becomes worse both with respect to code complexity
+     * and CPU usage.
+     */
+    if (duplicate_for_composite &&
+        (c->base.renderType == GLX_RGBA_FLOAT_BIT_ARB ||
+         c->base.rgbBits != 32 ||
+         c->base.redBits != 8 ||
+         c->base.greenBits != 8 ||
+         c->base.blueBits != 8 ||
+         c->base.visualRating != GLX_NONE ||
+         c->base.sampleBuffers != 0)) {
+        free(c);
+        return chain;
+    }
+    c->base.duplicatedForComp = duplicate_for_composite;
+
+    c->base.next = chain ? &chain->base : NULL;
+    return c;
+}
+
+static __GLXconfig *
+egl_mirror_configs(ScreenPtr pScreen, struct egl_screen *screen)
+{
+    int i, j, k, nconfigs;
+    struct egl_config *c = NULL;
+    EGLConfig *host_configs = NULL;
+    bool can_srgb = epoxy_has_gl_extension("GL_ARB_framebuffer_sRGB") ||
+                    epoxy_has_gl_extension("GL_EXT_framebuffer_sRGB") ||
+                    epoxy_has_gl_extension("GL_EXT_sRGB_write_control");
+
+    eglGetConfigs(screen->display, NULL, 0, &nconfigs);
+    if (!(host_configs = calloc(nconfigs, sizeof *host_configs)))
+        return NULL;
+
+    eglGetConfigs(screen->display, host_configs, nconfigs, &nconfigs);
+
+    /* We walk the EGL configs backwards to make building the
+     * ->next chain easier.
+     */
+    for (i = nconfigs - 1; i >= 0; i--)
+        for (j = 0; j < 3; j++) /* direct_color */
+            for (k = 0; k < 2; k++) /* double_buffer */ {
+                if (can_srgb)
+                    c = translate_eglconfig(screen, host_configs[i], c,
+                                            /* direct_color */ j == 1,
+                                            /* double_buffer */ k > 0,
+                                            /* duplicate_for_composite */ j == 0,
+                                            /* srgb_only */ true);
+
+                c = translate_eglconfig(screen, host_configs[i], c,
+                                        /* direct_color */ j == 1,
+                                        /* double_buffer */ k > 0,
+                                        /* duplicate_for_composite */ j == 0,
+                                        /* srgb_only */ false);
+            }
+
+    screen->configs = host_configs;
+    return c ? &c->base : NULL;
+}
+
+static __GLXscreen *
+egl_screen_probe(ScreenPtr pScreen)
+{
+    struct egl_screen *screen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    __GLXscreen *base;
+
+    if (enableIndirectGLX)
+        return NULL; /* not implemented */
+
+    if (!(screen = calloc(1, sizeof *screen)))
+        return NULL;
+
+    base = &screen->base;
+    base->destroy = egl_screen_destroy;
+    base->createDrawable = egl_create_glx_drawable;
+    /* base.swapInterval = NULL; */
+
+    screen->display = xwl_screen->glamor_ctx->display;
+
+    __glXInitExtensionEnableBits(screen->base.glx_enable_bits);
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_context_flush_control");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_create_context");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_create_context_no_error");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_create_context_profile");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_create_context_robustness");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_fbconfig_float");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_create_context_es2_profile");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_create_context_es_profile");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_fbconfig_packed_float");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_framebuffer_sRGB");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_no_config_context");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_EXT_texture_from_pixmap");
+    __glXEnableExtension(base->glx_enable_bits, "GLX_MESA_copy_sub_buffer");
+    // __glXEnableExtension(base->glx_enable_bits, "GLX_SGI_swap_control");
+
+    base->fbconfigs = egl_mirror_configs(pScreen, screen);
+    if (!base->fbconfigs) {
+        free(screen);
+        return NULL;
+    }
+
+    if (!screen->base.glvnd && xwl_screen->glvnd_vendor)
+        screen->base.glvnd = strdup(xwl_screen->glvnd_vendor);
+
+    if (!screen->base.glvnd)
+        screen->base.glvnd = strdup("mesa");
+
+    __glXScreenInit(base, pScreen);
+    __glXsetGetProcAddress(eglGetProcAddress);
+
+    return base;
+}
+
+__GLXprovider glamor_provider = {
+    egl_screen_probe,
+    "glamor",
+    NULL
+};
diff --git a/hw/xwayland/xwayland-glx.h b/hw/xwayland/xwayland-glx.h
new file mode 100644
index 000000000..62c9fb7ce
--- /dev/null
+++ b/hw/xwayland/xwayland-glx.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright © 2019 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Adam Jackson <ajax@redhat.com>
+ */
+
+#ifndef XWAYLAND_GLX_H
+#define XWAYLAND_GLX_H
+
+#include <xwayland-config.h>
+
+#ifdef GLXEXT
+#include "glx_extinit.h"
+extern __GLXprovider glamor_provider;
+#endif
+
+#endif /* XWAYLAND_GLX_H */
diff --git a/hw/xwayland/xwayland-input.c b/hw/xwayland/xwayland-input.c
new file mode 100644
index 000000000..5892dd502
--- /dev/null
+++ b/hw/xwayland/xwayland-input.c
@@ -0,0 +1,3509 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2008 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <linux/input.h>
+#include <sys/mman.h>
+
+#include <inputstr.h>
+#include <exevents.h>
+#include <xkbsrv.h>
+#include <xserver-properties.h>
+#include <inpututils.h>
+#include <mi.h>
+#include <mipointer.h>
+#include <mipointrst.h>
+#include <misc.h>
+
+#include "xwayland-cursor.h"
+#include "xwayland-input.h"
+#include "xwayland-window.h"
+#include "xwayland-screen.h"
+
+#include "pointer-constraints-unstable-v1-client-protocol.h"
+#include "relative-pointer-unstable-v1-client-protocol.h"
+#include "tablet-unstable-v2-client-protocol.h"
+#include "pointer-gestures-unstable-v1-client-protocol.h"
+#include "xwayland-keyboard-grab-unstable-v1-client-protocol.h"
+#include "keyboard-shortcuts-inhibit-unstable-v1-client-protocol.h"
+
+#define SCROLL_AXIS_HORIZ 2
+#define SCROLL_AXIS_VERT 3
+
+struct sync_pending {
+    struct xorg_list l;
+    DeviceIntPtr pending_dev;
+};
+
+static DevPrivateKeyRec xwl_tablet_private_key;
+
+static void
+xwl_pointer_warp_emulator_handle_motion(struct xwl_pointer_warp_emulator *warp_emulator,
+                                        double dx,
+                                        double dy,
+                                        double dx_unaccel,
+                                        double dy_unaccel);
+static void
+xwl_pointer_warp_emulator_maybe_lock(struct xwl_pointer_warp_emulator *warp_emulator,
+                                     struct xwl_window *xwl_window,
+                                     SpritePtr sprite,
+                                     int x, int y);
+
+static Bool
+xwl_seat_maybe_lock_on_hidden_cursor(struct xwl_seat *xwl_seat);
+
+static void
+xwl_seat_destroy_confined_pointer(struct xwl_seat *xwl_seat);
+
+static void
+init_tablet_manager_seat(struct xwl_screen *xwl_screen,
+                         struct xwl_seat *xwl_seat);
+static void
+release_tablet_manager_seat(struct xwl_seat *xwl_seat);
+
+static void
+xwl_pointer_control(DeviceIntPtr device, PtrCtrl *ctrl)
+{
+    /* Nothing to do, dix handles all settings */
+}
+
+static DeviceIntPtr
+get_pointer_device(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->relative_pointer)
+        return xwl_seat->relative_pointer;
+    else
+        return xwl_seat->pointer;
+}
+
+static Bool
+init_pointer_buttons(DeviceIntPtr device)
+{
+#define NBUTTONS 10
+    BYTE map[NBUTTONS + 1];
+    int i = 0;
+    Atom btn_labels[NBUTTONS] = { 0 };
+
+    for (i = 1; i <= NBUTTONS; i++)
+        map[i] = i;
+
+    btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
+    btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
+    btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
+    btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
+    btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
+    btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
+    btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
+    /* don't know about the rest */
+
+    if (!InitButtonClassDeviceStruct(device, NBUTTONS, btn_labels, map))
+        return FALSE;
+
+    return TRUE;
+}
+
+static void
+maybe_fake_grab_devices(struct xwl_seat *xwl_seat)
+{
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+    struct xwl_window *xwl_window;
+
+    if (xwl_screen->rootless)
+        return;
+
+    if (!xwl_screen->host_grab)
+        return;
+
+    if (!xwl_screen->has_grab)
+        return;
+
+    if (!xwl_screen->screen->root)
+        return;
+
+    xwl_window = xwl_window_get(xwl_screen->screen->root);
+    if (!xwl_window)
+        return;
+
+    xwl_seat_confine_pointer(xwl_seat, xwl_window);
+
+    if (!xwl_screen->shortcuts_inhibit_manager)
+        return;
+
+    if (xwl_screen->shortcuts_inhibit)
+        return;
+
+    xwl_screen->shortcuts_inhibit =
+        zwp_keyboard_shortcuts_inhibit_manager_v1_inhibit_shortcuts (
+            xwl_screen->shortcuts_inhibit_manager,
+            xwl_window->surface,
+            xwl_seat->seat);
+}
+
+static void
+maybe_fake_ungrab_devices(struct xwl_seat *xwl_seat)
+{
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+
+    xwl_seat_unconfine_pointer(xwl_seat);
+
+    if (!xwl_screen->shortcuts_inhibit)
+        return;
+
+    zwp_keyboard_shortcuts_inhibitor_v1_destroy (xwl_screen->shortcuts_inhibit);
+    xwl_screen->shortcuts_inhibit = NULL;
+}
+
+static int
+xwl_pointer_proc(DeviceIntPtr device, int what)
+{
+#define NAXES 4
+    Atom axes_labels[NAXES] = { 0 };
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        if (!init_pointer_buttons(device))
+            return BadValue;
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
+        axes_labels[SCROLL_AXIS_HORIZ] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HWHEEL);
+        axes_labels[SCROLL_AXIS_VERT] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_WHEEL);
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, SCROLL_AXIS_HORIZ, axes_labels[2],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, SCROLL_AXIS_VERT, axes_labels[3],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+
+        SetScrollValuator(device, SCROLL_AXIS_HORIZ, SCROLL_TYPE_HORIZONTAL, 1.0, SCROLL_FLAG_NONE);
+        SetScrollValuator(device, SCROLL_AXIS_VERT, SCROLL_TYPE_VERTICAL, 1.0, SCROLL_FLAG_PREFERRED);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+
+#undef NBUTTONS
+#undef NAXES
+}
+
+static int
+xwl_pointer_proc_relative(DeviceIntPtr device, int what)
+{
+#define NAXES 4
+    Atom axes_labels[NAXES] = { 0 };
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
+        axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HWHEEL);
+        axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_WHEEL);
+
+        /*
+         * We'll never send buttons, but XGetPointerMapping might in certain
+         * situations make the client think we have no buttons.
+         */
+        if (!init_pointer_buttons(device))
+            return BadValue;
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Relative))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, 2, axes_labels[2],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, 3, axes_labels[3],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+
+        SetScrollValuator(device, 2, SCROLL_TYPE_HORIZONTAL, 1.0, SCROLL_FLAG_NONE);
+        SetScrollValuator(device, 3, SCROLL_TYPE_VERTICAL, 1.0, SCROLL_FLAG_PREFERRED);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+
+#undef NAXES
+}
+
+static int
+xwl_pointer_proc_pointer_gestures(DeviceIntPtr device, int what)
+{
+#define NTOUCHPOINTS 20
+#define NAXES 2
+    Atom axes_labels[NAXES] = { 0 };
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        /* We need to setup a pointer device so that the device is attached to
+           master pointer device.
+        */
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Relative))
+            return BadValue;
+
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+
+        InitGestureClassDeviceStruct(device, NTOUCHPOINTS);
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+
+#undef NTOUCHPOINTS
+#undef NAXES
+}
+
+static void
+xwl_keyboard_control(DeviceIntPtr device, KeybdCtrl *ctrl)
+{
+}
+
+static int
+xwl_keyboard_proc(DeviceIntPtr device, int what)
+{
+    struct xwl_seat *xwl_seat = device->public.devicePrivate;
+    int len;
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+        if (xwl_seat->keymap)
+            len = strnlen(xwl_seat->keymap, xwl_seat->keymap_size);
+        else
+            len = 0;
+        if (!InitKeyboardDeviceStructFromString(device, xwl_seat->keymap,
+                                                len,
+                                                NULL, xwl_keyboard_control))
+            return BadValue;
+
+        return Success;
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+}
+
+static int
+xwl_touch_proc(DeviceIntPtr device, int what)
+{
+#define NTOUCHPOINTS 20
+#define NBUTTONS 1
+#define NAXES 2
+    Atom btn_labels[NBUTTONS] = { 0 };
+    Atom axes_labels[NAXES] = { 0 };
+    BYTE map[NBUTTONS + 1] = { 0 };
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_MT_POSITION_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_MT_POSITION_Y);
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        if (!InitButtonClassDeviceStruct(device, NBUTTONS, btn_labels, map))
+            return BadValue;
+
+        if (!InitTouchClassDeviceStruct(device, NTOUCHPOINTS,
+                                        XIDirectTouch, NAXES))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+#undef NAXES
+#undef NBUTTONS
+#undef NTOUCHPOINTS
+}
+
+static int
+xwl_tablet_proc(DeviceIntPtr device, int what)
+{
+#define NBUTTONS 9
+#define NAXES 6
+    Atom btn_labels[NBUTTONS] = { 0 };
+    Atom axes_labels[NAXES] = { 0 };
+    BYTE map[NBUTTONS + 1] = { 0 };
+    int i;
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        for (i = 1; i <= NBUTTONS; i++)
+            map[i] = i;
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
+        axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_PRESSURE);
+        axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_X);
+        axes_labels[4] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_Y);
+        axes_labels[5] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_WHEEL);
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        /* Valuators - match the xf86-input-wacom ranges */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 262143, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 262143, 10000, 0, 10000, Absolute);
+        /* pressure */
+        InitValuatorAxisStruct(device, 2, axes_labels[2],
+                               0, 65535, 1, 0, 1, Absolute);
+        /* tilt x */
+        InitValuatorAxisStruct(device, 3, axes_labels[3],
+                               -64, 63, 57, 0, 57, Absolute);
+        /* tilt y */
+        InitValuatorAxisStruct(device, 4, axes_labels[4],
+                               -64, 63, 57, 0, 57, Absolute);
+        /* abs wheel (airbrush) or rotation (artpen) */
+        InitValuatorAxisStruct(device, 5, axes_labels[5],
+                               -900, 899, 1, 0, 1, Absolute);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        if (!InitButtonClassDeviceStruct(device, NBUTTONS, btn_labels, map))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+#undef NAXES
+#undef NBUTTONS
+}
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                     uint32_t serial, struct wl_surface *surface,
+                     wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev = get_pointer_device(xwl_seat);
+    DeviceIntPtr master;
+    int i;
+    int sx = wl_fixed_to_int(sx_w);
+    int sy = wl_fixed_to_int(sy_w);
+    int dx, dy;
+    ScreenPtr pScreen = xwl_seat->xwl_screen->screen;
+    ValuatorMask mask;
+
+    /* There's a race here where if we create and then immediately
+     * destroy a surface, we might end up in a state where the Wayland
+     * compositor sends us an event for a surface that doesn't exist.
+     *
+     * Don't process enter events in this case.
+     */
+    if (surface == NULL)
+        return;
+
+    if (!is_surface_from_xwl_window(surface))
+        return;
+
+    xwl_seat->xwl_screen->serial = serial;
+    xwl_seat->pointer_enter_serial = serial;
+
+    xwl_seat->focus_window = wl_surface_get_user_data(surface);
+    dx = xwl_seat->focus_window->window->drawable.x;
+    dy = xwl_seat->focus_window->window->drawable.y;
+
+    /* We just entered a new xwindow, forget about the old last xwindow */
+    xwl_seat->last_xwindow = NullWindow;
+
+    master = GetMaster(dev, POINTER_OR_FLOAT);
+    (*pScreen->SetCursorPosition) (dev, pScreen, dx + sx, dy + sy, TRUE);
+
+    miPointerInvalidateSprite(master);
+
+    CheckMotion(NULL, master);
+
+    /* Ideally, X clients shouldn't see these button releases.  When
+     * the pointer leaves a window with buttons down, it means that
+     * the wayland compositor has grabbed the pointer.  The button
+     * release event is consumed by whatever grab in the compositor
+     * and won't be sent to clients (the X server is a client).
+     * However, we need to reset X's idea of which buttons are up and
+     * down, and they're all up (by definition) when the pointer
+     * enters a window.  We should figure out a way to swallow these
+     * events, perhaps using an X grab whenever the pointer is not in
+     * any X window, but for now just send the events. */
+    valuator_mask_zero(&mask);
+    for (i = 0; i < dev->button->numButtons; i++)
+        if (BitIsOn(dev->button->down, i))
+            QueuePointerEvents(dev, ButtonRelease, i, 0, &mask);
+
+    /* The last cursor frame we committed before the pointer left one
+     * of our surfaces might not have been shown. In that case we'll
+     * have a cursor surface frame callback pending which we need to
+     * clear so that we can continue submitting new cursor frames. */
+    if (xwl_cursor_clear_frame_cb(&xwl_seat->cursor))
+        xwl_seat_set_cursor(xwl_seat);
+
+    if (xwl_seat->pointer_warp_emulator) {
+        xwl_pointer_warp_emulator_maybe_lock(xwl_seat->pointer_warp_emulator,
+                                             xwl_seat->focus_window,
+                                             NULL, 0, 0);
+    }
+    else {
+        xwl_seat_maybe_lock_on_hidden_cursor(xwl_seat);
+    }
+
+    maybe_fake_grab_devices(xwl_seat);
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                     uint32_t serial, struct wl_surface *surface)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev = get_pointer_device(xwl_seat);
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    /* The pointer has left a known xwindow, save it for a possible match
+     * in sprite_check_lost_focus()
+     */
+    if (xwl_seat->focus_window) {
+        xwl_seat->last_xwindow = xwl_seat->focus_window->window;
+        xwl_seat->focus_window = NULL;
+        CheckMotion(NULL, GetMaster(dev, POINTER_OR_FLOAT));
+    }
+
+    maybe_fake_ungrab_devices(xwl_seat);
+}
+
+static void
+dispatch_relative_motion_with_warp(struct xwl_seat *xwl_seat)
+{
+    double dx, dx_unaccel;
+    double dy, dy_unaccel;
+
+    dx = xwl_seat->pending_pointer_event.dx;
+    dy = xwl_seat->pending_pointer_event.dy;
+    dx_unaccel = xwl_seat->pending_pointer_event.dx_unaccel;
+    dy_unaccel = xwl_seat->pending_pointer_event.dy_unaccel;
+
+    xwl_pointer_warp_emulator_handle_motion(xwl_seat->pointer_warp_emulator,
+                                            dx, dy,
+                                            dx_unaccel, dy_unaccel);
+}
+
+static void
+dispatch_absolute_motion(struct xwl_seat *xwl_seat)
+{
+    ValuatorMask mask;
+    DeviceIntPtr device;
+    int flags;
+    int event_x = wl_fixed_to_int(xwl_seat->pending_pointer_event.x);
+    int event_y = wl_fixed_to_int(xwl_seat->pending_pointer_event.y);
+    int drawable_x = xwl_seat->focus_window->window->drawable.x;
+    int drawable_y = xwl_seat->focus_window->window->drawable.y;
+    int x;
+    int y;
+
+    if (xwl_window_has_viewport_enabled(xwl_seat->focus_window)) {
+        event_x *= xwl_seat->focus_window->scale_x;
+        event_y *= xwl_seat->focus_window->scale_y;
+    }
+
+    x = drawable_x + event_x;
+    y = drawable_y + event_y;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 0, x);
+    valuator_mask_set(&mask, 1, y);
+
+    if (xwl_seat->pending_pointer_event.has_relative) {
+         flags = POINTER_ABSOLUTE | POINTER_SCREEN | POINTER_NORAW;
+         device = xwl_seat->relative_pointer;
+    } else {
+         flags = POINTER_ABSOLUTE | POINTER_SCREEN;
+         device = xwl_seat->pointer;
+    }
+
+    QueuePointerEvents(device, MotionNotify, 0, flags, &mask);
+}
+
+static void
+dispatch_relative_motion(struct xwl_seat *xwl_seat)
+{
+    ValuatorMask mask;
+    double event_dx = xwl_seat->pending_pointer_event.dx;
+    double event_dy = xwl_seat->pending_pointer_event.dy;
+    double event_dx_unaccel = xwl_seat->pending_pointer_event.dx_unaccel;
+    double event_dy_unaccel = xwl_seat->pending_pointer_event.dy_unaccel;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set_unaccelerated(&mask, 0, event_dx, event_dx_unaccel);
+    valuator_mask_set_unaccelerated(&mask, 1, event_dy, event_dy_unaccel);
+
+    QueuePointerEvents(xwl_seat->relative_pointer, MotionNotify, 0,
+                       POINTER_RAWONLY, &mask);
+}
+
+static void
+dispatch_scroll_motion(struct xwl_seat *xwl_seat)
+{
+    ValuatorMask mask;
+    const int divisor = 10;
+    wl_fixed_t dy = xwl_seat->pending_pointer_event.scroll_dy;
+    wl_fixed_t dx = xwl_seat->pending_pointer_event.scroll_dx;
+    int32_t dy_v120 = xwl_seat->pending_pointer_event.scroll_dy_v120;
+    int32_t dx_v120 = xwl_seat->pending_pointer_event.scroll_dx_v120;
+
+    valuator_mask_zero(&mask);
+    if (xwl_seat->pending_pointer_event.has_vertical_scroll_v120)
+        valuator_mask_set_double(&mask, SCROLL_AXIS_VERT, dy_v120 / 120.0);
+    else if (xwl_seat->pending_pointer_event.has_vertical_scroll)
+        valuator_mask_set_double(&mask,
+                                 SCROLL_AXIS_VERT,
+                                 wl_fixed_to_double(dy) / divisor);
+
+    if (xwl_seat->pending_pointer_event.has_horizontal_scroll_v120)
+        valuator_mask_set_double(&mask, SCROLL_AXIS_HORIZ, dx_v120 / 120.0);
+    else if (xwl_seat->pending_pointer_event.has_horizontal_scroll)
+        valuator_mask_set_double(&mask,
+                                 SCROLL_AXIS_HORIZ,
+                                 wl_fixed_to_double(dx) / divisor);
+
+    QueuePointerEvents(get_pointer_device(xwl_seat),
+                       MotionNotify, 0, POINTER_RELATIVE, &mask);
+}
+
+
+static void
+dispatch_pointer_motion_event(struct xwl_seat *xwl_seat)
+{
+    Bool has_relative = xwl_seat->pending_pointer_event.has_relative;
+    Bool has_absolute = xwl_seat->pending_pointer_event.has_absolute;
+
+    if (xwl_seat->pointer_warp_emulator && has_relative) {
+        dispatch_relative_motion_with_warp(xwl_seat);
+    } else {
+        if (has_relative)
+            dispatch_relative_motion(xwl_seat);
+
+        if (has_absolute)
+            dispatch_absolute_motion(xwl_seat);
+    }
+
+    if (xwl_seat->pending_pointer_event.has_vertical_scroll ||
+        xwl_seat->pending_pointer_event.has_horizontal_scroll ||
+        xwl_seat->pending_pointer_event.has_vertical_scroll_v120 ||
+        xwl_seat->pending_pointer_event.has_horizontal_scroll_v120)
+        dispatch_scroll_motion(xwl_seat);
+
+    xwl_seat->pending_pointer_event.has_absolute = FALSE;
+    xwl_seat->pending_pointer_event.has_relative = FALSE;
+    xwl_seat->pending_pointer_event.has_vertical_scroll = FALSE;
+    xwl_seat->pending_pointer_event.has_horizontal_scroll = FALSE;
+    xwl_seat->pending_pointer_event.has_vertical_scroll_v120 = FALSE;
+    xwl_seat->pending_pointer_event.has_horizontal_scroll_v120 = FALSE;
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                      uint32_t time, wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    if (!xwl_seat->focus_window)
+        return;
+
+    xwl_seat->pending_pointer_event.has_absolute = TRUE;
+    xwl_seat->pending_pointer_event.x = sx_w;
+    xwl_seat->pending_pointer_event.y = sy_w;
+
+    if (wl_proxy_get_version((struct wl_proxy *) xwl_seat->wl_pointer) < 5)
+        dispatch_pointer_motion_event(xwl_seat);
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *pointer, uint32_t serial,
+                      uint32_t time, uint32_t button, uint32_t state)
+{
+    struct xwl_seat *xwl_seat = data;
+    int index;
+    ValuatorMask mask;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    switch (button) {
+    case BTN_LEFT:
+        index = 1;
+        break;
+    case BTN_MIDDLE:
+        index = 2;
+        break;
+    case BTN_RIGHT:
+        index = 3;
+        break;
+    default:
+        /* Skip indexes 4-7: they are used for vertical and horizontal scroll.
+           The rest of the buttons go in order: BTN_SIDE becomes 8, etc. */
+        index = 8 + button - BTN_SIDE;
+        break;
+    }
+
+    valuator_mask_zero(&mask);
+    QueuePointerEvents(get_pointer_device(xwl_seat),
+                       state ? ButtonPress : ButtonRelease, index, 0, &mask);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *pointer,
+                    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    switch (axis) {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_vertical_scroll = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dy = value;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_horizontal_scroll = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dx = value;
+        break;
+    }
+}
+
+static void
+pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    if (!xwl_seat->focus_window)
+        return;
+
+    dispatch_pointer_motion_event(xwl_seat);
+}
+
+static void
+pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer, uint32_t axis_source)
+{
+}
+
+static void
+pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                         uint32_t time, uint32_t axis)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    switch (axis) {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_vertical_scroll = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dy = 0;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_horizontal_scroll = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dx = 0;
+        break;
+    }
+}
+
+static void
+pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                             uint32_t axis, int32_t discrete)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    switch (axis) {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_vertical_scroll_v120 = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dy_v120 = 120 * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_horizontal_scroll_v120 = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dx_v120 = 120 * discrete;
+        break;
+    }
+}
+
+#ifdef XWL_HAS_WL_POINTER_AXIS_V120
+static void
+pointer_handle_axis_v120(void *data, struct wl_pointer *pointer,
+                         uint32_t axis, int32_t v120)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    switch (axis) {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_vertical_scroll_v120 = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dy_v120 = v120;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        xwl_seat->pending_pointer_event.has_horizontal_scroll_v120 = TRUE;
+        xwl_seat->pending_pointer_event.scroll_dx_v120 = v120;
+        break;
+    }
+}
+#endif
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+#ifdef XWL_HAS_WL_POINTER_AXIS_V120
+    pointer_handle_axis_v120,
+#endif
+};
+
+static void
+relative_pointer_handle_relative_motion(void *data,
+                                        struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
+                                        uint32_t utime_hi,
+                                        uint32_t utime_lo,
+                                        wl_fixed_t dxf,
+                                        wl_fixed_t dyf,
+                                        wl_fixed_t dx_unaccelf,
+                                        wl_fixed_t dy_unaccelf)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    xwl_seat->pending_pointer_event.has_relative = TRUE;
+    xwl_seat->pending_pointer_event.dx = wl_fixed_to_double(dxf);
+    xwl_seat->pending_pointer_event.dy = wl_fixed_to_double(dyf);
+    xwl_seat->pending_pointer_event.dx_unaccel = wl_fixed_to_double(dx_unaccelf);
+    xwl_seat->pending_pointer_event.dy_unaccel = wl_fixed_to_double(dy_unaccelf);
+
+    if (!xwl_seat->focus_window)
+        return;
+
+    if (wl_proxy_get_version((struct wl_proxy *) xwl_seat->wl_pointer) < 5)
+        dispatch_pointer_motion_event(xwl_seat);
+}
+
+static const struct zwp_relative_pointer_v1_listener relative_pointer_listener = {
+    relative_pointer_handle_relative_motion,
+};
+
+static void
+pointer_gesture_swipe_handle_begin(void *data,
+                                   struct zwp_pointer_gesture_swipe_v1 *swipe,
+                                   uint32_t serial,
+                                   uint32_t time,
+                                   struct wl_surface *surface,
+                                   uint32_t fingers)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    if (surface != NULL && !is_surface_from_xwl_window(surface))
+        return;
+
+    xwl_seat->pointer_gesture_swipe_fingers = fingers;
+    QueueGestureSwipeEvents(xwl_seat->pointer_gestures,
+                            XI_GestureSwipeBegin, fingers, 0, 0.0, 0.0, 0.0, 0.0);
+}
+
+static void
+pointer_gesture_swipe_handle_update(void *data,
+                                    struct zwp_pointer_gesture_swipe_v1 *swipe,
+                                    uint32_t time,
+                                    wl_fixed_t dxf,
+                                    wl_fixed_t dyf)
+{
+    struct xwl_seat *xwl_seat = data;
+    double dx = wl_fixed_to_double(dxf);
+    double dy = wl_fixed_to_double(dyf);
+
+    QueueGestureSwipeEvents(xwl_seat->pointer_gestures,
+                            XI_GestureSwipeUpdate,
+                            xwl_seat->pointer_gesture_swipe_fingers,
+                            0,
+                            dx, dy,
+                            dx, dy);
+}
+
+static void
+pointer_gesture_swipe_handle_end(void *data,
+                                 struct zwp_pointer_gesture_swipe_v1 *swipe,
+                                 uint32_t serial,
+                                 uint32_t time,
+                                 int32_t cancelled)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t flags = 0;
+
+    if (cancelled)
+        flags |= XIGestureSwipeEventCancelled;
+
+    QueueGestureSwipeEvents(xwl_seat->pointer_gestures,
+                            XI_GestureSwipeEnd,
+                            xwl_seat->pointer_gesture_swipe_fingers,
+                            flags, 0.0, 0.0, 0.0, 0.0);
+}
+
+static const struct zwp_pointer_gesture_swipe_v1_listener pointer_gesture_swipe_listener = {
+    pointer_gesture_swipe_handle_begin,
+    pointer_gesture_swipe_handle_update,
+    pointer_gesture_swipe_handle_end
+};
+
+static void
+pointer_gesture_pinch_handle_begin(void *data,
+                                   struct zwp_pointer_gesture_pinch_v1 *pinch,
+                                   uint32_t serial,
+                                   uint32_t time,
+                                   struct wl_surface *surface,
+                                   uint32_t fingers)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    if (surface != NULL && !is_surface_from_xwl_window(surface))
+        return;
+
+    xwl_seat->pointer_gesture_pinch_fingers = fingers;
+    xwl_seat->pointer_gesture_pinch_last_scale = 1.0;
+    QueueGesturePinchEvents(xwl_seat->pointer_gestures,
+                            XI_GesturePinchBegin, fingers, 0, 0.0, 0.0, 0.0, 0.0,
+                            1.0, 0.0);
+}
+
+static void
+pointer_gesture_pinch_handle_update(void *data,
+                                    struct zwp_pointer_gesture_pinch_v1 *pinch,
+                                    uint32_t time,
+                                    wl_fixed_t dxf,
+                                    wl_fixed_t dyf,
+                                    wl_fixed_t scalef,
+                                    wl_fixed_t rotation)
+{
+    struct xwl_seat *xwl_seat = data;
+    double dx = wl_fixed_to_double(dxf);
+    double dy = wl_fixed_to_double(dyf);
+    double scale = wl_fixed_to_double(scalef);
+
+    xwl_seat->pointer_gesture_pinch_last_scale = scale;
+    QueueGesturePinchEvents(xwl_seat->pointer_gestures,
+                            XI_GesturePinchUpdate,
+                            xwl_seat->pointer_gesture_pinch_fingers,
+                            0,
+                            dx, dy,
+                            dx, dy,
+                            scale, wl_fixed_to_double(rotation));
+}
+
+static void
+pointer_gesture_pinch_handle_end(void *data,
+                                 struct zwp_pointer_gesture_pinch_v1 *pinch,
+                                 uint32_t serial,
+                                 uint32_t time,
+                                 int32_t cancelled)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t flags = 0;
+
+    if (cancelled)
+        flags |= XIGesturePinchEventCancelled;
+
+    QueueGesturePinchEvents(xwl_seat->pointer_gestures,
+                            XI_GesturePinchEnd,
+                            xwl_seat->pointer_gesture_pinch_fingers,
+                            flags, 0.0, 0.0, 0.0, 0.0,
+                            xwl_seat->pointer_gesture_pinch_last_scale, 0.0);
+}
+
+static const struct zwp_pointer_gesture_pinch_v1_listener pointer_gesture_pinch_listener = {
+    pointer_gesture_pinch_handle_begin,
+    pointer_gesture_pinch_handle_update,
+    pointer_gesture_pinch_handle_end
+};
+
+static void
+maybe_toggle_fake_grab(struct xwl_seat *xwl_seat, uint32_t key)
+{
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+    struct xwl_window *xwl_window;
+    XkbStateRec state_rec;
+    uint32_t xkb_state;
+
+    if (xwl_screen->rootless)
+        return;
+
+    if (!xwl_screen->host_grab)
+        return;
+
+    state_rec = xwl_seat->keyboard->key->xkbInfo->state;
+    xkb_state = (XkbStateFieldFromRec(&state_rec) & 0xff);
+
+    if (((key == KEY_LEFTSHIFT || key == KEY_RIGHTSHIFT) && (xkb_state & ControlMask)) ||
+        ((key == KEY_LEFTCTRL || key == KEY_RIGHTCTRL) && (xkb_state & ShiftMask))) {
+
+        xwl_screen->has_grab = !xwl_screen->has_grab;
+
+        if (xwl_screen->has_grab)
+            maybe_fake_grab_devices(xwl_seat);
+        else
+            maybe_fake_ungrab_devices(xwl_seat);
+
+        xwl_window = xwl_window_get(xwl_screen->screen->root);
+        if (xwl_window)
+            xwl_window_rootful_update_title(xwl_window);
+    }
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard, uint32_t serial,
+                    uint32_t time, uint32_t key, uint32_t state)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k, *end;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    end = (uint32_t *) ((char *) xwl_seat->keys.data + xwl_seat->keys.size);
+    for (k = xwl_seat->keys.data; k < end; k++) {
+        if (*k == key)
+            *k = *--end;
+    }
+    xwl_seat->keys.size = (char *) end - (char *) xwl_seat->keys.data;
+    if (state) {
+        k = wl_array_add(&xwl_seat->keys, sizeof *k);
+        *k = key;
+    }
+
+    QueueKeyboardEvents(xwl_seat->keyboard,
+                        state ? KeyPress : KeyRelease, key + 8);
+
+    if (!state)
+        maybe_toggle_fake_grab(xwl_seat, key);
+}
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                       uint32_t format, int fd, uint32_t size)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr master;
+    XkbDescPtr xkb;
+    XkbChangesRec changes = { 0 };
+
+    if (xwl_seat->keymap)
+        munmap(xwl_seat->keymap, xwl_seat->keymap_size);
+
+    xwl_seat->keymap_size = size;
+    xwl_seat->keymap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+    if (xwl_seat->keymap == MAP_FAILED) {
+        xwl_seat->keymap_size = 0;
+        xwl_seat->keymap = NULL;
+        goto out;
+    }
+
+    xkb = XkbCompileKeymapFromString(xwl_seat->keyboard, xwl_seat->keymap,
+                                     strnlen(xwl_seat->keymap,
+                                             xwl_seat->keymap_size));
+    if (!xkb)
+        goto out;
+
+    XkbUpdateDescActions(xkb, xkb->min_key_code, XkbNumKeys(xkb), &changes);
+
+    if (xwl_seat->keyboard->key)
+        /* Keep the current controls */
+        XkbCopyControls(xkb, xwl_seat->keyboard->key->xkbInfo->desc);
+
+    XkbDeviceApplyKeymap(xwl_seat->keyboard, xkb);
+
+    master = GetMaster(xwl_seat->keyboard, MASTER_KEYBOARD);
+    if (master)
+        XkbDeviceApplyKeymap(master, xkb);
+
+    XkbFreeKeyboard(xkb, XkbAllComponentsMask, TRUE);
+
+ out:
+    close(fd);
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial,
+                      struct wl_surface *surface, struct wl_array *keys)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k;
+
+    if (surface != NULL && !is_surface_from_xwl_window(surface))
+        return;
+
+    xwl_seat->xwl_screen->serial = serial;
+    xwl_seat->keyboard_focus = surface;
+
+    wl_array_copy(&xwl_seat->keys, keys);
+    wl_array_for_each(k, &xwl_seat->keys)
+        QueueKeyboardEvents(xwl_seat->keyboard, EnterNotify, *k + 8);
+
+    maybe_fake_grab_devices(xwl_seat);
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial, struct wl_surface *surface)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    wl_array_for_each(k, &xwl_seat->keys)
+        QueueKeyboardEvents(xwl_seat->keyboard, LeaveNotify, *k + 8);
+
+    xwl_seat->keyboard_focus = NULL;
+
+    maybe_fake_ungrab_devices(xwl_seat);
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                          uint32_t serial, uint32_t mods_depressed,
+                          uint32_t mods_latched, uint32_t mods_locked,
+                          uint32_t group)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev;
+    XkbStateRec old_state, *new_state;
+    xkbStateNotify sn;
+    CARD16 changed;
+
+    mieqProcessInputEvents();
+
+    for (dev = inputInfo.devices; dev; dev = dev->next) {
+        if (dev != xwl_seat->keyboard &&
+            dev != GetMaster(xwl_seat->keyboard, MASTER_KEYBOARD))
+            continue;
+
+        old_state = dev->key->xkbInfo->state;
+        new_state = &dev->key->xkbInfo->state;
+
+        new_state->locked_group = group & XkbAllGroupsMask;
+        new_state->base_mods = mods_depressed & XkbAllModifiersMask;
+        new_state->locked_mods = mods_locked & XkbAllModifiersMask;
+        XkbLatchModifiers(dev, XkbAllModifiersMask,
+                          mods_latched & XkbAllModifiersMask);
+
+        XkbComputeDerivedState(dev->key->xkbInfo);
+
+        changed = XkbStateChangedFlags(&old_state, new_state);
+        if (!changed)
+            continue;
+
+        sn.keycode = 0;
+        sn.eventType = 0;
+        sn.requestMajor = XkbReqCode;
+        sn.requestMinor = X_kbLatchLockState;   /* close enough */
+        sn.changed = changed;
+        XkbSendStateNotify(dev, &sn);
+    }
+}
+
+static void
+remove_sync_pending(DeviceIntPtr dev)
+{
+    struct xwl_seat *xwl_seat = dev->public.devicePrivate;
+    struct sync_pending *p, *npd;
+
+    if (!xwl_seat)
+        return;
+
+    xorg_list_for_each_entry_safe(p, npd, &xwl_seat->sync_pending, l) {
+        if (p->pending_dev == dev) {
+            xorg_list_del(&xwl_seat->sync_pending);
+            free (p);
+            return;
+        }
+    }
+}
+
+static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+    DeviceIntPtr dev = (DeviceIntPtr) data;
+
+    remove_sync_pending(dev);
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+static Bool
+keyboard_check_repeat (DeviceIntPtr dev, XkbSrvInfoPtr xkbi, unsigned key)
+{
+    struct xwl_seat *xwl_seat = dev->public.devicePrivate;
+    struct xwl_screen *xwl_screen;
+    struct wl_callback *callback;
+    struct sync_pending *p;
+
+    if (!xwl_seat)
+        return FALSE;
+
+    /* Make sure we didn't miss a possible reply from the compositor */
+    xwl_screen = xwl_seat->xwl_screen;
+    xwl_sync_events (xwl_screen);
+
+    xorg_list_for_each_entry(p, &xwl_seat->sync_pending, l) {
+        if (p->pending_dev == dev) {
+            ErrorF("Key repeat discarded, Wayland compositor doesn't "
+                   "seem to be processing events fast enough!\n");
+
+            return FALSE;
+        }
+    }
+
+    p = xnfalloc(sizeof(struct sync_pending));
+    p->pending_dev = dev;
+    callback = wl_display_sync (xwl_screen->display);
+    xorg_list_add(&p->l, &xwl_seat->sync_pending);
+
+    wl_callback_add_listener(callback, &sync_listener, dev);
+
+    return TRUE;
+}
+
+static void
+keyboard_handle_repeat_info (void *data, struct wl_keyboard *keyboard,
+                             int32_t rate, int32_t delay)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev;
+    XkbControlsPtr ctrl;
+
+    if (rate < 0 || delay < 0) {
+        ErrorF("Wrong rate/delay: %d, %d\n", rate, delay);
+        return;
+    }
+
+    for (dev = inputInfo.devices; dev; dev = dev->next) {
+        if (dev != xwl_seat->keyboard &&
+            dev != GetMaster(xwl_seat->keyboard, MASTER_KEYBOARD))
+            continue;
+
+        if (rate != 0) {
+            ctrl = dev->key->xkbInfo->desc->ctrls;
+            ctrl->repeat_delay = delay;
+            /* rate is number of keys per second */
+            ctrl->repeat_interval = 1000 / rate;
+
+            XkbSetRepeatKeys(dev, -1, AutoRepeatModeOn);
+        } else
+            XkbSetRepeatKeys(dev, -1, AutoRepeatModeOff);
+    }
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+static struct xwl_touch *
+xwl_seat_lookup_touch(struct xwl_seat *xwl_seat, int32_t id)
+{
+    struct xwl_touch *xwl_touch, *next_xwl_touch;
+
+    xorg_list_for_each_entry_safe(xwl_touch, next_xwl_touch,
+                                  &xwl_seat->touches, link_touch) {
+        if (xwl_touch->id == id)
+            return xwl_touch;
+    }
+
+    return NULL;
+}
+
+static void
+xwl_touch_send_event(struct xwl_touch *xwl_touch,
+                     struct xwl_seat *xwl_seat, int type)
+{
+    double dx, dy, x, y;
+    ValuatorMask mask;
+
+    dx = xwl_touch->window->window->drawable.x;
+    dy = xwl_touch->window->window->drawable.y;
+
+    x = (dx + xwl_touch->x) * 0xFFFF / xwl_seat->xwl_screen->width;
+    y = (dy + xwl_touch->y) * 0xFFFF / xwl_seat->xwl_screen->height;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set_double(&mask, 0, x);
+    valuator_mask_set_double(&mask, 1, y);
+    QueueTouchEvents(xwl_seat->touch, type, xwl_touch->id, 0, &mask);
+}
+
+static void
+touch_handle_down(void *data, struct wl_touch *wl_touch,
+                  uint32_t serial, uint32_t time,
+                  struct wl_surface *surface,
+                  int32_t id, wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_touch *xwl_touch;
+
+    if (surface == NULL)
+        return;
+
+    if (!is_surface_from_xwl_window(surface))
+        return;
+
+    xwl_touch = calloc(1, sizeof *xwl_touch);
+    if (xwl_touch == NULL) {
+        ErrorF("%s: ENOMEM\n", __func__);
+        return;
+    }
+
+    xwl_touch->window = wl_surface_get_user_data(surface);
+    xwl_touch->id = id;
+    xwl_touch->x = wl_fixed_to_int(sx_w);
+    xwl_touch->y = wl_fixed_to_int(sy_w);
+    xorg_list_add(&xwl_touch->link_touch, &xwl_seat->touches);
+
+    xwl_touch_send_event(xwl_touch, xwl_seat, XI_TouchBegin);
+}
+
+static void
+touch_handle_up(void *data, struct wl_touch *wl_touch,
+                uint32_t serial, uint32_t time, int32_t id)
+{
+    struct xwl_touch *xwl_touch;
+    struct xwl_seat *xwl_seat = data;
+
+    xwl_touch = xwl_seat_lookup_touch(xwl_seat, id);
+
+    if (!xwl_touch)
+        return;
+
+    xwl_touch_send_event(xwl_touch, xwl_seat, XI_TouchEnd);
+    xorg_list_del(&xwl_touch->link_touch);
+    free(xwl_touch);
+}
+
+static void
+touch_handle_motion(void *data, struct wl_touch *wl_touch,
+                    uint32_t time, int32_t id,
+                    wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_touch *xwl_touch;
+
+    xwl_touch = xwl_seat_lookup_touch(xwl_seat, id);
+
+    if (!xwl_touch)
+        return;
+
+    xwl_touch->x = wl_fixed_to_int(sx_w);
+    xwl_touch->y = wl_fixed_to_int(sy_w);
+    xwl_touch_send_event(xwl_touch, xwl_seat, XI_TouchUpdate);
+}
+
+static void
+touch_handle_frame(void *data, struct wl_touch *wl_touch)
+{
+}
+
+static void
+touch_handle_cancel(void *data, struct wl_touch *wl_touch)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_touch *xwl_touch, *next_xwl_touch;
+
+    xorg_list_for_each_entry_safe(xwl_touch, next_xwl_touch,
+                                  &xwl_seat->touches, link_touch) {
+        /* We can't properly notify of cancellation to the X client
+         * once it thinks it has the ownership, send at least a
+         * TouchEnd event.
+         */
+        xwl_touch_send_event(xwl_touch, xwl_seat, XI_TouchEnd);
+        xorg_list_del(&xwl_touch->link_touch);
+        free(xwl_touch);
+    }
+}
+
+static const struct wl_touch_listener touch_listener = {
+    touch_handle_down,
+    touch_handle_up,
+    touch_handle_motion,
+    touch_handle_frame,
+    touch_handle_cancel
+};
+
+static struct xwl_seat *
+find_matching_seat(DeviceIntPtr device)
+{
+    DeviceIntPtr dev;
+
+    for (dev = inputInfo.devices; dev; dev = dev->next)
+        if (dev->deviceProc == xwl_keyboard_proc &&
+            device == GetMaster(dev, MASTER_KEYBOARD))
+                return (struct xwl_seat *) dev->public.devicePrivate;
+
+    return NULL;
+}
+
+static void
+release_grab(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->keyboard_grab)
+        zwp_xwayland_keyboard_grab_v1_destroy(xwl_seat->keyboard_grab);
+    xwl_seat->keyboard_grab = NULL;
+}
+
+static void
+set_grab(struct xwl_seat *xwl_seat, struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen;
+
+    if (!xwl_window)
+        return;
+
+    /* We already have a grab */
+    if (xwl_seat->keyboard_grab)
+        release_grab (xwl_seat);
+
+    xwl_screen = xwl_seat->xwl_screen;
+    xwl_seat->keyboard_grab =
+        zwp_xwayland_keyboard_grab_manager_v1_grab_keyboard(xwl_screen->wp_grab,
+                                                            xwl_window->surface,
+                                                            xwl_seat->seat);
+}
+
+static void
+find_toplevel_callback(void *resource, XID id, void *user_data)
+{
+    WindowPtr window = resource;
+    WindowPtr *toplevel = user_data;
+
+    /* Pick the first realized toplevel we find */
+    if (*toplevel == NullWindow && window->realized && xwl_window_is_toplevel(window))
+        *toplevel = window;
+}
+
+static WindowPtr
+xwl_keyboard_search_window(ClientPtr client)
+{
+    WindowPtr window = NullWindow;
+
+    FindClientResourcesByType(client, RT_WINDOW, find_toplevel_callback, &window);
+
+    return window;
+}
+
+static void
+xwl_keyboard_activate_grab(DeviceIntPtr device, GrabPtr grab, TimeStamp time, Bool passive)
+{
+    struct xwl_seat *xwl_seat = device->public.devicePrivate;
+    WindowPtr grab_window = grab->window;
+
+    /* We are not interested in passive grabs */
+    if (!passive) {
+        /* If the device is the MASTER_KEYBOARD, we don't have an xwl_seat */
+        if (xwl_seat == NULL)
+            xwl_seat = find_matching_seat(device);
+        if (xwl_seat) {
+            if (grab_window == xwl_seat->xwl_screen->screen->root)
+                grab_window = xwl_keyboard_search_window(GetCurrentClient());
+            if (grab_window)
+                set_grab(xwl_seat, xwl_window_from_window(grab_window));
+        }
+    }
+
+    ActivateKeyboardGrab(device, grab, time, passive);
+}
+
+static void
+xwl_keyboard_deactivate_grab(DeviceIntPtr device)
+{
+    struct xwl_seat *xwl_seat = device->public.devicePrivate;
+
+    /* If the device is the MASTER_KEYBOARD, we don't have an xwl_seat */
+    if (xwl_seat == NULL)
+        xwl_seat = find_matching_seat(device);
+    if (xwl_seat)
+        release_grab (xwl_seat);
+
+    DeactivateKeyboardGrab(device);
+}
+
+static void
+setup_keyboard_grab_handler (DeviceIntPtr device)
+{
+    device->deviceGrab.ActivateGrab = xwl_keyboard_activate_grab;
+    device->deviceGrab.DeactivateGrab = xwl_keyboard_deactivate_grab;
+}
+
+static DeviceIntPtr
+add_device(struct xwl_seat *xwl_seat,
+           const char *driver, DeviceProc device_proc)
+{
+    DeviceIntPtr dev = NULL;
+    static Atom type_atom;
+    char name[32];
+
+    dev = AddInputDevice(serverClient, device_proc, TRUE);
+    if (dev == NULL)
+        return NULL;
+
+    if (type_atom == None)
+        type_atom = MakeAtom(driver, strlen(driver), TRUE);
+    snprintf(name, sizeof name, "%s:%d", driver, xwl_seat->id);
+    AssignTypeAndName(dev, type_atom, name);
+    dev->public.devicePrivate = xwl_seat;
+    dev->type = SLAVE;
+    dev->spriteInfo->spriteOwner = FALSE;
+
+    return dev;
+}
+
+static void
+disable_device(DeviceIntPtr dev)
+{
+    DisableDevice(dev, TRUE);
+    dev->public.devicePrivate = NULL;
+}
+
+static void
+enable_device(struct xwl_seat *xwl_seat, DeviceIntPtr dev)
+{
+    dev->public.devicePrivate = xwl_seat;
+    EnableDevice(dev, TRUE);
+}
+
+
+static void
+init_pointer(struct xwl_seat *xwl_seat)
+{
+    xwl_seat->wl_pointer = wl_seat_get_pointer(xwl_seat->seat);
+    wl_pointer_add_listener(xwl_seat->wl_pointer,
+                            &pointer_listener, xwl_seat);
+
+    if (xwl_seat->pointer == NULL) {
+        xwl_seat_set_cursor(xwl_seat);
+        xwl_seat->pointer =
+            add_device(xwl_seat, "xwayland-pointer", xwl_pointer_proc);
+        ActivateDevice(xwl_seat->pointer, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->pointer);
+}
+
+static void
+release_pointer(struct xwl_seat *xwl_seat)
+{
+    wl_pointer_release(xwl_seat->wl_pointer);
+    xwl_seat->wl_pointer = NULL;
+
+    if (xwl_seat->pointer)
+        disable_device(xwl_seat->pointer);
+}
+
+static void
+init_relative_pointer(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->relative_pointer == NULL) {
+        xwl_seat->relative_pointer =
+            add_device(xwl_seat, "xwayland-relative-pointer",
+                       xwl_pointer_proc_relative);
+        ActivateDevice(xwl_seat->relative_pointer, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->relative_pointer);
+}
+
+static void
+init_relative_pointer_listener(struct xwl_seat *xwl_seat)
+{
+    struct zwp_relative_pointer_manager_v1 *relative_pointer_manager =
+        xwl_seat->xwl_screen->relative_pointer_manager;
+
+    if (relative_pointer_manager) {
+        xwl_seat->wp_relative_pointer =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                relative_pointer_manager, xwl_seat->wl_pointer);
+        zwp_relative_pointer_v1_add_listener(xwl_seat->wp_relative_pointer,
+                                             &relative_pointer_listener,
+                                             xwl_seat);
+    }
+}
+
+static void
+release_relative_pointer(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->wp_relative_pointer) {
+        zwp_relative_pointer_v1_destroy(xwl_seat->wp_relative_pointer);
+        xwl_seat->wp_relative_pointer = NULL;
+    }
+
+    if (xwl_seat->relative_pointer)
+        disable_device(xwl_seat->relative_pointer);
+}
+
+static void
+init_pointer_gestures_device(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->pointer_gestures == NULL) {
+        xwl_seat->pointer_gestures =
+            add_device(xwl_seat, "xwayland-pointer-gestures",
+                       xwl_pointer_proc_pointer_gestures);
+        ActivateDevice(xwl_seat->pointer_gestures, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->pointer_gestures);
+}
+
+static void
+init_pointer_gestures_listener(struct xwl_seat *xwl_seat)
+{
+    struct zwp_pointer_gestures_v1 *pointer_gestures =
+            xwl_seat->xwl_screen->pointer_gestures;
+
+    if (pointer_gestures && !xwl_seat->wp_pointer_gesture_swipe) {
+        xwl_seat->wp_pointer_gesture_swipe =
+                zwp_pointer_gestures_v1_get_swipe_gesture(pointer_gestures,
+                                                          xwl_seat->wl_pointer);
+        zwp_pointer_gesture_swipe_v1_set_user_data(xwl_seat->wp_pointer_gesture_swipe,
+                                                   xwl_seat);
+        zwp_pointer_gesture_swipe_v1_add_listener(xwl_seat->wp_pointer_gesture_swipe,
+                                                  &pointer_gesture_swipe_listener,
+                                                  xwl_seat);
+    }
+
+    if (pointer_gestures && !xwl_seat->wp_pointer_gesture_pinch) {
+        xwl_seat->wp_pointer_gesture_pinch =
+                zwp_pointer_gestures_v1_get_pinch_gesture(pointer_gestures,
+                                                          xwl_seat->wl_pointer);
+        zwp_pointer_gesture_pinch_v1_set_user_data(xwl_seat->wp_pointer_gesture_pinch,
+                                                   xwl_seat);
+        zwp_pointer_gesture_pinch_v1_add_listener(xwl_seat->wp_pointer_gesture_pinch,
+                                                  &pointer_gesture_pinch_listener,
+                                                  xwl_seat);
+    }
+}
+
+static void
+release_pointer_gestures_device(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->wp_pointer_gesture_swipe) {
+        zwp_pointer_gesture_swipe_v1_destroy(xwl_seat->wp_pointer_gesture_swipe);
+        xwl_seat->wp_pointer_gesture_swipe = NULL;
+    }
+
+    if (xwl_seat->wp_pointer_gesture_pinch) {
+        zwp_pointer_gesture_pinch_v1_destroy(xwl_seat->wp_pointer_gesture_pinch);
+        xwl_seat->wp_pointer_gesture_pinch = NULL;
+    }
+
+    if (xwl_seat->pointer_gestures)
+        disable_device(xwl_seat->pointer_gestures);
+}
+
+static void
+init_keyboard(struct xwl_seat *xwl_seat)
+{
+    DeviceIntPtr master;
+
+    xwl_seat->wl_keyboard = wl_seat_get_keyboard(xwl_seat->seat);
+    wl_keyboard_add_listener(xwl_seat->wl_keyboard,
+                             &keyboard_listener, xwl_seat);
+
+    if (xwl_seat->keyboard == NULL) {
+        xwl_seat->keyboard =
+            add_device(xwl_seat, "xwayland-keyboard", xwl_keyboard_proc);
+        ActivateDevice(xwl_seat->keyboard, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->keyboard);
+    xwl_seat->keyboard->key->xkbInfo->checkRepeat = keyboard_check_repeat;
+
+    if (xwl_seat->xwl_screen->wp_grab) {
+        /* We have Xwayland grab protocol supported by the compositor */
+        master = GetMaster(xwl_seat->keyboard, MASTER_KEYBOARD);
+        if (master)
+            setup_keyboard_grab_handler(master);
+    }
+}
+
+static void
+release_keyboard(struct xwl_seat *xwl_seat)
+{
+    release_grab(xwl_seat);
+    wl_keyboard_release(xwl_seat->wl_keyboard);
+    xwl_seat->wl_keyboard = NULL;
+
+    if (xwl_seat->keyboard) {
+        remove_sync_pending(xwl_seat->keyboard);
+        disable_device(xwl_seat->keyboard);
+    }
+}
+
+static void
+init_touch(struct xwl_seat *xwl_seat)
+{
+    xwl_seat->wl_touch = wl_seat_get_touch(xwl_seat->seat);
+    wl_touch_add_listener(xwl_seat->wl_touch,
+                          &touch_listener, xwl_seat);
+
+    if (xwl_seat->touch == NULL) {
+        xwl_seat->touch =
+            add_device(xwl_seat, "xwayland-touch", xwl_touch_proc);
+        ActivateDevice(xwl_seat->touch, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->touch);
+}
+
+static void
+release_touch(struct xwl_seat *xwl_seat)
+{
+    wl_touch_release(xwl_seat->wl_touch);
+    xwl_seat->wl_touch = NULL;
+
+    if (xwl_seat->touch)
+        disable_device(xwl_seat->touch);
+}
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+                         enum wl_seat_capability caps)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    if (caps & WL_SEAT_CAPABILITY_POINTER && xwl_seat->wl_pointer == NULL) {
+        init_pointer(xwl_seat);
+        init_relative_pointer(xwl_seat);
+        init_relative_pointer_listener(xwl_seat);
+        init_pointer_gestures_device(xwl_seat);
+        init_pointer_gestures_listener(xwl_seat);
+    } else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && xwl_seat->wl_pointer) {
+        release_pointer(xwl_seat);
+        release_relative_pointer(xwl_seat);
+        release_pointer_gestures_device(xwl_seat);
+    }
+
+    if (caps & WL_SEAT_CAPABILITY_KEYBOARD && xwl_seat->wl_keyboard == NULL) {
+        init_keyboard(xwl_seat);
+    } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && xwl_seat->wl_keyboard) {
+        release_keyboard(xwl_seat);
+    }
+
+    if (caps & WL_SEAT_CAPABILITY_TOUCH && xwl_seat->wl_touch == NULL) {
+        init_touch(xwl_seat);
+    } else if (!(caps & WL_SEAT_CAPABILITY_TOUCH) && xwl_seat->wl_touch) {
+        release_touch(xwl_seat);
+    }
+
+    xwl_seat->xwl_screen->expecting_event--;
+}
+
+static void
+seat_handle_name(void *data, struct wl_seat *seat,
+                 const char *name)
+{
+
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name
+};
+
+static void
+xwl_cursor_init(struct xwl_cursor *xwl_cursor, struct xwl_screen *xwl_screen,
+                void (* update_proc)(struct xwl_cursor *))
+{
+    xwl_cursor->surface = wl_compositor_create_surface(xwl_screen->compositor);
+    xwl_cursor->update_proc = update_proc;
+    xwl_cursor->frame_cb = NULL;
+    xwl_cursor->needs_update = FALSE;
+}
+
+static void
+xwl_seat_update_cursor(struct xwl_cursor *xwl_cursor)
+{
+    struct xwl_seat *xwl_seat = wl_container_of(xwl_cursor, xwl_seat, cursor);
+    xwl_seat_set_cursor(xwl_seat);
+}
+
+static void
+create_input_device(struct xwl_screen *xwl_screen, uint32_t id, uint32_t version)
+{
+    struct xwl_seat *xwl_seat;
+    int seat_version = 5;
+
+#ifdef XWL_HAS_WL_POINTER_AXIS_V120
+    seat_version = 8;
+#endif
+
+    xwl_seat = calloc(1, sizeof *xwl_seat);
+    if (xwl_seat == NULL) {
+        ErrorF("%s: ENOMEM\n", __func__);
+        return;
+    }
+
+    xwl_seat->xwl_screen = xwl_screen;
+    xorg_list_add(&xwl_seat->link, &xwl_screen->seat_list);
+
+    xwl_seat->seat =
+        wl_registry_bind(xwl_screen->registry, id,
+                         &wl_seat_interface, min(version, seat_version));
+    xwl_seat->id = id;
+
+    xwl_cursor_init(&xwl_seat->cursor, xwl_seat->xwl_screen,
+                    xwl_seat_update_cursor);
+    wl_seat_add_listener(xwl_seat->seat, &seat_listener, xwl_seat);
+
+    init_tablet_manager_seat(xwl_screen, xwl_seat);
+
+    wl_array_init(&xwl_seat->keys);
+
+    xorg_list_init(&xwl_seat->touches);
+    xorg_list_init(&xwl_seat->sync_pending);
+}
+
+void
+xwl_seat_destroy(struct xwl_seat *xwl_seat)
+{
+    struct xwl_touch *xwl_touch, *next_xwl_touch;
+    struct sync_pending *p, *npd;
+
+    xorg_list_for_each_entry_safe(xwl_touch, next_xwl_touch,
+                                  &xwl_seat->touches, link_touch) {
+        xorg_list_del(&xwl_touch->link_touch);
+        free(xwl_touch);
+    }
+
+    xorg_list_for_each_entry_safe(p, npd, &xwl_seat->sync_pending, l) {
+        xorg_list_del(&xwl_seat->sync_pending);
+        free (p);
+    }
+
+    release_tablet_manager_seat(xwl_seat);
+
+    release_grab(xwl_seat);
+    wl_seat_destroy(xwl_seat->seat);
+    xwl_cursor_release(&xwl_seat->cursor);
+    wl_array_release(&xwl_seat->keys);
+    free(xwl_seat);
+}
+
+static void
+tablet_handle_name(void *data, struct zwp_tablet_v2 *tablet, const char *name)
+{
+}
+
+static void
+tablet_handle_id(void *data, struct zwp_tablet_v2 *tablet, uint32_t vid,
+                  uint32_t pid)
+{
+}
+
+static void
+tablet_handle_path(void *data, struct zwp_tablet_v2 *tablet, const char *path)
+{
+}
+
+static void
+tablet_handle_done(void *data, struct zwp_tablet_v2 *tablet)
+{
+    struct xwl_tablet *xwl_tablet = data;
+    struct xwl_seat *xwl_seat = xwl_tablet->seat;
+
+    if (xwl_seat->stylus == NULL) {
+        xwl_seat->stylus = add_device(xwl_seat, "xwayland-tablet stylus", xwl_tablet_proc);
+        ActivateDevice(xwl_seat->stylus, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->stylus);
+
+    if (xwl_seat->eraser == NULL) {
+        xwl_seat->eraser = add_device(xwl_seat, "xwayland-tablet eraser", xwl_tablet_proc);
+        ActivateDevice(xwl_seat->eraser, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->eraser);
+
+    if (xwl_seat->puck == NULL) {
+        xwl_seat->puck = add_device(xwl_seat, "xwayland-tablet cursor", xwl_tablet_proc);
+        ActivateDevice(xwl_seat->puck, TRUE);
+    }
+    enable_device(xwl_seat, xwl_seat->puck);
+}
+
+static void
+tablet_handle_removed(void *data, struct zwp_tablet_v2 *tablet)
+{
+    struct xwl_tablet *xwl_tablet = data;
+    struct xwl_seat *xwl_seat = xwl_tablet->seat;
+
+    xorg_list_del(&xwl_tablet->link);
+
+    /* The tablet is merely disabled, not removed. The next tablet
+       will re-use the same X devices */
+    if (xorg_list_is_empty(&xwl_seat->tablets)) {
+        if (xwl_seat->stylus)
+            disable_device(xwl_seat->stylus);
+        if (xwl_seat->eraser)
+            disable_device(xwl_seat->eraser);
+        if (xwl_seat->puck)
+            disable_device(xwl_seat->puck);
+        /* pads are removed separately */
+    }
+
+    zwp_tablet_v2_destroy(tablet);
+    free(xwl_tablet);
+}
+
+static const struct zwp_tablet_v2_listener tablet_listener = {
+    tablet_handle_name,
+    tablet_handle_id,
+    tablet_handle_path,
+    tablet_handle_done,
+    tablet_handle_removed
+};
+
+static void
+tablet_tool_receive_type(void *data, struct zwp_tablet_tool_v2 *tool,
+                         uint32_t type)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    switch (type) {
+        case ZWP_TABLET_TOOL_V2_TYPE_ERASER:
+            xwl_tablet_tool->xdevice = xwl_seat->eraser;
+            break;
+        case ZWP_TABLET_TOOL_V2_TYPE_MOUSE:
+        case ZWP_TABLET_TOOL_V2_TYPE_LENS:
+            xwl_tablet_tool->xdevice = xwl_seat->puck;
+            break;
+        default:
+            xwl_tablet_tool->xdevice = xwl_seat->stylus;
+            break;
+    }
+}
+
+static void
+tablet_tool_receive_hardware_serial(void *data, struct zwp_tablet_tool_v2 *tool,
+                                    uint32_t hi, uint32_t low)
+{
+}
+
+static void
+tablet_tool_receive_hardware_id_wacom(void *data, struct zwp_tablet_tool_v2 *tool,
+                                      uint32_t hi, uint32_t low)
+{
+}
+
+static void
+tablet_tool_receive_capability(void *data, struct zwp_tablet_tool_v2 *tool,
+                               uint32_t capability)
+{
+}
+
+static void
+tablet_tool_receive_done(void *data, struct zwp_tablet_tool_v2 *tool)
+{
+}
+
+static void
+tablet_tool_receive_removed(void *data, struct zwp_tablet_tool_v2 *tool)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+
+    xorg_list_del(&xwl_tablet_tool->link);
+    xwl_cursor_release(&xwl_tablet_tool->cursor);
+    zwp_tablet_tool_v2_destroy(tool);
+    free(xwl_tablet_tool);
+}
+
+static void
+tablet_tool_proximity_in(void *data, struct zwp_tablet_tool_v2 *tool,
+                         uint32_t serial, struct zwp_tablet_v2 *tablet,
+                         struct wl_surface *wl_surface)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    /* There's a race here where if we create and then immediately
+     * destroy a surface, we might end up in a state where the Wayland
+     * compositor sends us an event for a surface that doesn't exist.
+     *
+     * Don't process enter events in this case.
+     *
+     * see pointer_handle_enter()
+     */
+    if (wl_surface == NULL)
+        return;
+
+    if (!is_surface_from_xwl_window(wl_surface))
+        return;
+
+    xwl_tablet_tool->proximity_in_serial = serial;
+    xwl_seat->tablet_focus_window = wl_surface_get_user_data(wl_surface);
+
+    /* If there is a cursor surface frame callback pending, we need to clear it
+     * so that we can continue submitting new cursor frames.
+     */
+    xwl_cursor_clear_frame_cb(&xwl_tablet_tool->cursor);
+    xwl_tablet_tool_set_cursor(xwl_tablet_tool);
+}
+
+static void
+tablet_tool_proximity_out(void *data, struct zwp_tablet_tool_v2 *tool)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    xwl_tablet_tool->proximity_in_serial = 0;
+    xwl_seat->tablet_focus_window = NULL;
+
+    xwl_tablet_tool->pressure = 0;
+    xwl_tablet_tool->tilt_x = 0;
+    xwl_tablet_tool->tilt_y = 0;
+    xwl_tablet_tool->rotation = 0;
+    xwl_tablet_tool->slider = 0;
+}
+
+static void
+tablet_tool_down(void *data, struct zwp_tablet_tool_v2 *tool, uint32_t serial)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    ValuatorMask mask;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    valuator_mask_zero(&mask);
+    QueuePointerEvents(xwl_tablet_tool->xdevice, ButtonPress, 1, 0, &mask);
+}
+
+static void
+tablet_tool_up(void *data, struct zwp_tablet_tool_v2 *tool)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    ValuatorMask mask;
+
+    valuator_mask_zero(&mask);
+    QueuePointerEvents(xwl_tablet_tool->xdevice, ButtonRelease, 1, 0, &mask);
+}
+
+static void
+tablet_tool_motion(void *data, struct zwp_tablet_tool_v2 *tool,
+                   wl_fixed_t x, wl_fixed_t y)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    int32_t dx, dy;
+    double sx = wl_fixed_to_double(x);
+    double sy = wl_fixed_to_double(y);
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    dx = xwl_seat->tablet_focus_window->window->drawable.x;
+    dy = xwl_seat->tablet_focus_window->window->drawable.y;
+
+    xwl_tablet_tool->x = (double) dx + sx;
+    xwl_tablet_tool->y = (double) dy + sy;
+}
+
+static void
+tablet_tool_pressure(void *data, struct zwp_tablet_tool_v2 *tool,
+                     uint32_t pressure)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    /* normalized to 65535 already */
+    xwl_tablet_tool->pressure = pressure;
+}
+
+static void
+tablet_tool_distance(void *data, struct zwp_tablet_tool_v2 *tool,
+                     uint32_t distance_raw)
+{
+}
+
+static void
+tablet_tool_tilt(void *data, struct zwp_tablet_tool_v2 *tool,
+                 wl_fixed_t tilt_x, wl_fixed_t tilt_y)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    xwl_tablet_tool->tilt_x = wl_fixed_to_double(tilt_x);
+    xwl_tablet_tool->tilt_y = wl_fixed_to_double(tilt_y);
+}
+
+static void
+tablet_tool_rotation(void *data, struct zwp_tablet_tool_v2 *tool,
+                     wl_fixed_t angle)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    double rotation = wl_fixed_to_double(angle);
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    /* change origin (buttons facing right [libinput +90 degrees]) and
+     * scaling (5 points per degree) to match wacom driver behavior
+     */
+    rotation = remainderf(rotation + 90.0f, 360.0f);
+    rotation *= 5.0f;
+    xwl_tablet_tool->rotation = rotation;
+}
+
+static void
+tablet_tool_slider(void *data, struct zwp_tablet_tool_v2 *tool,
+                   int32_t position_raw)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    float position = position_raw / 65535.0;
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    xwl_tablet_tool->slider = (position * 1799.0f) - 900.0f;
+}
+
+static void
+tablet_tool_wheel(void *data, struct zwp_tablet_tool_v2 *tool,
+                  wl_fixed_t degrees, int32_t clicks)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+
+    if (!xwl_seat->tablet_focus_window)
+        return;
+
+    xwl_tablet_tool->wheel_clicks = clicks;
+}
+
+static void
+tablet_tool_button_state(void *data, struct zwp_tablet_tool_v2 *tool,
+                         uint32_t serial, uint32_t button, uint32_t state)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    struct xwl_seat *xwl_seat = xwl_tablet_tool->seat;
+    uint32_t *mask = &xwl_tablet_tool->buttons_now;
+    int xbtn = 0;
+
+    /* BTN_0 .. BTN_9 */
+    if (button >= 0x100 && button <= 0x109) {
+        xbtn = button - 0x100 + 1;
+    }
+    /* BTN_A .. BTN_Z */
+    else if (button >= 0x130 && button <= 0x135) {
+        xbtn = button - 0x130 + 10;
+    }
+    /* BTN_BASE .. BTN_BASE6 */
+    else if (button >= 0x126 && button <= 0x12b) {
+        xbtn = button - 0x126 + 16;
+    }
+    else {
+        switch (button) {
+        case 0x110: /* BTN_LEFT    */
+        case 0x14a: /* BTN_TOUCH   */
+            xbtn = 1;
+            break;
+
+        case 0x112: /* BTN_MIDDLE  */
+        case 0x14b: /* BTN_STYLUS  */
+            xbtn = 2;
+            break;
+
+        case 0x111: /* BTN_RIGHT   */
+        case 0x14c: /* BTN_STYLUS2 */
+            xbtn = 3;
+            break;
+
+        case 0x113: /* BTN_SIDE    */
+        case 0x116: /* BTN_BACK    */
+        case 0x149: /* BTN_STYLUS3 */
+            xbtn = 8;
+            break;
+
+        case 0x114: /* BTN_EXTRA   */
+        case 0x115: /* BTN_FORWARD */
+            xbtn = 9;
+            break;
+        }
+    }
+
+    if (!xbtn) {
+        ErrorF("unknown tablet button number %d\n", button);
+        return;
+    }
+
+    BUG_RETURN(xbtn >= 8 * sizeof(*mask));
+
+    if (state)
+        SetBit(mask, xbtn - 1);
+    else
+        ClearBit(mask, xbtn - 1);
+
+    xwl_seat->xwl_screen->serial = serial;
+}
+
+static void
+tablet_tool_frame(void *data, struct zwp_tablet_tool_v2 *tool, uint32_t time)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = data;
+    ValuatorMask mask;
+    uint32_t released, pressed, diff;
+    int button;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set_double(&mask, 0, xwl_tablet_tool->x);
+    valuator_mask_set_double(&mask, 1, xwl_tablet_tool->y);
+    valuator_mask_set(&mask, 2, xwl_tablet_tool->pressure);
+    valuator_mask_set_double(&mask, 3, xwl_tablet_tool->tilt_x);
+    valuator_mask_set_double(&mask, 4, xwl_tablet_tool->tilt_y);
+    valuator_mask_set_double(&mask, 5, xwl_tablet_tool->rotation + xwl_tablet_tool->slider);
+
+    QueuePointerEvents(xwl_tablet_tool->xdevice, MotionNotify, 0,
+               POINTER_ABSOLUTE | POINTER_DESKTOP, &mask);
+
+    valuator_mask_zero(&mask);
+
+    diff = xwl_tablet_tool->buttons_prev ^ xwl_tablet_tool->buttons_now;
+    released = diff & ~xwl_tablet_tool->buttons_now;
+    pressed = diff & xwl_tablet_tool->buttons_now;
+
+    button = 1;
+    while (released) {
+        if (released & 0x1)
+            QueuePointerEvents(xwl_tablet_tool->xdevice,
+                               ButtonRelease, button, 0, &mask);
+        button++;
+        released >>= 1;
+    }
+
+    button = 1;
+    while (pressed) {
+        if (pressed & 0x1)
+            QueuePointerEvents(xwl_tablet_tool->xdevice,
+                               ButtonPress, button, 0, &mask);
+        button++;
+        pressed >>= 1;
+    }
+
+    xwl_tablet_tool->buttons_prev = xwl_tablet_tool->buttons_now;
+
+    while (xwl_tablet_tool->wheel_clicks) {
+            if (xwl_tablet_tool->wheel_clicks < 0) {
+                button = 4;
+                xwl_tablet_tool->wheel_clicks++;
+            }
+            else {
+                button = 5;
+                xwl_tablet_tool->wheel_clicks--;
+            }
+
+            QueuePointerEvents(xwl_tablet_tool->xdevice,
+                               ButtonPress, button, 0, &mask);
+            QueuePointerEvents(xwl_tablet_tool->xdevice,
+                               ButtonRelease, button, 0, &mask);
+
+    }
+}
+
+static const struct zwp_tablet_tool_v2_listener tablet_tool_listener = {
+    tablet_tool_receive_type,
+    tablet_tool_receive_hardware_serial,
+    tablet_tool_receive_hardware_id_wacom,
+    tablet_tool_receive_capability,
+    tablet_tool_receive_done,
+    tablet_tool_receive_removed,
+    tablet_tool_proximity_in,
+    tablet_tool_proximity_out,
+    tablet_tool_down,
+    tablet_tool_up,
+    tablet_tool_motion,
+    tablet_tool_pressure,
+    tablet_tool_distance,
+    tablet_tool_tilt,
+    tablet_tool_rotation,
+    tablet_tool_slider,
+    tablet_tool_wheel,
+    tablet_tool_button_state,
+    tablet_tool_frame
+};
+
+static void
+tablet_pad_ring_destroy(struct xwl_tablet_pad_ring *ring)
+{
+    zwp_tablet_pad_ring_v2_destroy(ring->ring);
+    xorg_list_del(&ring->link);
+    free(ring);
+}
+
+static void
+tablet_pad_ring_source(void *data,
+                       struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+                       uint32_t source)
+{
+}
+
+static void
+tablet_pad_ring_angle(void *data,
+                      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+                      wl_fixed_t degrees)
+{
+    struct xwl_tablet_pad_ring *ring = data;
+    struct xwl_tablet_pad *pad = ring->group->pad;
+    double deg = wl_fixed_to_double(degrees);
+    ValuatorMask mask;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 5 + ring->index, deg/360.0  * 71);
+    QueuePointerEvents(pad->xdevice, MotionNotify, 0, 0, &mask);
+}
+
+static void
+tablet_pad_ring_stop(void *data,
+                     struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+}
+
+static void
+tablet_pad_ring_frame(void *data,
+                      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+                      uint32_t time)
+{
+}
+
+static const struct zwp_tablet_pad_ring_v2_listener tablet_pad_ring_listener = {
+    tablet_pad_ring_source,
+    tablet_pad_ring_angle,
+    tablet_pad_ring_stop,
+    tablet_pad_ring_frame,
+};
+
+
+static void
+tablet_pad_strip_destroy(struct xwl_tablet_pad_strip *strip)
+{
+    zwp_tablet_pad_strip_v2_destroy(strip->strip);
+    xorg_list_del(&strip->link);
+    free(strip);
+}
+
+static void
+tablet_pad_strip_source(void *data,
+                        struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+                        uint32_t source)
+{
+}
+
+static void
+tablet_pad_strip_position(void *data,
+                          struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+                          uint32_t position)
+{
+    struct xwl_tablet_pad_strip *strip = data;
+    struct xwl_tablet_pad *pad = strip->group->pad;
+    ValuatorMask mask;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 3 + strip->index, position/65535.0 * 2048);
+    QueuePointerEvents(pad->xdevice, MotionNotify, 0, 0, &mask);
+}
+
+static void
+tablet_pad_strip_stop(void *data,
+                      struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+}
+
+static void
+tablet_pad_strip_frame(void *data,
+                       struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+                       uint32_t time)
+{
+}
+
+static const struct zwp_tablet_pad_strip_v2_listener tablet_pad_strip_listener = {
+    tablet_pad_strip_source,
+    tablet_pad_strip_position,
+    tablet_pad_strip_stop,
+    tablet_pad_strip_frame,
+};
+
+static void
+tablet_pad_group_destroy(struct xwl_tablet_pad_group *group)
+{
+    struct xwl_tablet_pad_ring *r, *tr;
+    struct xwl_tablet_pad_strip *s, *ts;
+
+    xorg_list_for_each_entry_safe(r, tr,
+                                  &group->pad_group_ring_list,
+                                  link)
+        tablet_pad_ring_destroy(r);
+
+    xorg_list_for_each_entry_safe(s, ts,
+                                  &group->pad_group_strip_list,
+                                  link)
+        tablet_pad_strip_destroy(s);
+
+    zwp_tablet_pad_group_v2_destroy(group->group);
+    xorg_list_del(&group->link);
+    free(group);
+}
+
+static void
+tablet_pad_group_buttons(void *data,
+                         struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+                         struct wl_array *buttons)
+{
+
+}
+
+static void
+tablet_pad_group_ring(void *data,
+                      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+                      struct zwp_tablet_pad_ring_v2 *wp_ring)
+{
+    static unsigned int ring_index = 0;
+    struct xwl_tablet_pad_group *group = data;
+    struct xwl_tablet_pad_ring *ring;
+
+    ring = calloc(1, sizeof *ring);
+    if (ring == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    ring->index = ring_index++;
+    ring->group = group;
+    ring->ring = wp_ring;
+
+    xorg_list_add(&ring->link, &group->pad_group_ring_list);
+
+    zwp_tablet_pad_ring_v2_add_listener(wp_ring, &tablet_pad_ring_listener,
+                                        ring);
+}
+
+static void
+tablet_pad_group_strip(void *data,
+                       struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+                       struct zwp_tablet_pad_strip_v2 *wp_strip)
+{
+    static unsigned int strip_index = 0;
+    struct xwl_tablet_pad_group *group = data;
+    struct xwl_tablet_pad_strip *strip;
+
+    strip = calloc(1, sizeof *strip);
+    if (strip == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    strip->index = strip_index++;
+    strip->group = group;
+    strip->strip = wp_strip;
+
+    xorg_list_add(&strip->link, &group->pad_group_strip_list);
+
+    zwp_tablet_pad_strip_v2_add_listener(wp_strip, &tablet_pad_strip_listener,
+                                         strip);
+}
+
+static void
+tablet_pad_group_modes(void *data,
+                       struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+                       uint32_t modes)
+{
+
+}
+
+static void
+tablet_pad_group_done(void *data,
+                      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+
+}
+
+static void
+tablet_pad_group_mode_switch(void *data,
+                             struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+                             uint32_t time,
+                             uint32_t serial,
+                             uint32_t mode)
+{
+
+}
+
+static struct zwp_tablet_pad_group_v2_listener tablet_pad_group_listener = {
+    tablet_pad_group_buttons,
+    tablet_pad_group_ring,
+    tablet_pad_group_strip,
+    tablet_pad_group_modes,
+    tablet_pad_group_done,
+    tablet_pad_group_mode_switch,
+};
+
+static int
+xwl_tablet_pad_proc(DeviceIntPtr device, int what)
+{
+    struct xwl_tablet_pad *pad = dixGetPrivate(&device->devPrivates,
+                                               &xwl_tablet_private_key);
+    /* Axis layout mirrors that of xf86-input-wacom to have better
+       compatibility with existing clients */
+#define NAXES 7
+    Atom axes_labels[NAXES] = { 0 };
+    BYTE map[MAX_BUTTONS + 1];
+    int i = 0;
+    Atom btn_labels[MAX_BUTTONS] = { 0 }; /* btn labels are meaningless */
+    int nbuttons;
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
+        /* The others have no good mapping */
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, axes_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        for (i = 1; i <= MAX_BUTTONS; i++)
+            map[i] = i;
+
+        /* We need at least 7 buttons to allow scrolling */
+        nbuttons = min(max(pad->nbuttons + 4, 7), MAX_BUTTONS);
+
+        if (!InitButtonClassDeviceStruct(device, nbuttons,
+                                         btn_labels, map))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 100, 1, 0, 1, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 100, 1, 0, 1, Absolute);
+        /* Pressure - unused, for backwards compat only */
+        InitValuatorAxisStruct(device, 2, axes_labels[2],
+                               0, 2048, 1, 0, 1, Absolute);
+        /* strip x */
+        InitValuatorAxisStruct(device, 3, axes_labels[3],
+                               0, 2048, 1, 0, 1, Absolute);
+        /* strip y */
+        InitValuatorAxisStruct(device, 4, axes_labels[4],
+                               0, 2048, 1, 0, 1, Absolute);
+        /* ring */
+        InitValuatorAxisStruct(device, 5, axes_labels[5],
+                               0, 71, 1, 0, 1, Absolute);
+        /* ring2 */
+        InitValuatorAxisStruct(device, 6, axes_labels[6],
+                               0, 71, 1, 0, 1, Absolute);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+#undef NAXES
+}
+
+static void
+tablet_pad_group(void *data,
+                 struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                 struct zwp_tablet_pad_group_v2 *pad_group)
+{
+    struct xwl_tablet_pad *pad = data;
+    struct xwl_tablet_pad_group *group;
+
+    group = calloc(1, sizeof *group);
+    if (group == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    group->pad = pad;
+    group->group = pad_group;
+    xorg_list_init(&group->pad_group_ring_list);
+    xorg_list_init(&group->pad_group_strip_list);
+
+    xorg_list_add(&group->link, &pad->pad_group_list);
+
+    zwp_tablet_pad_group_v2_add_listener(pad_group,
+                                         &tablet_pad_group_listener,
+                                         group);
+}
+
+static void
+tablet_pad_path(void *data,
+                struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                const char *path)
+{
+
+}
+
+static void
+tablet_pad_buttons(void *data,
+                   struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                   uint32_t buttons)
+{
+    struct xwl_tablet_pad *pad = data;
+
+    pad->nbuttons = buttons;
+}
+
+static void
+tablet_pad_done(void *data,
+                struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+    struct xwl_tablet_pad *pad = data;
+
+    pad->xdevice = add_device(pad->seat, "xwayland-tablet-pad",
+                              xwl_tablet_pad_proc);
+    dixSetPrivate(&pad->xdevice->devPrivates, &xwl_tablet_private_key, pad);
+    ActivateDevice(pad->xdevice, TRUE);
+    EnableDevice(pad->xdevice, TRUE);
+}
+
+static void
+tablet_pad_button(void *data,
+                  struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                  uint32_t time,
+                  uint32_t button,
+                  uint32_t state)
+{
+    struct xwl_tablet_pad *pad = data;
+    ValuatorMask mask;
+
+    button++; /* wayland index vs X's 1-offset */
+    /* skip scroll wheel buttons 4-7 */
+    button = button > 3 ? button + 4 : button;
+
+    valuator_mask_zero(&mask);
+    QueuePointerEvents(pad->xdevice,
+                       state ? ButtonPress : ButtonRelease, button, 0, &mask);
+}
+
+static void
+tablet_pad_enter(void *data,
+                 struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                 uint32_t serial,
+                 struct zwp_tablet_v2 *tablet,
+                 struct wl_surface *surface)
+{
+    /* pairs the pad with the tablet but also to set the focus. We
+     * don't care about the pairing and always use X's focus */
+}
+
+static void
+tablet_pad_leave(void *data,
+                 struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+                 uint32_t serial,
+                 struct wl_surface *surface)
+{
+    /* pairs the pad with the tablet but also to set the focus. We
+     * don't care about the pairing and always use X's focus */
+}
+
+static void
+tablet_pad_removed(void *data,
+                   struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+    struct xwl_tablet_pad *pad = data;
+    struct xwl_tablet_pad_group *g, *tg;
+
+    xorg_list_for_each_entry_safe(g, tg, &pad->pad_group_list, link)
+        tablet_pad_group_destroy(g);
+
+    RemoveDevice(pad->xdevice, TRUE);
+    xorg_list_del(&pad->link);
+    zwp_tablet_pad_v2_destroy(pad->pad);
+    free(pad);
+}
+
+static const struct zwp_tablet_pad_v2_listener tablet_pad_listener = {
+    tablet_pad_group,
+    tablet_pad_path,
+    tablet_pad_buttons,
+    tablet_pad_done,
+    tablet_pad_button,
+    tablet_pad_enter,
+    tablet_pad_leave,
+    tablet_pad_removed,
+};
+
+static void
+tablet_seat_handle_add_tablet(void *data, struct zwp_tablet_seat_v2 *tablet_seat,
+                              struct zwp_tablet_v2 *tablet)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_tablet *xwl_tablet;
+
+    xwl_tablet = calloc(sizeof *xwl_tablet, 1);
+    if (xwl_tablet == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    xwl_tablet->tablet = tablet;
+    xwl_tablet->seat = xwl_seat;
+
+    xorg_list_add(&xwl_tablet->link, &xwl_seat->tablets);
+
+    zwp_tablet_v2_add_listener(tablet, &tablet_listener, xwl_tablet);
+}
+
+static void
+xwl_tablet_tool_update_cursor(struct xwl_cursor *xwl_cursor)
+{
+    struct xwl_tablet_tool *xwl_tablet_tool = wl_container_of(xwl_cursor,
+                                                              xwl_tablet_tool,
+                                                              cursor);
+    xwl_tablet_tool_set_cursor(xwl_tablet_tool);
+}
+
+static void
+tablet_seat_handle_add_tool(void *data, struct zwp_tablet_seat_v2 *tablet_seat,
+                            struct zwp_tablet_tool_v2 *tool)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+    struct xwl_tablet_tool *xwl_tablet_tool;
+
+    xwl_tablet_tool = calloc(sizeof *xwl_tablet_tool, 1);
+    if (xwl_tablet_tool == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    xwl_tablet_tool->tool = tool;
+    xwl_tablet_tool->seat = xwl_seat;
+    xwl_cursor_init(&xwl_tablet_tool->cursor, xwl_screen,
+                    xwl_tablet_tool_update_cursor);
+
+    xorg_list_add(&xwl_tablet_tool->link, &xwl_seat->tablet_tools);
+
+    zwp_tablet_tool_v2_add_listener(tool, &tablet_tool_listener, xwl_tablet_tool);
+}
+
+static void
+tablet_seat_handle_add_pad(void *data, struct zwp_tablet_seat_v2 *tablet_seat,
+                           struct zwp_tablet_pad_v2 *pad)
+{
+    struct xwl_seat *xwl_seat = data;
+    struct xwl_tablet_pad *xwl_tablet_pad;
+
+    xwl_tablet_pad = calloc(sizeof *xwl_tablet_pad, 1);
+    if (xwl_tablet_pad == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return;
+    }
+
+    xwl_tablet_pad->pad = pad;
+    xwl_tablet_pad->seat = xwl_seat;
+    xorg_list_init(&xwl_tablet_pad->pad_group_list);
+
+    xorg_list_add(&xwl_tablet_pad->link, &xwl_seat->tablet_pads);
+
+    zwp_tablet_pad_v2_add_listener(pad, &tablet_pad_listener,
+                                   xwl_tablet_pad);
+}
+
+static const struct zwp_tablet_seat_v2_listener tablet_seat_listener = {
+    tablet_seat_handle_add_tablet,
+    tablet_seat_handle_add_tool,
+    tablet_seat_handle_add_pad
+};
+
+static void
+init_tablet_manager_seat(struct xwl_screen *xwl_screen,
+                         struct xwl_seat *xwl_seat)
+{
+    xorg_list_init(&xwl_seat->tablets);
+    xorg_list_init(&xwl_seat->tablet_tools);
+    xorg_list_init(&xwl_seat->tablet_pads);
+
+    if (!xwl_screen->tablet_manager)
+        return;
+
+    xwl_seat->tablet_seat =
+        zwp_tablet_manager_v2_get_tablet_seat(xwl_screen->tablet_manager,
+                                              xwl_seat->seat);
+
+    zwp_tablet_seat_v2_add_listener(xwl_seat->tablet_seat, &tablet_seat_listener, xwl_seat);
+}
+
+static void
+release_tablet_manager_seat(struct xwl_seat *xwl_seat)
+{
+    struct xwl_tablet *xwl_tablet, *next_xwl_tablet;
+    struct xwl_tablet_tool *xwl_tablet_tool, *next_xwl_tablet_tool;
+    struct xwl_tablet_pad *xwl_tablet_pad, *next_xwl_tablet_pad;
+
+    xorg_list_for_each_entry_safe(xwl_tablet_pad, next_xwl_tablet_pad,
+                                  &xwl_seat->tablet_pads, link) {
+        xorg_list_del(&xwl_tablet_pad->link);
+        zwp_tablet_pad_v2_destroy(xwl_tablet_pad->pad);
+        free(xwl_tablet_pad);
+    }
+
+    xorg_list_for_each_entry_safe(xwl_tablet_tool, next_xwl_tablet_tool,
+                                  &xwl_seat->tablet_tools, link) {
+        xorg_list_del(&xwl_tablet_tool->link);
+        zwp_tablet_tool_v2_destroy(xwl_tablet_tool->tool);
+        free(xwl_tablet_tool);
+    }
+
+    xorg_list_for_each_entry_safe(xwl_tablet, next_xwl_tablet,
+                                  &xwl_seat->tablets, link) {
+        xorg_list_del(&xwl_tablet->link);
+        zwp_tablet_v2_destroy(xwl_tablet->tablet);
+        free(xwl_tablet);
+    }
+
+    if (xwl_seat->tablet_seat) {
+        zwp_tablet_seat_v2_destroy(xwl_seat->tablet_seat);
+        xwl_seat->tablet_seat = NULL;
+    }
+}
+
+static void
+init_tablet_manager(struct xwl_screen *xwl_screen, uint32_t id, uint32_t version)
+{
+    struct xwl_seat *xwl_seat;
+
+    xwl_screen->tablet_manager = wl_registry_bind(xwl_screen->registry,
+                                                  id,
+                                                  &zwp_tablet_manager_v2_interface,
+                                                  min(version,1));
+
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        init_tablet_manager_seat(xwl_screen, xwl_seat);
+    }
+}
+
+void
+xwl_screen_release_tablet_manager(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->tablet_manager) {
+        zwp_tablet_manager_v2_destroy(xwl_screen->tablet_manager);
+        xwl_screen->tablet_manager = NULL;
+    }
+}
+
+static void
+init_relative_pointer_manager(struct xwl_screen *xwl_screen,
+                              uint32_t id, uint32_t version)
+{
+    xwl_screen->relative_pointer_manager =
+        wl_registry_bind(xwl_screen->registry, id,
+                         &zwp_relative_pointer_manager_v1_interface,
+                         1);
+}
+
+static void
+init_pointer_constraints(struct xwl_screen *xwl_screen,
+                         uint32_t id, uint32_t version)
+{
+    xwl_screen->pointer_constraints =
+        wl_registry_bind(xwl_screen->registry, id,
+                         &zwp_pointer_constraints_v1_interface,
+                         1);
+}
+
+static void
+init_pointer_gestures(struct xwl_screen *xwl_screen,
+                      uint32_t id, uint32_t version)
+{
+    xwl_screen->pointer_gestures =
+        wl_registry_bind(xwl_screen->registry, id,
+                         &zwp_pointer_gestures_v1_interface,
+                         1);
+}
+
+static void
+init_keyboard_grab(struct xwl_screen *xwl_screen,
+                   uint32_t id, uint32_t version)
+{
+    struct xwl_seat *xwl_seat;
+    DeviceIntPtr master;
+
+    xwl_screen->wp_grab =
+         wl_registry_bind(xwl_screen->registry, id,
+                          &zwp_xwayland_keyboard_grab_manager_v1_interface,
+                          1);
+
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (xwl_seat->keyboard) {
+            master = GetMaster(xwl_seat->keyboard, MASTER_KEYBOARD);
+            if (master)
+                setup_keyboard_grab_handler(master);
+        }
+    }
+}
+
+static void
+init_keyboard_shortcuts_inhibit(struct xwl_screen *xwl_screen,
+                                uint32_t id, uint32_t version)
+{
+    xwl_screen->shortcuts_inhibit_manager =
+         wl_registry_bind(xwl_screen->registry, id,
+                          &zwp_keyboard_shortcuts_inhibit_manager_v1_interface,
+                          1);
+}
+
+/* The compositor may send us wl_seat and its capabilities before sending e.g.
+   relative_pointer_manager or pointer_gesture interfaces. This would result in
+   devices being created in capabilities handler, but listeners not, because
+   the interfaces weren't available at the time. So we manually attempt to setup
+   listeners again.
+*/
+static void
+maybe_init_relative_pointer_listeners_after_capabilities(struct xwl_screen* xwl_screen)
+{
+    struct xwl_seat *xwl_seat;
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (xwl_seat->wl_pointer) {
+            init_relative_pointer_listener(xwl_seat);
+        }
+    }
+}
+
+static void
+maybe_init_pointer_gesture_listeners_after_capabilities(struct xwl_screen* xwl_screen)
+{
+    struct xwl_seat *xwl_seat;
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (xwl_seat->wl_pointer) {
+            init_pointer_gestures_listener(xwl_seat);
+        }
+    }
+}
+
+static void
+input_handler(void *data, struct wl_registry *registry, uint32_t id,
+              const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    if (strcmp(interface, "wl_seat") == 0 && version >= 3) {
+        create_input_device(xwl_screen, id, version);
+        xwl_screen->expecting_event++;
+    } else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0) {
+        init_relative_pointer_manager(xwl_screen, id, version);
+        maybe_init_relative_pointer_listeners_after_capabilities(xwl_screen);
+    } else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0) {
+        init_pointer_constraints(xwl_screen, id, version);
+    } else if (strcmp(interface, "zwp_pointer_gestures_v1") == 0) {
+        init_pointer_gestures(xwl_screen, id, version);
+        maybe_init_pointer_gesture_listeners_after_capabilities(xwl_screen);
+    } else if (strcmp(interface, "zwp_tablet_manager_v2") == 0) {
+        init_tablet_manager(xwl_screen, id, version);
+    } else if (strcmp(interface, "zwp_xwayland_keyboard_grab_manager_v1") == 0) {
+        init_keyboard_grab(xwl_screen, id, version);
+    } else if (strcmp(interface, "zwp_keyboard_shortcuts_inhibit_manager_v1") == 0) {
+        init_keyboard_shortcuts_inhibit(xwl_screen, id, version);
+    }
+}
+
+static void
+global_remove(void *data, struct wl_registry *registry, uint32_t name)
+{
+}
+
+static const struct wl_registry_listener input_listener = {
+    input_handler,
+    global_remove,
+};
+
+void
+ProcessInputEvents(void)
+{
+    mieqProcessInputEvents();
+}
+
+void
+DDXRingBell(int volume, int pitch, int duration)
+{
+}
+
+static Bool
+sprite_check_lost_focus(SpritePtr sprite, WindowPtr window)
+{
+    DeviceIntPtr device, master;
+    struct xwl_seat *xwl_seat;
+
+    for (device = inputInfo.devices; device; device = device->next) {
+        /* Ignore non-wayland devices */
+        if (device->deviceProc == xwl_pointer_proc &&
+            device->spriteInfo->sprite == sprite)
+            break;
+    }
+
+    if (!device)
+        return FALSE;
+
+    xwl_seat = device->public.devicePrivate;
+    if (!xwl_seat)
+        return FALSE;
+
+    master = GetMaster(device, POINTER_OR_FLOAT);
+    if (!master || !master->lastSlave)
+        return FALSE;
+
+    /* We do want the last active slave, we only check on slave xwayland
+     * devices so we can find out the xwl_seat, but those don't actually own
+     * their sprite, so the match doesn't mean a lot.
+     */
+    if (master->lastSlave != get_pointer_device(xwl_seat))
+        return FALSE;
+
+    if (xwl_seat->focus_window != NULL &&
+        xwl_seat->cursor_confinement_window != NULL &&
+        xwl_seat->focus_window != xwl_seat->cursor_confinement_window)
+        return TRUE;
+
+    if (xwl_seat->focus_window == NULL &&
+        xwl_seat->last_xwindow != NullWindow &&
+        (IsParent(xwl_seat->last_xwindow, window) || xwl_seat->last_xwindow == window))
+        return TRUE;
+
+    return FALSE;
+}
+
+static WindowPtr
+xwl_xy_to_window(ScreenPtr screen, SpritePtr sprite, int x, int y)
+{
+    struct xwl_screen *xwl_screen;
+    WindowPtr ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->XYToWindow = xwl_screen->XYToWindow;
+    ret = screen->XYToWindow(screen, sprite, x, y);
+    xwl_screen->XYToWindow = screen->XYToWindow;
+    screen->XYToWindow = xwl_xy_to_window;
+
+    /* If the device controlling the sprite has left the Wayland surface but
+     * the DIX still finds the pointer within the X11 window, it means that
+     * the pointer has crossed to another native Wayland window, in this
+     * case, pretend we entered the root window so that a LeaveNotify
+     * event is emitted.
+     */
+    if (sprite_check_lost_focus(sprite, ret)) {
+        sprite->spriteTraceGood = 1;
+        return sprite->spriteTrace[0];
+    }
+
+    return ret;
+}
+
+void
+xwl_seat_clear_touch(struct xwl_seat *xwl_seat, WindowPtr window)
+{
+    struct xwl_touch *xwl_touch, *next_xwl_touch;
+
+    xorg_list_for_each_entry_safe(xwl_touch, next_xwl_touch,
+                                  &xwl_seat->touches, link_touch) {
+        if (xwl_touch->window->window == window) {
+            xorg_list_del(&xwl_touch->link_touch);
+            free(xwl_touch);
+        }
+    }
+}
+
+static void
+xwl_pointer_warp_emulator_set_fake_pos(struct xwl_pointer_warp_emulator *warp_emulator,
+                                       int x,
+                                       int y)
+{
+    struct zwp_locked_pointer_v1 *locked_pointer =
+        warp_emulator->locked_pointer;
+    WindowPtr window;
+    int sx, sy;
+
+    if (!warp_emulator->locked_pointer)
+        return;
+
+    if (!warp_emulator->xwl_seat->focus_window)
+        return;
+
+    window = warp_emulator->xwl_seat->focus_window->window;
+    if (x >= window->drawable.x ||
+        y >= window->drawable.y ||
+        x < (window->drawable.x + window->drawable.width) ||
+        y < (window->drawable.y + window->drawable.height)) {
+        sx = x - window->drawable.x;
+        sy = y - window->drawable.y;
+        zwp_locked_pointer_v1_set_cursor_position_hint(locked_pointer,
+                                                       wl_fixed_from_int(sx),
+                                                       wl_fixed_from_int(sy));
+        wl_surface_commit(warp_emulator->xwl_seat->focus_window->surface);
+    }
+}
+
+static Bool
+xwl_pointer_warp_emulator_is_locked(struct xwl_pointer_warp_emulator *warp_emulator)
+{
+    if (warp_emulator->locked_pointer)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+static void
+xwl_pointer_warp_emulator_lock(struct xwl_pointer_warp_emulator *warp_emulator)
+{
+    struct xwl_seat *xwl_seat = warp_emulator->xwl_seat;
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+    struct zwp_pointer_constraints_v1 *pointer_constraints =
+        xwl_screen->pointer_constraints;
+    struct xwl_window *lock_window = xwl_seat->focus_window;
+
+    warp_emulator->locked_window = lock_window;
+
+    warp_emulator->locked_pointer =
+        zwp_pointer_constraints_v1_lock_pointer(pointer_constraints,
+                                                lock_window->surface,
+                                                xwl_seat->wl_pointer,
+                                                NULL,
+                                                ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+}
+
+static void
+xwl_pointer_warp_emulator_maybe_lock(struct xwl_pointer_warp_emulator *warp_emulator,
+                                     struct xwl_window *xwl_window,
+                                     SpritePtr sprite,
+                                     int x, int y)
+{
+    struct xwl_seat *xwl_seat = warp_emulator->xwl_seat;
+    GrabPtr pointer_grab = xwl_seat->pointer->deviceGrab.grab;
+
+    if (warp_emulator->locked_pointer)
+        return;
+
+    /*
+     * If there is no grab, and the window doesn't have pointer focus, ignore
+     * the warp, as under Wayland it won't receive input anyway.
+     */
+    if (!pointer_grab && xwl_seat->focus_window != xwl_window)
+        return;
+
+    /*
+     * If there is a grab, but it's not an ownerEvents grab and the destination
+     * is not the pointer focus, ignore it, as events wouldn't be delivered
+     * there anyway.
+     */
+    if (pointer_grab &&
+        !pointer_grab->ownerEvents &&
+        sprite &&
+        XYToWindow(sprite, x, y) != xwl_seat->focus_window->window)
+        return;
+
+    xwl_pointer_warp_emulator_lock(warp_emulator);
+}
+
+static void
+xwl_pointer_warp_emulator_warp(struct xwl_pointer_warp_emulator *warp_emulator,
+                               struct xwl_window *xwl_window,
+                               SpritePtr sprite,
+                               int x, int y)
+{
+    xwl_pointer_warp_emulator_maybe_lock(warp_emulator,
+                                         xwl_window,
+                                         sprite,
+                                         x, y);
+    xwl_pointer_warp_emulator_set_fake_pos(warp_emulator, x, y);
+}
+
+static void
+xwl_pointer_warp_emulator_handle_motion(struct xwl_pointer_warp_emulator *warp_emulator,
+                                        double dx,
+                                        double dy,
+                                        double dx_unaccel,
+                                        double dy_unaccel)
+{
+    struct xwl_seat *xwl_seat = warp_emulator->xwl_seat;
+    ValuatorMask mask;
+    WindowPtr window;
+    int x, y;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set_unaccelerated(&mask, 0, dx, dx_unaccel);
+    valuator_mask_set_unaccelerated(&mask, 1, dy, dy_unaccel);
+
+    QueuePointerEvents(xwl_seat->relative_pointer, MotionNotify, 0,
+                       POINTER_RELATIVE, &mask);
+
+    window = xwl_seat->focus_window->window;
+    miPointerGetPosition(xwl_seat->pointer, &x, &y);
+
+    if (xwl_pointer_warp_emulator_is_locked(warp_emulator) &&
+        xwl_seat->cursor_confinement_window != warp_emulator->locked_window &&
+        (x < window->drawable.x ||
+         y < window->drawable.y ||
+         x >= (window->drawable.x + window->drawable.width) ||
+         y >= (window->drawable.y + window->drawable.height)))
+        xwl_seat_destroy_pointer_warp_emulator(xwl_seat);
+    else
+        xwl_pointer_warp_emulator_set_fake_pos(warp_emulator, x, y);
+}
+
+static struct xwl_pointer_warp_emulator *
+xwl_pointer_warp_emulator_create(struct xwl_seat *xwl_seat)
+{
+    struct xwl_pointer_warp_emulator *warp_emulator;
+
+    warp_emulator = calloc(1, sizeof *warp_emulator);
+    if (!warp_emulator) {
+        ErrorF("%s: ENOMEM\n", __func__);
+        return NULL;
+    }
+
+    warp_emulator->xwl_seat = xwl_seat;
+
+    return warp_emulator;
+}
+
+static void
+xwl_pointer_warp_emulator_destroy(struct xwl_pointer_warp_emulator *warp_emulator)
+{
+    if (warp_emulator->locked_pointer)
+        zwp_locked_pointer_v1_destroy(warp_emulator->locked_pointer);
+    free(warp_emulator);
+}
+
+static void
+xwl_seat_create_pointer_warp_emulator(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->confined_pointer)
+        xwl_seat_destroy_confined_pointer(xwl_seat);
+
+    xwl_seat->pointer_warp_emulator =
+        xwl_pointer_warp_emulator_create(xwl_seat);
+}
+
+static Bool
+xwl_seat_can_emulate_pointer_warp(struct xwl_seat *xwl_seat)
+{
+    struct xwl_screen *xwl_screen;
+
+    if (!xwl_seat)
+        return FALSE;
+
+    if (!xwl_seat->pointer)
+        return FALSE;
+
+    xwl_screen = xwl_seat->xwl_screen;
+
+    if (!xwl_screen->relative_pointer_manager)
+        return FALSE;
+
+    if (!xwl_screen->pointer_constraints)
+        return FALSE;
+
+    return TRUE;
+}
+
+void
+xwl_seat_emulate_pointer_warp(struct xwl_seat *xwl_seat,
+                              struct xwl_window *xwl_window,
+                              SpritePtr sprite,
+                              int x, int y)
+{
+    if (!xwl_seat_can_emulate_pointer_warp(xwl_seat))
+        return;
+
+    if (xwl_seat->x_cursor != NULL)
+        return;
+
+    if (!xwl_seat->pointer_warp_emulator)
+        xwl_seat_create_pointer_warp_emulator(xwl_seat);
+
+    if (!xwl_seat->pointer_warp_emulator)
+        return;
+
+    xwl_pointer_warp_emulator_warp(xwl_seat->pointer_warp_emulator,
+                                   xwl_window,
+                                   sprite,
+                                   x, y);
+}
+
+static Bool
+xwl_seat_maybe_lock_on_hidden_cursor(struct xwl_seat *xwl_seat)
+{
+    struct xwl_screen *xwl_screen = xwl_seat->xwl_screen;
+
+    /* Some clients use hidden cursor+confineTo+relative motion
+     * to implement infinite panning (eg. 3D views), lock the
+     * pointer for so the relative pointer is used.
+     */
+    if (xwl_seat->x_cursor)
+        return FALSE;
+
+    if (!xwl_seat->focus_window)
+        return FALSE;
+
+    if (!xwl_screen->rootless)
+        return FALSE;
+
+    if (xwl_seat->cursor_confinement_window != xwl_seat->focus_window)
+        return FALSE;
+
+    if (xwl_seat->confined_pointer)
+        xwl_seat_destroy_confined_pointer(xwl_seat);
+
+    xwl_seat_create_pointer_warp_emulator(xwl_seat);
+    xwl_pointer_warp_emulator_lock(xwl_seat->pointer_warp_emulator);
+    return TRUE;
+}
+
+void
+xwl_seat_cursor_visibility_changed(struct xwl_seat *xwl_seat)
+{
+    if (xwl_seat->pointer_warp_emulator && xwl_seat->x_cursor != NULL) {
+        xwl_seat_destroy_pointer_warp_emulator(xwl_seat);
+    } else if (!xwl_seat->x_cursor && xwl_seat->cursor_confinement_window) {
+        /* If the cursor goes hidden as is confined, lock it for
+         * relative motion to work. */
+        xwl_seat_maybe_lock_on_hidden_cursor(xwl_seat);
+    }
+}
+
+void
+xwl_seat_destroy_pointer_warp_emulator(struct xwl_seat *xwl_seat)
+{
+    if (!xwl_seat->pointer_warp_emulator)
+        return;
+
+    xwl_pointer_warp_emulator_destroy(xwl_seat->pointer_warp_emulator);
+    xwl_seat->pointer_warp_emulator = NULL;
+
+    if (xwl_seat->cursor_confinement_window) {
+        xwl_seat_confine_pointer(xwl_seat,
+                                 xwl_seat->cursor_confinement_window);
+    }
+}
+
+void
+xwl_seat_confine_pointer(struct xwl_seat *xwl_seat,
+                         struct xwl_window *xwl_window)
+{
+    struct zwp_pointer_constraints_v1 *pointer_constraints =
+        xwl_seat->xwl_screen->pointer_constraints;
+
+    if (!pointer_constraints)
+        return;
+
+    if (!xwl_seat->wl_pointer)
+        return;
+
+    if (xwl_seat->cursor_confinement_window == xwl_window &&
+        xwl_seat->confined_pointer)
+        return;
+
+    xwl_seat_unconfine_pointer(xwl_seat);
+
+    xwl_seat->cursor_confinement_window = xwl_window;
+
+    if (xwl_seat->pointer_warp_emulator)
+        return;
+
+    if (xwl_seat_maybe_lock_on_hidden_cursor(xwl_seat))
+        return;
+
+    xwl_seat->confined_pointer =
+        zwp_pointer_constraints_v1_confine_pointer(pointer_constraints,
+                                                   xwl_window->surface,
+                                                   xwl_seat->wl_pointer,
+                                                   NULL,
+                                                   ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+}
+
+static void
+xwl_seat_destroy_confined_pointer(struct xwl_seat *xwl_seat)
+{
+    zwp_confined_pointer_v1_destroy(xwl_seat->confined_pointer);
+    xwl_seat->confined_pointer = NULL;
+}
+
+void
+xwl_seat_unconfine_pointer(struct xwl_seat *xwl_seat)
+{
+    xwl_seat->cursor_confinement_window = NULL;
+
+    if (xwl_seat->confined_pointer)
+        xwl_seat_destroy_confined_pointer(xwl_seat);
+}
+
+void
+InitInput(int argc, char *argv[])
+{
+    ScreenPtr pScreen = screenInfo.screens[0];
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+
+    if (!dixRegisterPrivateKey(&xwl_tablet_private_key, PRIVATE_DEVICE, 0)) {
+        ErrorF("Failed to register private key\n");
+        return;
+    }
+
+    mieqInit();
+
+    xwl_screen->input_registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->input_registry, &input_listener,
+                             xwl_screen);
+
+    xwl_screen->XYToWindow = pScreen->XYToWindow;
+    pScreen->XYToWindow = xwl_xy_to_window;
+
+    xwl_screen_roundtrip(xwl_screen);
+}
+
+void
+CloseInput(void)
+{
+    mieqFini();
+}
diff --git a/hw/xwayland/xwayland-input.h b/hw/xwayland/xwayland-input.h
new file mode 100644
index 000000000..ee94d73ae
--- /dev/null
+++ b/hw/xwayland/xwayland-input.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2008 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_INPUT_H
+#define XWAYLAND_INPUT_H
+
+#include <xwayland-config.h>
+#include <wayland-client.h>
+
+#include <dix.h>
+#include <input.h>
+
+struct xwl_touch {
+    struct xwl_window *window;
+    int32_t id;
+    int x, y;
+    struct xorg_list link_touch;
+};
+
+struct xwl_pointer_warp_emulator {
+    struct xwl_seat *xwl_seat;
+    struct xwl_window *locked_window;
+    struct zwp_locked_pointer_v1 *locked_pointer;
+};
+
+struct xwl_cursor {
+    void (* update_proc) (struct xwl_cursor *);
+    struct wl_surface *surface;
+    struct wl_callback *frame_cb;
+    Bool needs_update;
+};
+
+struct xwl_seat {
+    DeviceIntPtr pointer;
+    DeviceIntPtr relative_pointer;
+    DeviceIntPtr pointer_gestures;
+    DeviceIntPtr keyboard;
+    DeviceIntPtr touch;
+    DeviceIntPtr stylus;
+    DeviceIntPtr eraser;
+    DeviceIntPtr puck;
+    struct xwl_screen *xwl_screen;
+    struct wl_seat *seat;
+    struct wl_pointer *wl_pointer;
+    struct zwp_relative_pointer_v1 *wp_relative_pointer;
+    struct zwp_pointer_gesture_swipe_v1 *wp_pointer_gesture_swipe;
+    struct zwp_pointer_gesture_pinch_v1 *wp_pointer_gesture_pinch;
+    struct wl_keyboard *wl_keyboard;
+    struct wl_touch *wl_touch;
+    struct zwp_tablet_seat_v2 *tablet_seat;
+    struct wl_array keys;
+    struct xwl_window *focus_window;
+    struct xwl_window *tablet_focus_window;
+    uint32_t id;
+    uint32_t pointer_enter_serial;
+    struct xorg_list link;
+    CursorPtr x_cursor;
+    OsTimerPtr x_cursor_timer;
+    CursorPtr pending_x_cursor;
+    struct xwl_cursor cursor;
+    WindowPtr last_xwindow;
+
+    uint32_t pointer_gesture_swipe_fingers;
+    uint32_t pointer_gesture_pinch_fingers;
+    double pointer_gesture_pinch_last_scale;
+
+    struct xorg_list touches;
+
+    size_t keymap_size;
+    char *keymap;
+    struct wl_surface *keyboard_focus;
+
+    struct xorg_list sync_pending;
+
+    struct xwl_pointer_warp_emulator *pointer_warp_emulator;
+
+    struct xwl_window *cursor_confinement_window;
+    struct zwp_confined_pointer_v1 *confined_pointer;
+
+    struct {
+        Bool has_absolute;
+        wl_fixed_t x;
+        wl_fixed_t y;
+
+        Bool has_relative;
+        double dx;
+        double dy;
+        double dx_unaccel;
+        double dy_unaccel;
+
+        wl_fixed_t scroll_dy;
+        wl_fixed_t scroll_dx;
+        int32_t scroll_dy_v120;
+        int32_t scroll_dx_v120;
+        Bool has_vertical_scroll;
+        Bool has_horizontal_scroll;
+        Bool has_vertical_scroll_v120;
+        Bool has_horizontal_scroll_v120;
+    } pending_pointer_event;
+
+    struct xorg_list tablets;
+    struct xorg_list tablet_tools;
+    struct xorg_list tablet_pads;
+    struct zwp_xwayland_keyboard_grab_v1 *keyboard_grab;
+};
+
+struct xwl_tablet {
+    struct xorg_list link;
+    struct zwp_tablet_v2 *tablet;
+    struct xwl_seat *seat;
+};
+
+struct xwl_tablet_tool {
+    struct xorg_list link;
+    struct zwp_tablet_tool_v2 *tool;
+    struct xwl_seat *seat;
+
+    DeviceIntPtr xdevice;
+    uint32_t proximity_in_serial;
+    double x;
+    double y;
+    uint32_t pressure;
+    double tilt_x;
+    double tilt_y;
+    double rotation;
+    double slider;
+
+    uint32_t buttons_now,
+             buttons_prev;
+
+    int32_t wheel_clicks;
+
+    struct xwl_cursor cursor;
+};
+
+struct xwl_tablet_pad_ring {
+    unsigned int index;
+    struct xorg_list link;
+    struct xwl_tablet_pad_group *group;
+    struct zwp_tablet_pad_ring_v2 *ring;
+};
+
+struct xwl_tablet_pad_strip {
+    unsigned int index;
+    struct xorg_list link;
+    struct xwl_tablet_pad_group *group;
+    struct zwp_tablet_pad_strip_v2 *strip;
+};
+
+struct xwl_tablet_pad_group {
+    struct xorg_list link;
+    struct xwl_tablet_pad *pad;
+    struct zwp_tablet_pad_group_v2 *group;
+
+    struct xorg_list pad_group_ring_list;
+    struct xorg_list pad_group_strip_list;
+};
+
+struct xwl_tablet_pad {
+    struct xorg_list link;
+    struct zwp_tablet_pad_v2 *pad;
+    struct xwl_seat *seat;
+
+    DeviceIntPtr xdevice;
+
+    unsigned int nbuttons;
+    struct xorg_list pad_group_list;
+};
+
+void xwl_seat_destroy(struct xwl_seat *xwl_seat);
+
+void xwl_seat_clear_touch(struct xwl_seat *xwl_seat, WindowPtr window);
+
+void xwl_seat_emulate_pointer_warp(struct xwl_seat *xwl_seat,
+                                   struct xwl_window *xwl_window,
+                                   SpritePtr sprite,
+                                   int x, int y);
+
+void xwl_seat_destroy_pointer_warp_emulator(struct xwl_seat *xwl_seat);
+
+void xwl_seat_cursor_visibility_changed(struct xwl_seat *xwl_seat);
+
+void xwl_seat_confine_pointer(struct xwl_seat *xwl_seat,
+                              struct xwl_window *xwl_window);
+void xwl_seat_unconfine_pointer(struct xwl_seat *xwl_seat);
+
+void xwl_screen_release_tablet_manager(struct xwl_screen *xwl_screen);
+
+#endif /* XWAYLAND_INPUT_H */
diff --git a/hw/xwayland/xwayland-output.c b/hw/xwayland/xwayland-output.c
new file mode 100644
index 000000000..7a9352f58
--- /dev/null
+++ b/hw/xwayland/xwayland-output.c
@@ -0,0 +1,1218 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <randrstr.h>
+#include <X11/Xatom.h>
+
+#include "xwayland-cvt.h"
+#include "xwayland-output.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+
+#include "xdg-output-unstable-v1-client-protocol.h"
+
+static void xwl_output_get_xdg_output(struct xwl_output *xwl_output);
+
+static Rotation
+wl_transform_to_xrandr(enum wl_output_transform transform)
+{
+    switch (transform) {
+    default:
+    case WL_OUTPUT_TRANSFORM_NORMAL:
+        return RR_Rotate_0;
+    case WL_OUTPUT_TRANSFORM_90:
+        return RR_Rotate_90;
+    case WL_OUTPUT_TRANSFORM_180:
+        return RR_Rotate_180;
+    case WL_OUTPUT_TRANSFORM_270:
+        return RR_Rotate_270;
+    case WL_OUTPUT_TRANSFORM_FLIPPED:
+        return RR_Reflect_X | RR_Rotate_0;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+        return RR_Reflect_X | RR_Rotate_90;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+        return RR_Reflect_X | RR_Rotate_180;
+    case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+        return RR_Reflect_X | RR_Rotate_270;
+    }
+}
+
+static int
+wl_subpixel_to_xrandr(int subpixel)
+{
+    switch (subpixel) {
+    default:
+    case WL_OUTPUT_SUBPIXEL_UNKNOWN:
+        return SubPixelUnknown;
+    case WL_OUTPUT_SUBPIXEL_NONE:
+        return SubPixelNone;
+    case WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB:
+        return SubPixelHorizontalRGB;
+    case WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR:
+        return SubPixelHorizontalBGR;
+    case WL_OUTPUT_SUBPIXEL_VERTICAL_RGB:
+        return SubPixelVerticalRGB;
+    case WL_OUTPUT_SUBPIXEL_VERTICAL_BGR:
+        return SubPixelVerticalBGR;
+    }
+}
+
+static void
+output_handle_geometry(void *data, struct wl_output *wl_output, int x, int y,
+                       int physical_width, int physical_height, int subpixel,
+                       const char *make, const char *model, int transform)
+{
+    struct xwl_output *xwl_output = data;
+
+    if (xwl_output->randr_output) {
+        RROutputSetPhysicalSize(xwl_output->randr_output,
+                                physical_width, physical_height);
+        RROutputSetSubpixelOrder(xwl_output->randr_output,
+                                 wl_subpixel_to_xrandr(subpixel));
+    }
+
+    /* Apply the change from wl_output only if xdg-output is not supported */
+    if (!xwl_output->xdg_output) {
+        xwl_output->x = x;
+        xwl_output->y = y;
+    }
+    xwl_output->rotation = wl_transform_to_xrandr(transform);
+}
+
+static void
+output_handle_mode(void *data, struct wl_output *wl_output, uint32_t flags,
+                   int width, int height, int refresh)
+{
+    struct xwl_output *xwl_output = data;
+
+    if (!(flags & WL_OUTPUT_MODE_CURRENT))
+        return;
+
+    /* Apply the change from wl_output only if xdg-output is not supported */
+    if (!xwl_output->xdg_output) {
+        xwl_output->width = width;
+        xwl_output->height = height;
+    }
+    xwl_output->refresh = refresh;
+}
+
+/**
+ * Decides on the maximum expanse of an output in logical space (i.e. in the
+ * Wayland compositor plane) respective to some fix width and height values. The
+ * function sets the provided values to these maxima on return.
+ */
+static inline void
+output_get_new_size(struct xwl_output *xwl_output, int *width, int *height)
+{
+    int output_width, output_height;
+
+    /* When we have xdg-output support the stored size is already rotated. */
+    if (xwl_output->xdg_output
+            || (xwl_output->rotation & (RR_Rotate_0 | RR_Rotate_180))) {
+        output_width = xwl_output->width;
+        output_height = xwl_output->height;
+    } else {
+        output_width = xwl_output->height;
+        output_height = xwl_output->width;
+    }
+
+    if (*width < xwl_output->x + output_width)
+        *width = xwl_output->x + output_width;
+
+    if (*height < xwl_output->y + output_height)
+        *height = xwl_output->y + output_height;
+}
+
+static int
+xwl_set_pixmap_visit_window(WindowPtr window, void *data)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+
+    if (screen->GetWindowPixmap(window) == data) {
+        screen->SetWindowPixmap(window, screen->GetScreenPixmap(screen));
+        return WT_WALKCHILDREN;
+    }
+
+    return WT_DONTWALKCHILDREN;
+}
+
+static void
+update_backing_pixmaps(struct xwl_screen *xwl_screen, int width, int height)
+{
+    ScreenPtr pScreen = xwl_screen->screen;
+    WindowPtr pRoot = pScreen->root;
+    PixmapPtr old_pixmap, new_pixmap;
+
+    old_pixmap = pScreen->GetScreenPixmap(pScreen);
+    new_pixmap = pScreen->CreatePixmap(pScreen, width, height,
+                                       pScreen->rootDepth,
+                                       CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    pScreen->SetScreenPixmap(new_pixmap);
+
+    if (old_pixmap) {
+        TraverseTree(pRoot, xwl_set_pixmap_visit_window, old_pixmap);
+        pScreen->DestroyPixmap(old_pixmap);
+    }
+
+    pScreen->ResizeWindow(pRoot, 0, 0, width, height, NULL);
+}
+
+static void
+update_screen_size(struct xwl_screen *xwl_screen, int width, int height)
+{
+    xwl_screen->width = width;
+    xwl_screen->height = height;
+
+    if (xwl_screen->root_clip_mode == ROOT_CLIP_FULL)
+        SetRootClip(xwl_screen->screen, ROOT_CLIP_NONE);
+
+    if (!xwl_screen->rootless && xwl_screen->screen->root)
+        update_backing_pixmaps (xwl_screen, width, height);
+
+    xwl_screen->screen->width = width;
+    xwl_screen->screen->height = height;
+    xwl_screen->screen->mmWidth = (width * 25.4) / monitorResolution;
+    xwl_screen->screen->mmHeight = (height * 25.4) / monitorResolution;
+
+    SetRootClip(xwl_screen->screen, xwl_screen->root_clip_mode);
+
+    if (xwl_screen->screen->root) {
+        BoxRec box = { 0, 0, width, height };
+
+        xwl_screen->screen->root->drawable.width = width;
+        xwl_screen->screen->root->drawable.height = height;
+        RegionReset(&xwl_screen->screen->root->winSize, &box);
+        RRScreenSizeNotify(xwl_screen->screen);
+    }
+
+    update_desktop_dimensions();
+
+    RRTellChanged(xwl_screen->screen);
+}
+
+struct xwl_emulated_mode *
+xwl_output_get_emulated_mode_for_client(struct xwl_output *xwl_output,
+                                        ClientPtr client)
+{
+    struct xwl_client *xwl_client = xwl_client_get(client);
+    int i;
+
+    if (!xwl_output)
+        return NULL;
+
+    /* We don't do XRandr emulation when rootful or a fake lease display */
+    if (!xwl_output->xwl_screen->rootless || !xwl_output->output)
+        return NULL;
+
+    for (i = 0; i < XWL_CLIENT_MAX_EMULATED_MODES; i++) {
+        if (xwl_client->emulated_modes[i].server_output_id ==
+            xwl_output->server_output_id)
+            return &xwl_client->emulated_modes[i];
+    }
+
+    return NULL;
+}
+
+static void
+xwl_output_add_emulated_mode_for_client(struct xwl_output *xwl_output,
+                                        ClientPtr client,
+                                        RRModePtr mode,
+                                        Bool from_vidmode)
+{
+    struct xwl_client *xwl_client = xwl_client_get(client);
+    struct xwl_emulated_mode *emulated_mode;
+    int i;
+
+    emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, client);
+    if (!emulated_mode) {
+        /* Find a free spot in the emulated modes array */
+        for (i = 0; i < XWL_CLIENT_MAX_EMULATED_MODES; i++) {
+            if (xwl_client->emulated_modes[i].server_output_id == 0) {
+                emulated_mode = &xwl_client->emulated_modes[i];
+                break;
+            }
+        }
+    }
+    if (!emulated_mode) {
+        static Bool warned;
+
+        if (!warned) {
+            ErrorF("Ran out of space for emulated-modes, not adding mode");
+            warned = TRUE;
+        }
+
+        return;
+    }
+
+    emulated_mode->server_output_id = xwl_output->server_output_id;
+    emulated_mode->width  = mode->mode.width;
+    emulated_mode->height = mode->mode.height;
+    emulated_mode->id = mode->mode.id;
+    emulated_mode->from_vidmode = from_vidmode;
+}
+
+static void
+xwl_output_remove_emulated_mode_for_client(struct xwl_output *xwl_output,
+                                           ClientPtr client)
+{
+    struct xwl_emulated_mode *emulated_mode;
+
+    emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, client);
+    if (emulated_mode) {
+        DebugF("XWAYLAND: xwl_output_remove_emulated_mode: %dx%d\n",
+               emulated_mode->width, emulated_mode->height);
+        memset(emulated_mode, 0, sizeof(*emulated_mode));
+    }
+}
+
+/* From hw/xfree86/common/xf86DefModeSet.c with some obscure modes dropped */
+const int32_t xwl_output_fake_modes[][2] = {
+    /* 4:3 (1.33) */
+    { 2048, 1536 },
+    { 1920, 1440 },
+    { 1600, 1200 },
+    { 1440, 1080 },
+    { 1400, 1050 },
+    { 1280, 1024 }, /* 5:4 (1.25) */
+    { 1280,  960 },
+    { 1152,  864 },
+    { 1024,  768 },
+    {  800,  600 },
+    {  640,  480 },
+    {  320,  240 },
+    /* 16:10 (1.6) */
+    { 2560, 1600 },
+    { 1920, 1200 },
+    { 1680, 1050 },
+    { 1440,  900 },
+    { 1280,  800 },
+    { 1152,  720 },
+    {  960,  600 },
+    {  928,  580 },
+    {  800,  500 },
+    {  768,  480 },
+    {  720,  480 }, /* 3:2 (1.5) */
+    {  640,  400 },
+    {  320,  200 },
+    /* 16:9 (1.77) */
+    { 5120, 2880 },
+    { 4096, 2304 },
+    { 3840, 2160 },
+    { 3200, 1800 },
+    { 2880, 1620 },
+    { 2560, 1440 },
+    { 2048, 1152 },
+    { 1920, 1080 },
+    { 1600,  900 },
+    { 1368,  768 },
+    { 1280,  720 },
+    { 1024,  576 },
+    {  864,  486 },
+    {  720,  400 },
+    {  640,  350 },
+};
+
+/* Build an array with RRModes the first mode is the actual output mode, the
+ * rest are fake modes from the xwl_output_fake_modes list. We do this for apps
+ * which want to change resolution when they go fullscreen.
+ * When an app requests a mode-change, we fake it using WPviewport.
+ */
+static RRModePtr *
+output_get_rr_modes(struct xwl_output *xwl_output,
+                    int32_t width, int32_t height,
+                    int *count)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+    RRModePtr *rr_modes;
+    int i;
+
+    rr_modes = xallocarray(ARRAY_SIZE(xwl_output_fake_modes) + 1, sizeof(RRModePtr));
+    if (!rr_modes)
+        goto err;
+
+    /* Add actual output mode */
+    rr_modes[0] = xwayland_cvt(width, height, xwl_output->refresh / 1000.0, 0, 0);
+    if (!rr_modes[0])
+        goto err;
+
+    *count = 1;
+
+    if (!xwl_screen_has_resolution_change_emulation(xwl_screen) && !xwl_screen->force_xrandr_emulation)
+        return rr_modes;
+
+    /* Add fake modes */
+    for (i = 0; i < ARRAY_SIZE(xwl_output_fake_modes); i++) {
+        /* Skip actual output mode, already added */
+        if (xwl_output_fake_modes[i][0] == width &&
+            xwl_output_fake_modes[i][1] == height)
+            continue;
+
+        /* Skip modes which are too big, avoid downscaling */
+        if (xwl_output_fake_modes[i][0] > width ||
+            xwl_output_fake_modes[i][1] > height)
+            continue;
+
+        rr_modes[*count] = xwayland_cvt(xwl_output_fake_modes[i][0],
+                                        xwl_output_fake_modes[i][1],
+                                        xwl_output->refresh / 1000.0, 0, 0);
+        if (!rr_modes[*count])
+            goto err;
+
+        (*count)++;
+    }
+
+    return rr_modes;
+err:
+    FatalError("Failed to allocate memory for list of RR modes");
+}
+
+RRModePtr
+xwl_output_find_mode(struct xwl_output *xwl_output,
+                     int32_t width, int32_t height)
+{
+    RROutputPtr output = xwl_output->randr_output;
+    int i;
+
+    /* width & height -1 means we want the actual output mode, which is idx 0 */
+    if (width == -1 && height == -1 && output->modes)
+        return output->modes[0];
+
+    for (i = 0; i < output->numModes; i++) {
+        if (output->modes[i]->mode.width == width && output->modes[i]->mode.height == height)
+            return output->modes[i];
+    }
+
+    ErrorF("XWAYLAND: mode %dx%d is not available\n", width, height);
+    return NULL;
+}
+
+struct xwl_output_randr_emu_prop {
+    Atom atom;
+    uint32_t rects[XWL_CLIENT_MAX_EMULATED_MODES][4];
+    int rect_count;
+};
+
+static void
+xwl_output_randr_emu_prop(struct xwl_screen *xwl_screen, ClientPtr client,
+                          struct xwl_output_randr_emu_prop *prop)
+{
+    static const char atom_name[] = "_XWAYLAND_RANDR_EMU_MONITOR_RECTS";
+    struct xwl_emulated_mode *emulated_mode;
+    struct xwl_output *xwl_output;
+    int index = 0;
+
+    prop->atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+
+    xorg_list_for_each_entry(xwl_output, &xwl_screen->output_list, link) {
+        emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, client);
+        if (!emulated_mode)
+            continue;
+
+        prop->rects[index][0] = xwl_output->x;
+        prop->rects[index][1] = xwl_output->y;
+        prop->rects[index][2] = emulated_mode->width;
+        prop->rects[index][3] = emulated_mode->height;
+        index++;
+    }
+
+    prop->rect_count = index;
+}
+
+static void
+xwl_output_set_randr_emu_prop(WindowPtr window,
+                              struct xwl_output_randr_emu_prop *prop)
+{
+    if (prop->rect_count) {
+        dixChangeWindowProperty(serverClient, window, prop->atom,
+                                XA_CARDINAL, 32, PropModeReplace,
+                                prop->rect_count * 4, prop->rects, TRUE);
+    } else {
+        DeleteProperty(serverClient, window, prop->atom);
+    }
+}
+
+static void
+xwl_output_set_randr_emu_prop_callback(void *resource, XID id, void *user_data)
+{
+    if (xwl_window_is_toplevel(resource))
+        xwl_output_set_randr_emu_prop(resource, user_data);
+}
+
+static void
+xwl_output_set_randr_emu_props(struct xwl_screen *xwl_screen, ClientPtr client)
+{
+    struct xwl_output_randr_emu_prop prop = {};
+
+    xwl_output_randr_emu_prop(xwl_screen, client, &prop);
+    FindClientResourcesByType(client, RT_WINDOW,
+                              xwl_output_set_randr_emu_prop_callback, &prop);
+}
+
+static inline void
+xwl_output_get_emulated_root_size(struct xwl_output *xwl_output,
+                                  ClientPtr client,
+                                  int *width,
+                                  int *height)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+    struct xwl_emulated_mode *emulated_mode;
+
+    emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, client);
+    /* If not an emulated mode, just return the actual screen size */
+    if (!emulated_mode) {
+        *width = xwl_screen->width;
+        *height = xwl_screen->height;
+        return;
+    }
+
+    if (xwl_output->rotation & (RR_Rotate_0 | RR_Rotate_180)) {
+        *width = emulated_mode->width;
+        *height = emulated_mode->height;
+    } else {
+        *width = emulated_mode->height;
+        *height = emulated_mode->width;
+    }
+}
+
+static int
+xwl_output_get_rr_event_mask(WindowPtr pWin, ClientPtr client)
+{
+    RREventPtr pRREvent, *pHead;
+
+    dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
+                            RREventType, client, DixReadAccess);
+
+    pRREvent = NULL;
+    if (pHead) {
+        for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)
+            if (pRREvent->client == client)
+                break;
+        }
+
+    if (pRREvent)
+        return pRREvent->mask;
+
+    return 0;
+}
+
+static void
+xwl_output_notify_emulated_root_size(struct xwl_output *xwl_output,
+                                     ClientPtr client,
+                                     int new_emulated_root_width,
+                                     int new_emulated_root_height)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+    ScreenPtr pScreen = xwl_screen->screen;
+    WindowPtr pRoot = pScreen->root;
+    xEvent event = {
+             .u.configureNotify.event = pRoot->drawable.id,
+             .u.configureNotify.window = pRoot->drawable.id,
+             .u.configureNotify.aboveSibling = None,
+             .u.configureNotify.x = 0,
+             .u.configureNotify.y = 0,
+             .u.configureNotify.width = new_emulated_root_width,
+             .u.configureNotify.height = new_emulated_root_height,
+             .u.configureNotify.borderWidth = pRoot->borderWidth,
+             .u.configureNotify.override = pRoot->overrideRedirect
+         };
+     event.u.u.type = ConfigureNotify;
+
+     if (!client || client == serverClient || client->clientGone)
+         return;
+
+     if (EventMaskForClient(pRoot, client) & StructureNotifyMask)
+         WriteEventsToClient(client, 1, &event);
+
+     if (xwl_output_get_rr_event_mask(pRoot, client) & RRScreenChangeNotifyMask)
+         RRDeliverScreenEvent(client, pRoot, pScreen);
+}
+
+void
+xwl_output_set_window_randr_emu_props(struct xwl_screen *xwl_screen,
+                                      WindowPtr window)
+{
+    struct xwl_output_randr_emu_prop prop = {};
+
+    xwl_output_randr_emu_prop(xwl_screen, wClient(window), &prop);
+    xwl_output_set_randr_emu_prop(window, &prop);
+}
+
+void
+xwl_output_set_emulated_mode(struct xwl_output *xwl_output, ClientPtr client,
+                             RRModePtr mode, Bool from_vidmode)
+{
+    int old_emulated_width, old_emulated_height;
+    int new_emulated_width, new_emulated_height;
+
+    DebugF("XWAYLAND: xwl_output_set_emulated_mode from %s: %dx%d\n",
+           from_vidmode ? "vidmode" : "randr",
+           mode->mode.width, mode->mode.height);
+
+    xwl_output_get_emulated_root_size(xwl_output, client,
+                                      &old_emulated_width, &old_emulated_height);
+
+    /* modes[0] is the actual (not-emulated) output mode */
+    if (mode == xwl_output->randr_output->modes[0])
+        xwl_output_remove_emulated_mode_for_client(xwl_output, client);
+    else
+        xwl_output_add_emulated_mode_for_client(xwl_output, client, mode, from_vidmode);
+
+    xwl_screen_check_resolution_change_emulation(xwl_output->xwl_screen);
+
+    xwl_output_set_randr_emu_props(xwl_output->xwl_screen, client);
+
+    xwl_output_get_emulated_root_size(xwl_output, client,
+                                      &new_emulated_width, &new_emulated_height);
+
+    if (new_emulated_width != old_emulated_width ||
+        new_emulated_height != old_emulated_height)
+        xwl_output_notify_emulated_root_size(xwl_output, client,
+                                             new_emulated_width,
+                                             new_emulated_height);
+}
+
+static void
+apply_output_change(struct xwl_output *xwl_output)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+    struct xwl_output *it;
+    int mode_width, mode_height, count;
+    int width = 0, height = 0, has_this_output = 0;
+    RRModePtr *randr_modes;
+
+    /* Clear out the "done" received flags */
+    xwl_output->wl_output_done = FALSE;
+    xwl_output->xdg_output_done = FALSE;
+
+    /* When we have received an xdg-output for the mode size we might need to
+     * rotate back the stored logical size it provided.
+     */
+    if (xwl_output->xdg_output == NULL
+        || xwl_output->rotation & (RR_Rotate_0 | RR_Rotate_180)) {
+        mode_width = xwl_output->width;
+        mode_height = xwl_output->height;
+    } else {
+        mode_width = xwl_output->height;
+        mode_height = xwl_output->width;
+    }
+    if (xwl_output->randr_output) {
+        /* Build a fresh modes array using the current refresh rate */
+        randr_modes = output_get_rr_modes(xwl_output, mode_width, mode_height, &count);
+        RROutputSetModes(xwl_output->randr_output, randr_modes, count, 1);
+        RRCrtcNotify(xwl_output->randr_crtc, randr_modes[0],
+                     xwl_output->x, xwl_output->y,
+                     xwl_output->rotation, NULL, 1, &xwl_output->randr_output);
+        /* RROutputSetModes takes ownership of the passed in modes, so we only
+         * have to free the pointer array.
+         */
+        free(randr_modes);
+    }
+
+    xorg_list_for_each_entry(it, &xwl_screen->output_list, link) {
+        /* output done event is sent even when some property
+         * of output is changed. That means that we may already
+         * have this output. If it is true, we must not add it
+         * into the output_list otherwise we'll corrupt it */
+        if (it == xwl_output)
+            has_this_output = 1;
+
+        output_get_new_size(it, &width, &height);
+    }
+
+    if (!has_this_output) {
+        xorg_list_append(&xwl_output->link, &xwl_screen->output_list);
+
+        /* we did not check this output for new screen size, do it now */
+        output_get_new_size(xwl_output, &width, &height);
+
+	--xwl_screen->expecting_event;
+    }
+
+    if (xwl_screen->fixed_output == NULL)
+        update_screen_size(xwl_screen, width, height);
+}
+
+static void
+output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct xwl_output *xwl_output = data;
+
+    xwl_output->wl_output_done = TRUE;
+    /* Apply the changes from wl_output only if both "done" events are received,
+     * if xdg-output is not supported or if xdg-output version is high enough.
+     */
+    if (xwl_output->xdg_output_done || !xwl_output->xdg_output ||
+        zxdg_output_v1_get_version(xwl_output->xdg_output) >= 3)
+        apply_output_change(xwl_output);
+}
+
+static void
+output_handle_scale(void *data, struct wl_output *wl_output, int32_t factor)
+{
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void
+xdg_output_handle_logical_position(void *data, struct zxdg_output_v1 *xdg_output,
+                                   int32_t x, int32_t y)
+{
+    struct xwl_output *xwl_output = data;
+
+    xwl_output->x = x;
+    xwl_output->y = y;
+}
+
+static void
+xdg_output_handle_logical_size(void *data, struct zxdg_output_v1 *xdg_output,
+                               int32_t width, int32_t height)
+{
+    struct xwl_output *xwl_output = data;
+
+    xwl_output->width = width;
+    xwl_output->height = height;
+}
+
+static void
+xdg_output_handle_done(void *data, struct zxdg_output_v1 *xdg_output)
+{
+    struct xwl_output *xwl_output = data;
+
+    xwl_output->xdg_output_done = TRUE;
+    if (xwl_output->wl_output_done &&
+        zxdg_output_v1_get_version(xdg_output) < 3)
+        apply_output_change(xwl_output);
+}
+
+static void
+xdg_output_handle_name(void *data, struct zxdg_output_v1 *xdg_output,
+                       const char *name)
+{
+}
+
+static void
+xdg_output_handle_description(void *data, struct zxdg_output_v1 *xdg_output,
+                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener xdg_output_listener = {
+    xdg_output_handle_logical_position,
+    xdg_output_handle_logical_size,
+    xdg_output_handle_done,
+    xdg_output_handle_name,
+    xdg_output_handle_description,
+};
+
+#define XRANDR_EMULATION_PROP "RANDR Emulation"
+static Atom
+get_rand_emulation_property(void)
+{
+    const char *emulStr = XRANDR_EMULATION_PROP;
+
+    return MakeAtom(emulStr, strlen(emulStr), TRUE);
+}
+
+static void
+xwl_output_set_emulated(struct xwl_output *xwl_output)
+{
+    int32_t val = TRUE;
+
+    RRChangeOutputProperty(xwl_output->randr_output,
+                           get_rand_emulation_property(),
+                           XA_INTEGER,
+                           32, PropModeReplace, 1,
+                           &val, FALSE, FALSE);
+}
+
+struct xwl_output*
+xwl_output_from_wl_output(struct xwl_screen *xwl_screen,
+                          struct wl_output* wl_output)
+{
+    struct xwl_output *xwl_output;
+
+    xorg_list_for_each_entry(xwl_output, &xwl_screen->output_list, link) {
+        if (xwl_output->output == wl_output)
+            return xwl_output;
+    }
+
+    return NULL;
+}
+
+struct xwl_output *
+xwl_output_create(struct xwl_screen *xwl_screen, uint32_t id, Bool with_xrandr)
+{
+    struct xwl_output *xwl_output;
+    char name[256];
+
+    xwl_output = calloc(1, sizeof *xwl_output);
+    if (xwl_output == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return NULL;
+    }
+
+    xwl_output->output = wl_registry_bind(xwl_screen->registry, id,
+                                          &wl_output_interface, 2);
+    if (!xwl_output->output) {
+        ErrorF("Failed binding wl_output\n");
+        goto err;
+    }
+
+    xwl_output->server_output_id = id;
+    wl_output_add_listener(xwl_output->output, &output_listener, xwl_output);
+
+    xwl_output->xwl_screen = xwl_screen;
+
+    if (with_xrandr) {
+        snprintf(name, sizeof name, "XWAYLAND%d",
+                 xwl_screen_get_next_output_serial(xwl_screen));
+
+        xwl_output->randr_crtc = RRCrtcCreate(xwl_screen->screen, xwl_output);
+        if (!xwl_output->randr_crtc) {
+            ErrorF("Failed creating RandR CRTC\n");
+            goto err;
+        }
+        RRCrtcSetRotations (xwl_output->randr_crtc, ALL_ROTATIONS);
+
+        xwl_output->randr_output = RROutputCreate(xwl_screen->screen, name,
+                                                  strlen(name), xwl_output);
+        if (!xwl_output->randr_output) {
+            ErrorF("Failed creating RandR Output\n");
+            goto err;
+        }
+        xwl_output_set_emulated(xwl_output);
+
+        RRCrtcGammaSetSize(xwl_output->randr_crtc, 256);
+        RROutputSetCrtcs(xwl_output->randr_output, &xwl_output->randr_crtc, 1);
+        RROutputSetConnection(xwl_output->randr_output, RR_Connected);
+        RRTellChanged(xwl_screen->screen);
+    }
+    /* We want the output to be in the list as soon as created so we can
+     * use it when binding to the xdg-output protocol...
+     */
+    xorg_list_append(&xwl_output->link, &xwl_screen->output_list);
+    --xwl_screen->expecting_event;
+
+    if (xwl_screen->xdg_output_manager)
+        xwl_output_get_xdg_output(xwl_output);
+
+    return xwl_output;
+
+err:
+    if (xwl_output->randr_crtc)
+        RRCrtcDestroy(xwl_output->randr_crtc);
+    if (xwl_output->output)
+        wl_output_destroy(xwl_output->output);
+    free(xwl_output);
+    return NULL;
+}
+
+void
+xwl_output_destroy(struct xwl_output *xwl_output)
+{
+    if (xwl_output->lease_connector)
+        wp_drm_lease_connector_v1_destroy(xwl_output->lease_connector);
+    if (xwl_output->xdg_output)
+        zxdg_output_v1_destroy(xwl_output->xdg_output);
+    if (xwl_output->output)
+        wl_output_destroy(xwl_output->output);
+    free(xwl_output);
+}
+
+void
+xwl_output_remove(struct xwl_output *xwl_output)
+{
+    struct xwl_output *it;
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+    int width = 0, height = 0;
+
+    xorg_list_del(&xwl_output->link);
+
+    if (xwl_output->randr_output)
+        RROutputSetConnection(xwl_output->randr_output, RR_Disconnected);
+
+    if (xwl_screen->fixed_output == NULL) {
+        xorg_list_for_each_entry(it, &xwl_screen->output_list, link)
+            output_get_new_size(it, &width, &height);
+        update_screen_size(xwl_screen, width, height);
+    }
+
+    if (xwl_output->randr_crtc)
+        RRCrtcDestroy(xwl_output->randr_crtc);
+    if (xwl_output->randr_output) {
+        RROutputDestroy(xwl_output->randr_output);
+        RRTellChanged(xwl_screen->screen);
+    }
+    xwl_output_destroy(xwl_output);
+}
+
+static Bool
+xwl_randr_get_info(ScreenPtr pScreen, Rotation * rotations)
+{
+    *rotations = ALL_ROTATIONS;
+
+    return TRUE;
+}
+
+#ifdef RANDR_10_INTERFACE
+static Bool
+xwl_randr_set_config(ScreenPtr pScreen,
+                     Rotation rotation, int rate, RRScreenSizePtr pSize)
+{
+    return FALSE;
+}
+#endif
+
+#if RANDR_12_INTERFACE
+static Bool
+xwl_randr_screen_set_size(ScreenPtr pScreen,
+                          CARD16 width,
+                          CARD16 height,
+                          CARD32 mmWidth, CARD32 mmHeight)
+{
+    return TRUE;
+}
+
+static Bool
+xwl_randr_crtc_set(ScreenPtr pScreen,
+                   RRCrtcPtr crtc,
+                   RRModePtr new_mode,
+                   int x,
+                   int y,
+                   Rotation rotation,
+                   int numOutputs, RROutputPtr * outputs)
+{
+    struct xwl_output *xwl_output = crtc->devPrivate;
+    RRModePtr mode;
+
+    if (new_mode) {
+        mode = xwl_output_find_mode(xwl_output,
+                                    new_mode->mode.width,
+                                    new_mode->mode.height);
+    } else {
+        mode = xwl_output_find_mode(xwl_output, -1, -1);
+    }
+    if (!mode)
+        return FALSE;
+
+    xwl_output_set_emulated_mode(xwl_output, GetCurrentClient(), mode, FALSE);
+
+    /* A real randr implementation would call:
+     * RRCrtcNotify(xwl_output->randr_crtc, mode, xwl_output->x, xwl_output->y,
+     *              xwl_output->rotation, NULL, 1, &xwl_output->randr_output);
+     * here to update the mode reported to clients querying the randr settings
+     * but that influences *all* clients and we do randr mode change emulation
+     * on a per client basis. So we just return success here.
+     */
+
+    return TRUE;
+}
+
+static void
+xwl_randr_crtc_get(ScreenPtr pScreen,
+                   RRCrtcPtr crtc,
+                   xRRGetCrtcInfoReply *rep)
+{
+    struct xwl_output *xwl_output = crtc->devPrivate;
+
+    struct xwl_emulated_mode *mode = xwl_output_get_emulated_mode_for_client(
+        xwl_output, GetCurrentClient());
+
+    if (mode)
+        rep->mode = mode->id;
+}
+
+static Bool
+xwl_randr_crtc_set_gamma(ScreenPtr pScreen, RRCrtcPtr crtc)
+{
+    return TRUE;
+}
+
+static Bool
+xwl_randr_crtc_get_gamma(ScreenPtr pScreen, RRCrtcPtr crtc)
+{
+    return TRUE;
+}
+
+static Bool
+xwl_randr_output_set_property(ScreenPtr pScreen,
+                              RROutputPtr output,
+                              Atom property,
+                              RRPropertyValuePtr value)
+{
+    /* RANDR Emulation property is read-only. */
+    if (get_rand_emulation_property() == property)
+        return FALSE;
+
+    return TRUE;
+}
+
+static Bool
+xwl_output_validate_mode(ScreenPtr pScreen,
+                         RROutputPtr output,
+                         RRModePtr mode)
+{
+    return TRUE;
+}
+
+static void
+xwl_randr_mode_destroy(ScreenPtr pScreen, RRModePtr mode)
+{
+    return;
+}
+#endif
+
+Bool
+xwl_screen_init_output(struct xwl_screen *xwl_screen)
+{
+    rrScrPrivPtr rp;
+
+    if (!RRScreenInit(xwl_screen->screen))
+        return FALSE;
+
+    RRScreenSetSizeRange(xwl_screen->screen, 16, 16, 32767, 32767);
+
+    rp = rrGetScrPriv(xwl_screen->screen);
+    rp->rrGetInfo = xwl_randr_get_info;
+
+#if RANDR_10_INTERFACE
+    rp->rrSetConfig = xwl_randr_set_config;
+#endif
+
+#if RANDR_12_INTERFACE
+    rp->rrScreenSetSize = xwl_randr_screen_set_size;
+    rp->rrCrtcSet = xwl_randr_crtc_set;
+    rp->rrCrtcGet = xwl_randr_crtc_get;
+    rp->rrCrtcSetGamma = xwl_randr_crtc_set_gamma;
+    rp->rrCrtcGetGamma = xwl_randr_crtc_get_gamma;
+    rp->rrOutputSetProperty = xwl_randr_output_set_property;
+    rp->rrOutputValidateMode = xwl_output_validate_mode;
+    rp->rrModeDestroy = xwl_randr_mode_destroy;
+#endif
+
+    rp->rrRequestLease = xwl_randr_request_lease;
+    rp->rrGetLease = xwl_randr_get_lease;
+    rp->rrTerminateLease = xwl_randr_terminate_lease;
+
+    return TRUE;
+}
+
+static int
+mode_sort(const void *left, const void *right)
+{
+    const RRModePtr *mode_a = left;
+    const RRModePtr *mode_b = right;
+
+    if ((*mode_b)->mode.width == (*mode_a)->mode.width)
+        return (*mode_b)->mode.height - (*mode_a)->mode.height;
+
+    return (*mode_b)->mode.width - (*mode_a)->mode.width;
+}
+
+static Bool
+xwl_randr_add_modes_fixed(struct xwl_output *xwl_output,
+                          int current_width, int current_height)
+{
+    RRModePtr *modes = NULL;
+    RRModePtr mode;
+    xRRModeInfo mode_info = { 0, };
+    char mode_name[128];
+    int i, nmodes, current;
+
+
+    modes = xallocarray(ARRAY_SIZE(xwl_output_fake_modes) + 1, sizeof(RRModePtr));
+    if (!modes) {
+        ErrorF("Failed to allocated RandR modes\n");
+        return FALSE;
+    }
+
+    nmodes = 0;
+    current = 0;
+
+    /* Add fake modes */
+    for (i = 0; i < ARRAY_SIZE(xwl_output_fake_modes); i++) {
+        if (xwl_output_fake_modes[i][0] == current_width &&
+            xwl_output_fake_modes[i][1] == current_height)
+            current = 1;
+
+        mode = xwayland_cvt(xwl_output_fake_modes[i][0],
+                            xwl_output_fake_modes[i][1],
+                            60, 0, 0);
+
+        if (mode)
+            modes[nmodes++] = mode;
+    }
+
+    if (!current) {
+        /* Add the current mode as it's not part of the fake modes.
+         * Not using libcvt as the size is set from the command line and
+         * may not be a valid CVT mode.
+         */
+        mode_info.width = current_width;
+        mode_info.height = current_height;
+        mode_info.hTotal = current_width;
+        mode_info.vTotal = current_height;
+        mode_info.dotClock = 60 * 1000 * 1000;
+
+        snprintf(mode_name, sizeof(mode_name), "%dx%d",
+                 current_width, current_height);
+        mode_info.nameLength = strlen(mode_name);
+
+        modes[nmodes++] = RRModeGet(&mode_info, mode_name);
+    }
+
+    qsort(modes, nmodes, sizeof(RRModePtr), mode_sort);
+    RROutputSetModes(xwl_output->randr_output, modes, nmodes, 1);
+    free(modes);
+
+    return TRUE;
+}
+
+void
+xwl_output_set_mode_fixed(struct xwl_output *xwl_output, RRModePtr mode)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+
+    update_screen_size(xwl_screen, mode->mode.width, mode->mode.height);
+
+    RRCrtcNotify(xwl_output->randr_crtc, mode, 0, 0, RR_Rotate_0,
+                 NULL, 1, &xwl_output->randr_output);
+}
+
+static Bool
+xwl_randr_set_config_fixed(ScreenPtr pScreen,
+                           Rotation randr, int rate, RRScreenSizePtr pSize)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+
+    update_screen_size(xwl_screen, pSize->width, pSize->height);
+
+    return TRUE;
+}
+
+/* Create a single RR output/mode used with a fixed geometry */
+Bool
+xwl_screen_init_randr_fixed(struct xwl_screen *xwl_screen)
+{
+    struct xwl_output *xwl_output;
+    rrScrPrivPtr rp;
+    RRModePtr mode;
+
+    xwl_output = calloc(1, sizeof *xwl_output);
+    if (xwl_output == NULL) {
+        ErrorF("%s ENOMEM\n", __func__);
+        return FALSE;
+    }
+
+    if (!RRScreenInit(xwl_screen->screen))
+        goto err;
+
+    RRScreenSetSizeRange(xwl_screen->screen, 16, 16, 32767, 32767);
+
+    rp = rrGetScrPriv(xwl_screen->screen);
+    rp->rrGetInfo = xwl_randr_get_info;
+    rp->rrSetConfig = xwl_randr_set_config_fixed;
+
+    xwl_output->randr_output = RROutputCreate(xwl_screen->screen, "XWAYLAND0", 9, NULL);
+    if (!xwl_output->randr_output) {
+        ErrorF("Failed to create RandR output\n");
+        goto err;
+    }
+
+    xwl_output->randr_crtc = RRCrtcCreate(xwl_screen->screen, xwl_output);
+    if (!xwl_output->randr_crtc) {
+        ErrorF("Failed to create RandR CRTC\n");
+        goto err;
+    }
+    RRCrtcSetRotations (xwl_output->randr_crtc, RR_Rotate_0);
+    RRCrtcGammaSetSize(xwl_output->randr_crtc, 256);
+    RROutputSetCrtcs(xwl_output->randr_output, &xwl_output->randr_crtc, 1);
+
+    xwl_randr_add_modes_fixed(xwl_output,
+                              xwl_screen->width, xwl_screen->height);
+    /* Current mode */
+    mode = xwl_output_find_mode(xwl_output,
+                                xwl_screen->width, xwl_screen->height);
+    RRCrtcNotify(xwl_output->randr_crtc, mode, 0, 0, RR_Rotate_0,
+                 NULL, 1, &xwl_output->randr_output);
+
+    RROutputSetPhysicalSize(xwl_output->randr_output,
+                            (xwl_screen->width * 25.4) / monitorResolution,
+                            (xwl_screen->height * 25.4) / monitorResolution);
+
+    RROutputSetConnection(xwl_output->randr_output, RR_Connected);
+
+    xwl_output->xwl_screen = xwl_screen;
+    xwl_screen->fixed_output = xwl_output;
+
+    return TRUE;
+
+err:
+    if (xwl_output->randr_crtc)
+        RRCrtcDestroy(xwl_output->randr_crtc);
+    if (xwl_output->randr_output)
+        RROutputDestroy(xwl_output->randr_output);
+    free(xwl_output);
+
+    return FALSE;
+}
+
+static void
+xwl_output_get_xdg_output(struct xwl_output *xwl_output)
+{
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+
+    if (!xwl_output->output) {
+        /* This can happen when an output is created from a leasable DRM
+         * connector */
+        return;
+    }
+
+    xwl_output->xdg_output =
+        zxdg_output_manager_v1_get_xdg_output (xwl_screen->xdg_output_manager,
+                                               xwl_output->output);
+
+    zxdg_output_v1_add_listener(xwl_output->xdg_output,
+                                &xdg_output_listener,
+                                xwl_output);
+}
+
+void
+xwl_screen_init_xdg_output(struct xwl_screen *xwl_screen)
+{
+    struct xwl_output *it;
+
+    assert(xwl_screen->xdg_output_manager);
+
+    xorg_list_for_each_entry(it, &xwl_screen->output_list, link)
+        xwl_output_get_xdg_output(it);
+}
diff --git a/hw/xwayland/xwayland-output.h b/hw/xwayland/xwayland-output.h
new file mode 100644
index 000000000..e975dfbf6
--- /dev/null
+++ b/hw/xwayland/xwayland-output.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_OUTPUT_H
+#define XWAYLAND_OUTPUT_H
+
+#include <xwayland-config.h>
+#include <wayland-client.h>
+
+#include <dix.h>
+#include <input.h>
+#include <randrstr.h>
+
+#include "xwayland-types.h"
+#include "xwayland-drm-lease.h"
+
+#define ALL_ROTATIONS (RR_Rotate_0   | \
+                       RR_Rotate_90  | \
+                       RR_Rotate_180 | \
+                       RR_Rotate_270 | \
+                       RR_Reflect_X  | \
+                       RR_Reflect_Y)
+
+struct xwl_output {
+    struct xorg_list link;
+    struct xwl_screen *xwl_screen;
+    RROutputPtr randr_output;
+    RRCrtcPtr randr_crtc;
+
+    /* only for regular outputs */
+    struct wl_output *output;
+    struct zxdg_output_v1 *xdg_output;
+    uint32_t server_output_id;
+    int32_t x, y, width, height, refresh;
+    Rotation rotation;
+    Bool wl_output_done;
+    Bool xdg_output_done;
+
+    /* only for lease-able DRM connectors */
+    struct wp_drm_lease_connector_v1 *lease_connector;
+    struct xwl_drm_lease *lease;
+    struct xwl_drm_lease_device *lease_device;
+};
+
+/* Per client per output emulated randr/vidmode resolution info. */
+struct xwl_emulated_mode {
+    uint32_t server_output_id;
+    int32_t width;
+    int32_t height;
+    RRMode id;
+    Bool from_vidmode;
+};
+
+Bool xwl_screen_init_output(struct xwl_screen *xwl_screen);
+
+Bool xwl_screen_init_randr_fixed(struct xwl_screen *xwl_screen);
+
+void xwl_output_set_mode_fixed(struct xwl_output *xwl_output,
+                               RRModePtr mode);
+
+struct xwl_output *xwl_output_from_wl_output(struct xwl_screen *xwl_screen,
+                                             struct wl_output* wl_output);
+
+struct xwl_output *xwl_output_create(struct xwl_screen *xwl_screen,
+                                     uint32_t id, Bool with_xrandr);
+
+void xwl_output_destroy(struct xwl_output *xwl_output);
+
+void xwl_output_remove(struct xwl_output *xwl_output);
+
+struct xwl_emulated_mode *xwl_output_get_emulated_mode_for_client(
+                            struct xwl_output *xwl_output, ClientPtr client);
+
+RRModePtr xwl_output_find_mode(struct xwl_output *xwl_output,
+                               int32_t width, int32_t height);
+void xwl_output_set_emulated_mode(struct xwl_output *xwl_output,
+                                  ClientPtr client, RRModePtr mode,
+                                  Bool from_vidmode);
+void xwl_output_set_window_randr_emu_props(struct xwl_screen *xwl_screen,
+                                           WindowPtr window);
+
+void xwl_screen_init_xdg_output(struct xwl_screen *xwl_screen);
+
+#endif /* XWAYLAND_OUTPUT_H */
diff --git a/hw/xwayland/xwayland-pixmap.c b/hw/xwayland/xwayland-pixmap.c
new file mode 100644
index 000000000..6e797a34c
--- /dev/null
+++ b/hw/xwayland/xwayland-pixmap.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <X11/X.h>
+
+#include "os.h"
+#include "privates.h"
+#include "dix.h"
+#include "fb.h"
+#include "pixmapstr.h"
+
+#include "xwayland-types.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-window-buffers.h"
+
+static DevPrivateKeyRec xwl_pixmap_private_key;
+static DevPrivateKeyRec xwl_pixmap_cb_private_key;
+
+struct xwl_pixmap_buffer_release_callback {
+    xwl_buffer_release_cb callback;
+    void *data;
+};
+
+void
+xwl_pixmap_set_private(PixmapPtr pixmap, struct xwl_pixmap *xwl_pixmap)
+{
+    dixSetPrivate(&pixmap->devPrivates, &xwl_pixmap_private_key, xwl_pixmap);
+}
+
+struct xwl_pixmap *
+xwl_pixmap_get(PixmapPtr pixmap)
+{
+    return dixLookupPrivate(&pixmap->devPrivates, &xwl_pixmap_private_key);
+}
+
+Bool
+xwl_pixmap_set_buffer_release_cb(PixmapPtr pixmap,
+                                 xwl_buffer_release_cb func, void *data)
+{
+    struct xwl_pixmap_buffer_release_callback *xwl_pixmap_buffer_release_callback;
+
+    xwl_pixmap_buffer_release_callback = dixLookupPrivate(&pixmap->devPrivates,
+                                                          &xwl_pixmap_cb_private_key);
+
+    if (xwl_pixmap_buffer_release_callback == NULL) {
+        xwl_pixmap_buffer_release_callback =
+            calloc(1, sizeof (struct xwl_pixmap_buffer_release_callback));
+
+        if (xwl_pixmap_buffer_release_callback == NULL) {
+            ErrorF("Failed to allocate pixmap callback data\n");
+            return FALSE;
+        }
+        dixSetPrivate(&pixmap->devPrivates, &xwl_pixmap_cb_private_key,
+                      xwl_pixmap_buffer_release_callback);
+    }
+
+    xwl_pixmap_buffer_release_callback->callback = func;
+    xwl_pixmap_buffer_release_callback->data = data;
+
+    return TRUE;
+}
+
+void
+xwl_pixmap_del_buffer_release_cb(PixmapPtr pixmap)
+{
+    struct xwl_pixmap_buffer_release_callback *xwl_pixmap_buffer_release_callback;
+
+    xwl_pixmap_buffer_release_callback = dixLookupPrivate(&pixmap->devPrivates,
+                                                          &xwl_pixmap_cb_private_key);
+    if (xwl_pixmap_buffer_release_callback) {
+        dixSetPrivate(&pixmap->devPrivates, &xwl_pixmap_cb_private_key, NULL);
+        free(xwl_pixmap_buffer_release_callback);
+    }
+}
+
+void
+xwl_pixmap_buffer_release_cb(void *data, struct wl_buffer *wl_buffer)
+{
+    PixmapPtr pixmap = data;
+    struct xwl_pixmap_buffer_release_callback *xwl_pixmap_buffer_release_callback;
+
+    xwl_pixmap_buffer_release_callback = dixLookupPrivate(&pixmap->devPrivates,
+                                                          &xwl_pixmap_cb_private_key);
+    if (xwl_pixmap_buffer_release_callback)
+        (*xwl_pixmap_buffer_release_callback->callback)
+            (xwl_pixmap_buffer_release_callback->data);
+}
+
+Bool
+xwl_pixmap_init(void)
+{
+    if (!dixRegisterPrivateKey(&xwl_pixmap_private_key, PRIVATE_PIXMAP, 0))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&xwl_pixmap_cb_private_key, PRIVATE_PIXMAP, 0))
+        return FALSE;
+
+    return TRUE;
+}
diff --git a/hw/xwayland/xwayland-pixmap.h b/hw/xwayland/xwayland-pixmap.h
new file mode 100644
index 000000000..06ee4898a
--- /dev/null
+++ b/hw/xwayland/xwayland-pixmap.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_PIXMAP_H
+#define XWAYLAND_PIXMAP_H
+
+#include <xwayland-config.h>
+#include <wayland-client.h>
+
+#include "pixmapstr.h"
+
+/* This is an opaque structure implemented in the different backends */
+struct xwl_pixmap;
+
+typedef void (*xwl_buffer_release_cb) (void *data);
+
+void xwl_pixmap_set_private(PixmapPtr pixmap, struct xwl_pixmap *xwl_pixmap);
+struct xwl_pixmap *xwl_pixmap_get(PixmapPtr pixmap);
+Bool xwl_pixmap_set_buffer_release_cb(PixmapPtr pixmap,
+                                      xwl_buffer_release_cb func, void *data);
+void xwl_pixmap_del_buffer_release_cb(PixmapPtr pixmap);
+void xwl_pixmap_buffer_release_cb(void *data, struct wl_buffer *wl_buffer);
+Bool xwl_pixmap_init(void);
+
+#endif /* XWAYLAND_PIXMAP_H */
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
new file mode 100644
index 000000000..2c0e1a05c
--- /dev/null
+++ b/hw/xwayland/xwayland-present.c
@@ -0,0 +1,1026 @@
+/*
+ * Copyright © 2018 Roman Gilg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <windowstr.h>
+#include <present.h>
+
+#include "xwayland-present.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+#include "xwayland-pixmap.h"
+#include "glamor.h"
+
+
+#define XWL_PRESENT_CAPS PresentCapabilityAsync
+
+
+/*
+ * When not flipping let Present copy with 60fps.
+ * When flipping wait on frame_callback, otherwise
+ * the surface is not visible, in this case update
+ * with long interval.
+ */
+#define TIMER_LEN_COPY      17  // ~60fps
+#define TIMER_LEN_FLIP    1000  // 1fps
+
+static DevPrivateKeyRec xwl_present_window_private_key;
+
+static struct xwl_present_window *
+xwl_present_window_priv(WindowPtr window)
+{
+    return dixGetPrivate(&window->devPrivates,
+                         &xwl_present_window_private_key);
+}
+
+static struct xwl_present_window *
+xwl_present_window_get_priv(WindowPtr window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+
+    if (xwl_present_window == NULL) {
+        xwl_present_window = calloc (1, sizeof (struct xwl_present_window));
+        if (!xwl_present_window)
+            return NULL;
+
+        xwl_present_window->window = window;
+        xwl_present_window->msc = 1;
+        xwl_present_window->ust = GetTimeInMicros();
+
+        xorg_list_init(&xwl_present_window->frame_callback_list);
+        xorg_list_init(&xwl_present_window->wait_list);
+        xorg_list_init(&xwl_present_window->flip_queue);
+        xorg_list_init(&xwl_present_window->idle_queue);
+
+        dixSetPrivate(&window->devPrivates,
+                      &xwl_present_window_private_key,
+                      xwl_present_window);
+    }
+
+    return xwl_present_window;
+}
+
+static struct xwl_present_event *
+xwl_present_event_from_id(uint64_t event_id)
+{
+    return (struct xwl_present_event*)(uintptr_t)event_id;
+}
+
+static void
+xwl_present_free_timer(struct xwl_present_window *xwl_present_window)
+{
+    TimerFree(xwl_present_window->frame_timer);
+    xwl_present_window->frame_timer = NULL;
+    xwl_present_window->timer_armed = 0;
+}
+
+static CARD32
+xwl_present_timer_callback(OsTimerPtr timer,
+                           CARD32 time,
+                           void *arg);
+
+static present_vblank_ptr
+xwl_present_get_pending_flip(struct xwl_present_window *xwl_present_window)
+{
+    present_vblank_ptr flip_pending;
+
+    if (xorg_list_is_empty(&xwl_present_window->flip_queue))
+        return NULL;
+
+    flip_pending = xorg_list_first_entry(&xwl_present_window->flip_queue, present_vblank_rec,
+                                         event_queue);
+
+    if (flip_pending->queued)
+        return NULL;
+
+    return flip_pending;
+}
+
+static inline Bool
+xwl_present_has_pending_events(struct xwl_present_window *xwl_present_window)
+{
+    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+
+    return (flip_pending && flip_pending->sync_flip) ||
+           !xorg_list_is_empty(&xwl_present_window->wait_list);
+}
+
+void
+xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
+{
+    if (xwl_present_has_pending_events(xwl_present_window)) {
+        struct xwl_window *xwl_window = xwl_window_from_window(xwl_present_window->window);
+        CARD32 now = GetTimeInMillis();
+        CARD32 timeout;
+
+        if (xwl_window && xwl_window->frame_callback &&
+            !xorg_list_is_empty(&xwl_present_window->frame_callback_list))
+            timeout = TIMER_LEN_FLIP;
+        else
+            timeout = TIMER_LEN_COPY;
+
+        /* Make sure the timer callback runs if at least a second has passed
+         * since we first armed the timer. This can happen e.g. if the Wayland
+         * compositor doesn't send a pending frame event, e.g. because the
+         * Wayland surface isn't visible anywhere.
+         */
+        if (xwl_present_window->timer_armed) {
+            if ((int)(now - xwl_present_window->timer_armed) > 1000) {
+                xwl_present_timer_callback(xwl_present_window->frame_timer, now,
+                                           xwl_present_window);
+                return;
+            }
+        } else {
+            xwl_present_window->timer_armed = now;
+        }
+
+        xwl_present_window->frame_timer = TimerSet(xwl_present_window->frame_timer,
+                                                   0, timeout,
+                                                   &xwl_present_timer_callback,
+                                                   xwl_present_window);
+    } else {
+        xwl_present_free_timer(xwl_present_window);
+    }
+}
+
+
+static void
+xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc);
+
+static uint32_t
+xwl_present_query_capabilities(present_screen_priv_ptr screen_priv)
+{
+    return XWL_PRESENT_CAPS;
+}
+
+static int
+xwl_present_get_ust_msc(ScreenPtr screen,
+                        WindowPtr present_window,
+                        uint64_t *ust,
+                        uint64_t *msc)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
+    if (!xwl_present_window)
+        return BadAlloc;
+
+    *ust = xwl_present_window->ust;
+    *msc = xwl_present_window->msc;
+
+    return Success;
+}
+
+/*
+ * When the wait fence or previous flip is completed, it's time
+ * to re-try the request
+ */
+static void
+xwl_present_re_execute(present_vblank_ptr vblank)
+{
+    uint64_t ust = 0, crtc_msc = 0;
+
+    (void) xwl_present_get_ust_msc(vblank->screen, vblank->window, &ust, &crtc_msc);
+    xwl_present_execute(vblank, ust, crtc_msc);
+}
+
+static void
+xwl_present_flip_try_ready(struct xwl_present_window *xwl_present_window)
+{
+    present_vblank_ptr vblank;
+
+    xorg_list_for_each_entry(vblank, &xwl_present_window->flip_queue, event_queue) {
+        if (vblank->queued) {
+            xwl_present_re_execute(vblank);
+            return;
+        }
+    }
+}
+
+static void
+xwl_present_release_pixmap(struct xwl_present_event *event)
+{
+    if (!event->pixmap)
+        return;
+
+    xwl_pixmap_del_buffer_release_cb(event->pixmap);
+    dixDestroyPixmap(event->pixmap, event->pixmap->drawable.id);
+    event->pixmap = NULL;
+}
+
+static void
+xwl_present_free_event(struct xwl_present_event *event)
+{
+    xwl_present_release_pixmap(event);
+    xorg_list_del(&event->vblank.event_queue);
+    present_vblank_destroy(&event->vblank);
+}
+
+static void
+xwl_present_free_idle_vblank(present_vblank_ptr vblank)
+{
+    present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
+    xwl_present_free_event(xwl_present_event_from_id((uintptr_t)vblank));
+}
+
+static WindowPtr
+xwl_present_toplvl_pixmap_window(WindowPtr window)
+{
+    ScreenPtr       screen = window->drawable.pScreen;
+    PixmapPtr       pixmap = (*screen->GetWindowPixmap)(window);
+    WindowPtr       w = window;
+    WindowPtr       next_w;
+
+    while(w->parent) {
+        next_w = w->parent;
+        if ( (*screen->GetWindowPixmap)(next_w) != pixmap) {
+            break;
+        }
+        w = next_w;
+    }
+    return w;
+}
+
+static void
+xwl_present_flips_stop(WindowPtr window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    present_vblank_ptr vblank, tmp;
+
+    /* Change back to the fast refresh rate */
+    xwl_present_reset_timer(xwl_present_window);
+
+    /* Free any left over idle vblanks */
+    xorg_list_for_each_entry_safe(vblank, tmp, &xwl_present_window->idle_queue, event_queue)
+        xwl_present_free_idle_vblank(vblank);
+
+    if (xwl_present_window->flip_active) {
+        struct xwl_present_event *event;
+
+        vblank = xwl_present_window->flip_active;
+        event = xwl_present_event_from_id((uintptr_t)vblank);
+        if (event->pixmap)
+            xwl_present_free_idle_vblank(vblank);
+        else
+            xwl_present_free_event(event);
+
+        xwl_present_window->flip_active = NULL;
+    }
+
+    xwl_present_flip_try_ready(xwl_present_window);
+}
+
+static void
+xwl_present_flip_notify_vblank(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
+{
+    WindowPtr                   window = vblank->window;
+    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    uint8_t mode = PresentCompleteModeFlip;
+
+    DebugPresent(("\tn %" PRIu64 " %p %" PRIu64 " %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
+                  vblank->event_id, vblank, vblank->exec_msc, vblank->target_msc,
+                  vblank->pixmap ? vblank->pixmap->drawable.id : 0,
+                  vblank->window ? vblank->window->drawable.id : 0));
+
+    assert (&vblank->event_queue == xwl_present_window->flip_queue.next);
+
+    xorg_list_del(&vblank->event_queue);
+
+    if (xwl_present_window->flip_active) {
+        struct xwl_present_event *event =
+            xwl_present_event_from_id((uintptr_t)xwl_present_window->flip_active);
+
+        if (!event->pixmap)
+            xwl_present_free_event(event);
+        else
+            /* Put the previous flip in the idle_queue and wait for further notice from
+             * the Wayland compositor
+             */
+            xorg_list_append(&xwl_present_window->flip_active->event_queue, &xwl_present_window->idle_queue);
+    }
+
+    xwl_present_window->flip_active = vblank;
+
+    if (vblank->reason == PRESENT_FLIP_REASON_BUFFER_FORMAT)
+        mode = PresentCompleteModeSuboptimalCopy;
+
+    present_vblank_notify(vblank, PresentCompleteKindPixmap, mode, ust, crtc_msc);
+
+    if (vblank->abort_flip)
+        xwl_present_flips_stop(window);
+
+    xwl_present_flip_try_ready(xwl_present_window);
+}
+
+static void
+xwl_present_update_window_crtc(present_window_priv_ptr window_priv, RRCrtcPtr crtc, uint64_t new_msc)
+{
+    /* Crtc unchanged, no offset. */
+    if (crtc == window_priv->crtc)
+        return;
+
+    /* No crtc earlier to offset against, just set the crtc. */
+    if (window_priv->crtc == PresentCrtcNeverSet) {
+        window_priv->msc_offset = 0;
+        window_priv->crtc = crtc;
+        return;
+    }
+
+    /* In window-mode the last correct msc-offset is always kept
+     * in window-priv struct because msc is saved per window and
+     * not per crtc as in screen-mode.
+     */
+    window_priv->msc_offset += new_msc - window_priv->msc;
+    window_priv->crtc = crtc;
+}
+
+
+void
+xwl_present_cleanup(WindowPtr window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    present_window_priv_ptr window_priv = present_window_priv(window);
+    struct xwl_present_event *event, *tmp;
+
+    if (!xwl_present_window)
+        return;
+
+    xorg_list_del(&xwl_present_window->frame_callback_list);
+
+    if (xwl_present_window->sync_callback) {
+        wl_callback_destroy(xwl_present_window->sync_callback);
+        xwl_present_window->sync_callback = NULL;
+    }
+
+    /* Clear remaining events */
+    xorg_list_for_each_entry_safe(event, tmp, &window_priv->vblank, vblank.window_list)
+        xwl_present_free_event(event);
+
+    /* Clear timer */
+    xwl_present_free_timer(xwl_present_window);
+
+    /* Remove from privates so we don't try to access it later */
+    dixSetPrivate(&window->devPrivates,
+                  &xwl_present_window_private_key,
+                  NULL);
+
+    free(xwl_present_window);
+}
+
+static void
+xwl_present_buffer_release(void *data)
+{
+    struct xwl_present_window *xwl_present_window;
+    struct xwl_present_event *event = data;
+    present_vblank_ptr vblank;
+
+    if (!event)
+        return;
+
+    vblank = &event->vblank;
+    present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
+
+    xwl_present_window = xwl_present_window_priv(vblank->window);
+    if (xwl_present_window->flip_active == vblank ||
+        xwl_present_get_pending_flip(xwl_present_window) == vblank)
+        xwl_present_release_pixmap(event);
+    else
+        xwl_present_free_event(event);
+}
+
+static void
+xwl_present_msc_bump(struct xwl_present_window *xwl_present_window)
+{
+    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+    uint64_t msc = ++xwl_present_window->msc;
+    present_vblank_ptr vblank, tmp;
+
+    xwl_present_window->ust = GetTimeInMicros();
+
+    xwl_present_window->timer_armed = 0;
+
+    if (flip_pending && flip_pending->sync_flip)
+        xwl_present_flip_notify_vblank(flip_pending, xwl_present_window->ust, msc);
+
+    xorg_list_for_each_entry_safe(vblank, tmp, &xwl_present_window->wait_list, event_queue) {
+        if (vblank->exec_msc <= msc) {
+            DebugPresent(("\te %" PRIu64 " ust %" PRIu64 " msc %" PRIu64 "\n",
+                          vblank->event_id, xwl_present_window->ust, msc));
+
+            xwl_present_execute(vblank, xwl_present_window->ust, msc);
+        }
+    }
+}
+
+static CARD32
+xwl_present_timer_callback(OsTimerPtr timer,
+                           CARD32 time,
+                           void *arg)
+{
+    struct xwl_present_window *xwl_present_window = arg;
+
+    /* If we were expecting a frame callback for this window, it didn't arrive
+     * in a second. Stop listening to it to avoid double-bumping the MSC
+     */
+    xorg_list_del(&xwl_present_window->frame_callback_list);
+
+    xwl_present_msc_bump(xwl_present_window);
+    xwl_present_reset_timer(xwl_present_window);
+
+    return 0;
+}
+
+void
+xwl_present_frame_callback(struct xwl_present_window *xwl_present_window)
+{
+    xorg_list_del(&xwl_present_window->frame_callback_list);
+
+    xwl_present_msc_bump(xwl_present_window);
+
+    /* we do not need the timer anymore for this frame,
+     * reset it for potentially the next one
+     */
+    xwl_present_reset_timer(xwl_present_window);
+}
+
+static void
+xwl_present_sync_callback(void *data,
+               struct wl_callback *callback,
+               uint32_t time)
+{
+    present_vblank_ptr vblank = data;
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(vblank->window);
+
+    wl_callback_destroy(xwl_present_window->sync_callback);
+    xwl_present_window->sync_callback = NULL;
+
+    xwl_present_flip_notify_vblank(vblank, xwl_present_window->ust, xwl_present_window->msc);
+}
+
+static const struct wl_callback_listener xwl_present_sync_listener = {
+    xwl_present_sync_callback
+};
+
+static RRCrtcPtr
+xwl_present_get_crtc(present_screen_priv_ptr screen_priv,
+                     WindowPtr present_window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
+    rrScrPrivPtr rr_private;
+
+    if (xwl_present_window == NULL)
+        return NULL;
+
+    rr_private = rrGetScrPriv(present_window->drawable.pScreen);
+
+    if (rr_private->numCrtcs == 0)
+        return NULL;
+
+    return rr_private->crtcs[0];
+}
+
+/*
+ * Queue an event to report back to the Present extension when the specified
+ * MSC has passed
+ */
+static int
+xwl_present_queue_vblank(ScreenPtr screen,
+                         WindowPtr present_window,
+                         RRCrtcPtr crtc,
+                         uint64_t event_id,
+                         uint64_t msc)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
+    struct xwl_window *xwl_window = xwl_window_from_window(present_window);
+    struct xwl_present_event *event = xwl_present_event_from_id(event_id);
+
+    event->vblank.exec_msc = msc;
+
+    xorg_list_del(&event->vblank.event_queue);
+    xorg_list_append(&event->vblank.event_queue, &xwl_present_window->wait_list);
+
+    /* Hook up to frame callback */
+    if (xwl_window &&
+        xorg_list_is_empty(&xwl_present_window->frame_callback_list)) {
+        xorg_list_add(&xwl_present_window->frame_callback_list,
+                      &xwl_window->frame_callback_list);
+    }
+
+    if ((xwl_window && xwl_window->frame_callback) ||
+        !xwl_present_window->frame_timer)
+        xwl_present_reset_timer(xwl_present_window);
+
+    return Success;
+}
+
+/*
+ * Remove a pending vblank event so that it is not reported
+ * to the extension
+ */
+static void
+xwl_present_abort_vblank(ScreenPtr screen,
+                         WindowPtr present_window,
+                         RRCrtcPtr crtc,
+                         uint64_t event_id,
+                         uint64_t msc)
+{
+    static Bool called;
+
+    if (called)
+        return;
+
+    /* xwl_present_cleanup should have cleaned up everything,
+     * present_free_window_vblank shouldn't need to call this.
+     */
+    ErrorF("Unexpected call to %s:\n", __func__);
+    xorg_backtrace();
+}
+
+static void
+xwl_present_flush(WindowPtr window)
+{
+    glamor_block_handler(window->drawable.pScreen);
+}
+
+static void
+xwl_present_maybe_set_reason(struct xwl_window *xwl_window, PresentFlipReason *reason)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (!reason || xwl_screen->dmabuf_protocol_version < 4)
+        return;
+
+    if (xwl_window->feedback.unprocessed_feedback_pending) {
+        xwl_window->feedback.unprocessed_feedback_pending = 0;
+
+        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+    }
+
+    if (xwl_screen->default_feedback.unprocessed_feedback_pending) {
+        xwl_screen->default_feedback.unprocessed_feedback_pending = 0;
+
+        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+    }
+}
+
+static Bool
+xwl_present_check_flip(RRCrtcPtr crtc,
+                       WindowPtr present_window,
+                       PixmapPtr pixmap,
+                       Bool sync_flip,
+                       RegionPtr valid,
+                       int16_t x_off,
+                       int16_t y_off,
+                       PresentFlipReason *reason)
+{
+    WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(present_window);
+    struct xwl_window *xwl_window = xwl_window_from_window(present_window);
+    ScreenPtr screen = pixmap->drawable.pScreen;
+
+    if (reason)
+        *reason = PRESENT_FLIP_REASON_UNKNOWN;
+
+    if (!xwl_window)
+        return FALSE;
+
+    xwl_present_maybe_set_reason(xwl_window, reason);
+
+    if (!crtc)
+        return FALSE;
+
+    /* Source pixmap must align with window exactly */
+    if (x_off || y_off)
+        return FALSE;
+
+    /* Valid area must contain window (for simplicity for now just never flip when one is set). */
+    if (valid)
+        return FALSE;
+
+    /* Flip pixmap must have same dimensions as window */
+    if (present_window->drawable.width != pixmap->drawable.width ||
+            present_window->drawable.height != pixmap->drawable.height)
+        return FALSE;
+
+    /* Window must be same region as toplevel window */
+    if ( !RegionEqual(&present_window->winSize, &toplvl_window->winSize) )
+        return FALSE;
+
+    /* Can't flip if window clipped by children */
+    if (!RegionEqual(&present_window->clipList, &present_window->winSize))
+        return FALSE;
+
+    if (!xwl_glamor_check_flip(pixmap))
+        return FALSE;
+
+    /* Can't flip if the window pixmap doesn't match the xwl_window parent
+     * window's, e.g. because a client redirected this window or one of its
+     * parents.
+     */
+    if (screen->GetWindowPixmap(xwl_window->window) != screen->GetWindowPixmap(present_window))
+        return FALSE;
+
+    /*
+     * We currently only allow flips of windows, that have the same
+     * dimensions as their xwl_window parent window. For the case of
+     * different sizes subsurfaces are presumably the way forward.
+     */
+    if (!RegionEqual(&xwl_window->window->winSize, &present_window->winSize))
+        return FALSE;
+
+    return TRUE;
+}
+
+/*
+ * 'window' is being reconfigured. Check to see if it is involved
+ * in flipping and clean up as necessary.
+ */
+static void
+xwl_present_check_flip_window (WindowPtr window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    present_window_priv_ptr window_priv = present_window_priv(window);
+    present_vblank_ptr      flip_pending;
+    present_vblank_ptr      flip_active;
+    present_vblank_ptr      vblank;
+    PresentFlipReason       reason;
+
+    /* If this window hasn't ever been used with Present, it can't be
+     * flipping
+     */
+    if (!xwl_present_window || !window_priv)
+        return;
+
+    flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+    flip_active = xwl_present_window->flip_active;
+
+    if (flip_pending) {
+        if (!xwl_present_check_flip(flip_pending->crtc, flip_pending->window, flip_pending->pixmap,
+                                    flip_pending->sync_flip, flip_pending->valid, 0, 0, NULL))
+            flip_pending->abort_flip = TRUE;
+    } else if (flip_active) {
+        if (!xwl_present_check_flip(flip_active->crtc, flip_active->window, flip_active->pixmap,
+                                    flip_active->sync_flip, flip_active->valid, 0, 0, NULL))
+            xwl_present_flips_stop(window);
+    }
+
+    /* Now check any queued vblanks */
+    xorg_list_for_each_entry(vblank, &window_priv->vblank, window_list) {
+        if (vblank->queued && vblank->flip &&
+                !xwl_present_check_flip(vblank->crtc, window, vblank->pixmap,
+                                        vblank->sync_flip, vblank->valid, 0, 0, &reason)) {
+            vblank->flip = FALSE;
+            vblank->reason = reason;
+        }
+    }
+}
+
+/*
+ * Clean up any pending or current flips for this window
+ */
+static void
+xwl_present_clear_window_flip(WindowPtr window)
+{
+    /* xwl_present_cleanup cleaned up everything */
+}
+
+static Bool
+xwl_present_flip(WindowPtr present_window,
+                 RRCrtcPtr crtc,
+                 uint64_t event_id,
+                 PixmapPtr pixmap,
+                 Bool sync_flip,
+                 RegionPtr damage)
+{
+    struct xwl_window           *xwl_window = xwl_window_from_window(present_window);
+    struct xwl_present_window   *xwl_present_window = xwl_present_window_priv(present_window);
+    BoxPtr                      damage_box;
+    struct wl_buffer            *buffer;
+    struct xwl_present_event    *event = xwl_present_event_from_id(event_id);
+
+    if (!xwl_window)
+        return FALSE;
+
+    buffer = xwl_glamor_pixmap_get_wl_buffer(pixmap);
+    if (!buffer) {
+        ErrorF("present: Error getting buffer\n");
+        return FALSE;
+    }
+
+    damage_box = RegionExtents(damage);
+
+    pixmap->refcnt++;
+
+    event->pixmap = pixmap;
+
+    xwl_pixmap_set_buffer_release_cb(pixmap, xwl_present_buffer_release, event);
+
+    /* We can flip directly to the main surface (full screen window without clips) */
+    wl_surface_attach(xwl_window->surface, buffer, 0, 0);
+
+    if (xorg_list_is_empty(&xwl_present_window->frame_callback_list)) {
+        xorg_list_add(&xwl_present_window->frame_callback_list,
+                      &xwl_window->frame_callback_list);
+    }
+
+    if (!xwl_window->frame_callback)
+        xwl_window_create_frame_callback(xwl_window);
+
+    xwl_surface_damage(xwl_window->xwl_screen, xwl_window->surface,
+                       damage_box->x1 - present_window->drawable.x,
+                       damage_box->y1 - present_window->drawable.y,
+                       damage_box->x2 - damage_box->x1,
+                       damage_box->y2 - damage_box->y1);
+
+    wl_surface_commit(xwl_window->surface);
+
+    if (!sync_flip) {
+        xwl_present_window->sync_callback =
+            wl_display_sync(xwl_window->xwl_screen->display);
+        wl_callback_add_listener(xwl_present_window->sync_callback,
+                                 &xwl_present_sync_listener,
+                                 &event->vblank);
+    }
+
+    wl_display_flush(xwl_window->xwl_screen->display);
+    xwl_window->present_flipped = TRUE;
+    return TRUE;
+}
+
+/*
+ * Once the required MSC has been reached, execute the pending request.
+ *
+ * For requests to actually present something, either blt contents to
+ * the window pixmap or queue a window buffer swap on the backend.
+ *
+ * For requests to just get the current MSC/UST combo, skip that part and
+ * go straight to event delivery.
+ */
+static void
+xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
+{
+    WindowPtr               window = vblank->window;
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
+    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+
+    xorg_list_del(&vblank->event_queue);
+
+    if (present_execute_wait(vblank, crtc_msc))
+        return;
+
+    if (flip_pending && vblank->flip && vblank->pixmap && vblank->window) {
+        DebugPresent(("\tr %" PRIu64 " %p (pending %p)\n",
+                      vblank->event_id, vblank, flip_pending));
+        xorg_list_append(&vblank->event_queue, &xwl_present_window->flip_queue);
+        vblank->flip_ready = TRUE;
+        return;
+    }
+
+    vblank->queued = FALSE;
+
+    if (vblank->pixmap && vblank->window) {
+        ScreenPtr screen = window->drawable.pScreen;
+
+        if (vblank->flip) {
+            RegionPtr damage;
+
+            DebugPresent(("\tf %" PRIu64 " %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
+                          vblank->event_id, vblank, crtc_msc,
+                          vblank->pixmap->drawable.id, vblank->window->drawable.id));
+
+            /* Set update region as damaged */
+            if (vblank->update) {
+                damage = RegionDuplicate(vblank->update);
+                /* Translate update region to screen space */
+                assert(vblank->x_off == 0 && vblank->y_off == 0);
+                RegionTranslate(damage, window->drawable.x, window->drawable.y);
+                RegionIntersect(damage, damage, &window->clipList);
+            } else
+                damage = RegionDuplicate(&window->clipList);
+
+            if (xwl_present_flip(vblank->window, vblank->crtc, vblank->event_id,
+                                 vblank->pixmap, vblank->sync_flip, damage)) {
+                WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(vblank->window);
+                PixmapPtr old_pixmap = screen->GetWindowPixmap(window);
+
+                /* Replace window pixmap with flip pixmap */
+#ifdef COMPOSITE
+                vblank->pixmap->screen_x = old_pixmap->screen_x;
+                vblank->pixmap->screen_y = old_pixmap->screen_y;
+#endif
+                present_set_tree_pixmap(toplvl_window, old_pixmap, vblank->pixmap);
+                vblank->pixmap->refcnt++;
+                dixDestroyPixmap(old_pixmap, old_pixmap->drawable.id);
+
+                /* Report damage */
+                DamageDamageRegion(&vblank->window->drawable, damage);
+                RegionDestroy(damage);
+
+                /* Put pending flip at the flip queue head */
+                xorg_list_add(&vblank->event_queue, &xwl_present_window->flip_queue);
+
+                /* Realign timer */
+                xwl_present_reset_timer(xwl_present_window);
+
+                return;
+            }
+
+            vblank->flip = FALSE;
+        }
+        DebugPresent(("\tc %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
+                      vblank, crtc_msc, vblank->pixmap->drawable.id, vblank->window->drawable.id));
+
+        if (flip_pending)
+            flip_pending->abort_flip = TRUE;
+        else if (xwl_present_window->flip_active)
+            xwl_present_flips_stop(window);
+
+        present_execute_copy(vblank, crtc_msc);
+        assert(!vblank->queued);
+
+        /* Clear the pixmap field, so this will fall through to present_execute_post next time */
+        dixDestroyPixmap(vblank->pixmap, vblank->pixmap->drawable.id);
+        vblank->pixmap = NULL;
+
+        if (xwl_present_queue_vblank(screen, window, vblank->crtc,
+                                     vblank->event_id, crtc_msc + 1)
+            == Success)
+            return;
+    }
+
+    present_execute_post(vblank, ust, crtc_msc);
+}
+
+static int
+xwl_present_pixmap(WindowPtr window,
+                   PixmapPtr pixmap,
+                   CARD32 serial,
+                   RegionPtr valid,
+                   RegionPtr update,
+                   int16_t x_off,
+                   int16_t y_off,
+                   RRCrtcPtr target_crtc,
+                   SyncFence *wait_fence,
+                   SyncFence *idle_fence,
+                   uint32_t options,
+                   uint64_t target_window_msc,
+                   uint64_t divisor,
+                   uint64_t remainder,
+                   present_notify_ptr notifies,
+                   int num_notifies)
+{
+    uint64_t                    ust = 0;
+    uint64_t                    target_msc;
+    uint64_t                    crtc_msc = 0;
+    int                         ret;
+    present_vblank_ptr          vblank, tmp;
+    ScreenPtr                   screen = window->drawable.pScreen;
+    present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
+    present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
+    struct xwl_present_event *event;
+
+    if (!window_priv)
+        return BadAlloc;
+
+    target_crtc = xwl_present_get_crtc(screen_priv, window);
+
+    ret = xwl_present_get_ust_msc(screen, window, &ust, &crtc_msc);
+
+    xwl_present_update_window_crtc(window_priv, target_crtc, crtc_msc);
+
+    if (ret == Success) {
+        /* Stash the current MSC away in case we need it later
+         */
+        window_priv->msc = crtc_msc;
+    }
+
+    target_msc = present_get_target_msc(target_window_msc + window_priv->msc_offset,
+                                        crtc_msc,
+                                        divisor,
+                                        remainder,
+                                        options);
+
+    /*
+     * Look for a matching presentation already on the list...
+     */
+
+    if (!update && pixmap) {
+        xorg_list_for_each_entry_safe(vblank, tmp, &window_priv->vblank, window_list) {
+
+            if (!vblank->pixmap)
+                continue;
+
+            if (!vblank->queued)
+                continue;
+
+            if (vblank->target_msc != target_msc)
+                continue;
+
+            present_vblank_scrap(vblank);
+            if (vblank->flip_ready)
+                xwl_present_re_execute(vblank);
+        }
+    }
+
+    event = calloc(1, sizeof(*event));
+    if (!event)
+        return BadAlloc;
+
+    vblank = &event->vblank;
+    if (!present_vblank_init(vblank, window, pixmap, serial, valid, update, x_off, y_off,
+                             target_crtc, wait_fence, idle_fence, options, XWL_PRESENT_CAPS,
+                             notifies, num_notifies, target_msc, crtc_msc)) {
+        present_vblank_destroy(vblank);
+        return BadAlloc;
+    }
+
+    vblank->event_id = (uintptr_t)event;
+
+    /* Xwayland presentations always complete (at least) one frame after they
+     * are executed
+     */
+    vblank->exec_msc = vblank->target_msc - 1;
+
+    vblank->queued = TRUE;
+    if (crtc_msc < vblank->exec_msc) {
+        if (xwl_present_queue_vblank(screen, window, target_crtc, vblank->event_id, vblank->exec_msc) == Success)
+            return Success;
+
+        DebugPresent(("present_queue_vblank failed\n"));
+    }
+
+    xwl_present_execute(vblank, ust, crtc_msc);
+    return Success;
+}
+
+void
+xwl_present_unrealize_window(struct xwl_present_window *xwl_present_window)
+{
+    /* The pending frame callback may never be called, so drop it and shorten
+     * the frame timer interval.
+     */
+    xorg_list_del(&xwl_present_window->frame_callback_list);
+
+    /* Make sure the timer callback doesn't get called */
+    xwl_present_window->timer_armed = 0;
+    xwl_present_reset_timer(xwl_present_window);
+}
+
+Bool
+xwl_present_init(ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    present_screen_priv_ptr screen_priv;
+
+    if (!xwl_screen->glamor || !xwl_screen->egl_backend)
+        return FALSE;
+
+    if (!present_screen_register_priv_keys())
+        return FALSE;
+
+    if (present_screen_priv(screen))
+        return TRUE;
+
+    screen_priv = present_screen_priv_init(screen);
+    if (!screen_priv)
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&xwl_present_window_private_key, PRIVATE_WINDOW, 0))
+        return FALSE;
+
+    screen_priv->query_capabilities = xwl_present_query_capabilities;
+    screen_priv->get_crtc = xwl_present_get_crtc;
+
+    screen_priv->check_flip = xwl_present_check_flip;
+    screen_priv->check_flip_window = xwl_present_check_flip_window;
+    screen_priv->clear_window_flip = xwl_present_clear_window_flip;
+
+    screen_priv->present_pixmap = xwl_present_pixmap;
+    screen_priv->queue_vblank = xwl_present_queue_vblank;
+    screen_priv->flush = xwl_present_flush;
+    screen_priv->re_execute = xwl_present_re_execute;
+
+    screen_priv->abort_vblank = xwl_present_abort_vblank;
+
+    return TRUE;
+}
diff --git a/hw/xwayland/xwayland-present.h b/hw/xwayland/xwayland-present.h
new file mode 100644
index 000000000..ab7f04a3b
--- /dev/null
+++ b/hw/xwayland/xwayland-present.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright © 2018 Roman Gilg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_PRESENT_H
+#define XWAYLAND_PRESENT_H
+
+#include <xwayland-config.h>
+
+#include <dix.h>
+#include <present_priv.h>
+
+#include "xwayland-types.h"
+
+#ifdef GLAMOR_HAS_GBM
+struct xwl_present_window {
+    WindowPtr window;
+
+    struct xorg_list frame_callback_list;
+
+    uint64_t msc;
+    uint64_t ust;
+
+    OsTimerPtr frame_timer;
+    /* Timestamp when the current timer was first armed */
+    CARD32 timer_armed;
+
+    struct wl_callback *sync_callback;
+
+    struct xorg_list wait_list;
+    struct xorg_list flip_queue;
+    struct xorg_list idle_queue;
+
+    present_vblank_ptr flip_active;
+};
+
+struct xwl_present_event {
+    present_vblank_rec vblank;
+
+    PixmapPtr pixmap;
+};
+
+void xwl_present_reset_timer(struct xwl_present_window *xwl_present_window);
+void xwl_present_frame_callback(struct xwl_present_window *xwl_present_window);
+Bool xwl_present_init(ScreenPtr screen);
+void xwl_present_cleanup(WindowPtr window);
+void xwl_present_unrealize_window(struct xwl_present_window *xwl_present_window);
+
+#endif /* GLAMOR_HAS_GBM */
+
+#endif /* XWAYLAND_PRESENT_H */
diff --git a/hw/xwayland/xwayland-screen.c b/hw/xwayland/xwayland-screen.c
new file mode 100644
index 000000000..a880406c9
--- /dev/null
+++ b/hw/xwayland/xwayland-screen.c
@@ -0,0 +1,999 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+
+#ifdef XWL_HAS_GLAMOR
+#include <glamor.h>
+#endif
+
+#include <X11/Xatom.h>
+#include <micmap.h>
+#include <misyncshm.h>
+#include <os.h>
+#include <fb.h>
+#include <dixstruct.h>
+#include <propertyst.h>
+#include <inputstr.h>
+#include <xserver_poll.h>
+
+#include "xwayland-cursor.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+#include "xwayland-input.h"
+#include "xwayland-output.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-present.h"
+#include "xwayland-shm.h"
+
+#ifdef MITSHM
+#include "shmint.h"
+#endif
+
+#include "xdg-output-unstable-v1-client-protocol.h"
+#include "viewporter-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
+#include "xwayland-shell-v1-client-protocol.h"
+
+static DevPrivateKeyRec xwl_screen_private_key;
+static DevPrivateKeyRec xwl_client_private_key;
+
+#define DEFAULT_DPI 96
+
+_X_NORETURN
+static void _X_ATTRIBUTE_PRINTF(1, 2)
+xwl_give_up(const char *f, ...)
+{
+    va_list args;
+
+    va_start(args, f);
+    VErrorFSigSafe(f, args);
+    va_end(args);
+
+    CloseWellKnownConnections();
+    OsCleanup(TRUE);
+    fflush(stderr);
+    exit(1);
+}
+
+struct xwl_client *
+xwl_client_get(ClientPtr client)
+{
+    return dixLookupPrivate(&client->devPrivates, &xwl_client_private_key);
+}
+
+struct xwl_screen *
+xwl_screen_get(ScreenPtr screen)
+{
+    return dixLookupPrivate(&screen->devPrivates, &xwl_screen_private_key);
+}
+
+Bool
+xwl_screen_has_viewport_support(struct xwl_screen *xwl_screen)
+{
+    return wl_compositor_get_version(xwl_screen->compositor) >=
+                            WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION &&
+           xwl_screen->viewporter != NULL;
+}
+
+Bool
+xwl_screen_has_resolution_change_emulation(struct xwl_screen *xwl_screen)
+{
+    /* Resolution change emulation is only supported in rootless mode and
+     * it requires viewport support.
+     */
+    return xwl_screen->rootless && xwl_screen_has_viewport_support(xwl_screen);
+}
+
+/* Return the output @ 0x0, falling back to the first output in the list */
+struct xwl_output *
+xwl_screen_get_first_output(struct xwl_screen *xwl_screen)
+{
+    struct xwl_output *xwl_output;
+
+    xorg_list_for_each_entry(xwl_output, &xwl_screen->output_list, link) {
+        if (xwl_output->x == 0 && xwl_output->y == 0)
+            return xwl_output;
+    }
+
+    if (xorg_list_is_empty(&xwl_screen->output_list))
+        return NULL;
+
+    return xorg_list_first_entry(&xwl_screen->output_list, struct xwl_output, link);
+}
+
+struct xwl_output *
+xwl_screen_get_fixed_or_first_output(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->fixed_output)
+        return xwl_screen->fixed_output;
+
+    return xwl_screen_get_first_output(xwl_screen);
+}
+
+static void
+xwl_property_callback(CallbackListPtr *pcbl, void *closure,
+                      void *calldata)
+{
+    ScreenPtr screen = closure;
+    PropertyStateRec *rec = calldata;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+
+    if (rec->win->drawable.pScreen != screen)
+        return;
+
+    xwl_window = xwl_window_get(rec->win);
+    if (!xwl_window)
+        return;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    if (rec->prop->propertyName == xwl_screen->allow_commits_prop)
+        xwl_window_update_property(xwl_window, rec);
+}
+
+static void
+xwl_root_window_finalized_callback(CallbackListPtr *pcbl,
+                                   void *closure,
+                                   void *calldata)
+{
+    ScreenPtr screen = closure;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_queued_drm_lease_device *queued_device, *next;
+
+    xorg_list_for_each_entry_safe(queued_device, next,
+                                  &xwl_screen->queued_drm_lease_devices, link) {
+        xwl_screen_add_drm_lease_device(xwl_screen, queued_device->id);
+        xorg_list_del(&queued_device->link);
+        free(queued_device);
+    }
+    DeleteCallback(&RootWindowFinalizeCallback, xwl_root_window_finalized_callback, screen);
+}
+
+Bool
+xwl_close_screen(ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_output *xwl_output, *next_xwl_output;
+    struct xwl_seat *xwl_seat, *next_xwl_seat;
+    struct xwl_wl_surface *xwl_wl_surface, *xwl_wl_surface_next;
+
+    xwl_dmabuf_feedback_destroy(&xwl_screen->default_feedback);
+
+    DeleteCallback(&PropertyStateCallback, xwl_property_callback, screen);
+
+    xorg_list_for_each_entry_safe(xwl_output, next_xwl_output,
+                                  &xwl_screen->output_list, link)
+        xwl_output_destroy(xwl_output);
+
+    if (xwl_screen->fixed_output)
+        xwl_output_destroy(xwl_screen->fixed_output);
+
+    xorg_list_for_each_entry_safe(xwl_seat, next_xwl_seat,
+                                  &xwl_screen->seat_list, link)
+        xwl_seat_destroy(xwl_seat);
+
+    xwl_screen_release_tablet_manager(xwl_screen);
+
+    struct xwl_drm_lease_device *device_data, *next;
+    xorg_list_for_each_entry_safe(device_data, next,
+                                  &xwl_screen->drm_lease_devices, link)
+        xwl_screen_destroy_drm_lease_device(xwl_screen,
+                                            device_data->drm_lease_device);
+
+    xorg_list_for_each_entry_safe(xwl_wl_surface, xwl_wl_surface_next,
+                                  &xwl_screen->pending_wl_surface_destroy, link)
+        xwl_window_surface_do_destroy(xwl_wl_surface);
+
+    RemoveNotifyFd(xwl_screen->wayland_fd);
+
+    wl_display_disconnect(xwl_screen->display);
+
+    screen->CloseScreen = xwl_screen->CloseScreen;
+    free(xwl_screen);
+
+    return screen->CloseScreen(screen);
+}
+
+static struct xwl_seat *
+xwl_screen_get_default_seat(struct xwl_screen *xwl_screen)
+{
+    if (xorg_list_is_empty(&xwl_screen->seat_list))
+        return NULL;
+
+    return container_of(xwl_screen->seat_list.prev,
+                        struct xwl_seat,
+                        link);
+}
+
+static void
+xwl_cursor_warped_to(DeviceIntPtr device,
+                     ScreenPtr screen,
+                     ClientPtr client,
+                     WindowPtr window,
+                     SpritePtr sprite,
+                     int x, int y)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_seat *xwl_seat = device->public.devicePrivate;
+    struct xwl_window *xwl_window;
+    WindowPtr focus;
+
+    if (!xwl_seat)
+        xwl_seat = xwl_screen_get_default_seat(xwl_screen);
+
+    if (!window)
+        window = XYToWindow(sprite, x, y);
+
+    xwl_window = xwl_window_from_window(window);
+    if (!xwl_window && xwl_seat->focus_window) {
+        focus = xwl_seat->focus_window->window;
+
+        /* Warps on non wl_surface backed Windows are only allowed
+         * as long as the pointer stays within the focus window.
+         */
+        if (x >= focus->drawable.x &&
+            y >= focus->drawable.y &&
+            x < focus->drawable.x + focus->drawable.width &&
+            y < focus->drawable.y + focus->drawable.height) {
+            if (!window) {
+                DebugF("Warp relative to pointer, assuming pointer focus\n");
+                xwl_window = xwl_seat->focus_window;
+            } else if (window == screen->root) {
+                DebugF("Warp on root window, assuming pointer focus\n");
+                xwl_window = xwl_seat->focus_window;
+            }
+        }
+    }
+    if (!xwl_window)
+        return;
+
+    xwl_seat_emulate_pointer_warp(xwl_seat, xwl_window, sprite, x, y);
+}
+
+static struct xwl_window *
+find_matching_input_output_window(struct xwl_screen *xwl_screen,
+                                  WindowPtr window)
+{
+    struct xwl_window *xwl_window;
+
+    xorg_list_for_each_entry(xwl_window, &xwl_screen->window_list, link_window) {
+        /* When confining happens on InputOnly windows, work out the InputOutput
+         * window that would be covered by its geometry.
+         */
+        if (window->drawable.x < xwl_window->window->drawable.x ||
+            window->drawable.x + window->drawable.width >
+            xwl_window->window->drawable.x + xwl_window->window->drawable.width ||
+            window->drawable.y < xwl_window->window->drawable.y ||
+            window->drawable.y + window->drawable.height >
+            xwl_window->window->drawable.y + xwl_window->window->drawable.height)
+            continue;
+
+        if (xwl_window->window->drawable.class == InputOnly)
+            continue;
+
+        return xwl_window;
+    }
+
+    return NULL;
+}
+
+static void
+xwl_cursor_confined_to(DeviceIntPtr device,
+                       ScreenPtr screen,
+                       WindowPtr window)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_seat *xwl_seat = device->public.devicePrivate;
+    struct xwl_window *xwl_window;
+
+    /* If running rootful with host grab requested, do not tamper with
+     * pointer confinement.
+     */
+    if (!xwl_screen->rootless && xwl_screen->host_grab && xwl_screen->has_grab)
+        return;
+
+    if (!xwl_seat)
+        xwl_seat = xwl_screen_get_default_seat(xwl_screen);
+
+    /* xwl_seat hasn't been setup yet, don't do anything just yet */
+    if (!xwl_seat)
+        return;
+
+    if (window == screen->root) {
+        xwl_seat_unconfine_pointer(xwl_seat);
+        return;
+    }
+
+    xwl_window = xwl_window_from_window(window);
+    if (!xwl_window && window->drawable.class == InputOnly) {
+        DebugF("Confine on InputOnly window, finding matching toplevel\n");
+        xwl_window = find_matching_input_output_window(xwl_screen, window);
+    }
+    if (!xwl_window)
+        return;
+
+    xwl_seat_confine_pointer(xwl_seat, xwl_window);
+}
+
+void
+xwl_screen_check_resolution_change_emulation(struct xwl_screen *xwl_screen)
+{
+    struct xwl_window *xwl_window;
+
+    xorg_list_for_each_entry(xwl_window, &xwl_screen->window_list, link_window)
+        xwl_window_check_resolution_change_emulation(xwl_window);
+}
+
+static void
+xwl_screen_post_damage(struct xwl_screen *xwl_screen)
+{
+    struct xwl_window *xwl_window, *next_xwl_window;
+    struct xorg_list commit_window_list;
+
+    xorg_list_init(&commit_window_list);
+
+    xorg_list_for_each_entry_safe(xwl_window, next_xwl_window,
+                                  &xwl_screen->damage_window_list, link_damage) {
+        /* If we're waiting on a frame callback from the server,
+         * don't attach a new buffer. */
+        if (xwl_window->frame_callback)
+            continue;
+
+        if (!xwl_window->allow_commits)
+            continue;
+
+#ifdef XWL_HAS_GLAMOR
+        if (xwl_screen->glamor && !xwl_glamor_allow_commits(xwl_window))
+            continue;
+#endif
+
+        xwl_window_post_damage(xwl_window);
+        xorg_list_del(&xwl_window->link_damage);
+        xorg_list_append(&xwl_window->link_damage, &commit_window_list);
+    }
+
+    if (xorg_list_is_empty(&commit_window_list))
+        return;
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_glamor_needs_buffer_flush(xwl_screen))
+        glamor_block_handler(xwl_screen->screen);
+#endif
+
+    xorg_list_for_each_entry_safe(xwl_window, next_xwl_window,
+                                  &commit_window_list, link_damage) {
+        wl_surface_commit(xwl_window->surface);
+        xorg_list_del(&xwl_window->link_damage);
+    }
+}
+
+static void
+xdg_wm_base_ping(void *data, struct xdg_wm_base *xdg_wm_base,
+                 uint32_t serial)
+{
+    xdg_wm_base_pong(xdg_wm_base, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
+static void
+registry_global(void *data, struct wl_registry *registry, uint32_t id,
+                const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    if (strcmp(interface, "wl_compositor") == 0) {
+        uint32_t request_version = 1;
+
+        if (version >= WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION)
+            request_version = WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION;
+
+        xwl_screen->compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, request_version);
+    }
+    else if (strcmp(interface, "wl_shm") == 0) {
+        xwl_screen->shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0) {
+        xwl_screen->xdg_wm_base =
+            wl_registry_bind(registry, id, &xdg_wm_base_interface, 1);
+        xdg_wm_base_add_listener(xwl_screen->xdg_wm_base,
+                                 &xdg_wm_base_listener,
+                                 NULL);
+    }
+    else if (strcmp(interface, "wl_output") == 0 && version >= 2) {
+        if (xwl_output_create(xwl_screen, id, (xwl_screen->fixed_output == NULL)))
+            xwl_screen->expecting_event++;
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0) {
+        /* We support xdg-output from version 1 to version 3 */
+        version = min(version, 3);
+        xwl_screen->xdg_output_manager =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface, version);
+        xwl_screen_init_xdg_output(xwl_screen);
+    }
+    else if (strcmp(interface, "wp_drm_lease_device_v1") == 0) {
+        if (xwl_screen->screen->root == NULL) {
+            struct xwl_queued_drm_lease_device *queued = malloc(sizeof(struct xwl_queued_drm_lease_device));
+            queued->id = id;
+            xorg_list_append(&queued->link, &xwl_screen->queued_drm_lease_devices);
+        } else {
+            xwl_screen_add_drm_lease_device(xwl_screen, id);
+        }
+    }
+    else if (strcmp(interface, "wp_viewporter") == 0) {
+        xwl_screen->viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
+    else if (strcmp(interface, "xwayland_shell_v1") == 0 && xwl_screen->rootless) {
+        xwl_screen->xwayland_shell =
+            wl_registry_bind(registry, id, &xwayland_shell_v1_interface, 1);
+    }
+#ifdef XWL_HAS_GLAMOR
+    else if (xwl_screen->glamor) {
+        xwl_glamor_init_wl_registry(xwl_screen, registry, id, interface,
+                                    version);
+    }
+#endif
+}
+
+static void
+global_remove(void *data, struct wl_registry *registry, uint32_t name)
+{
+    struct xwl_screen *xwl_screen = data;
+    struct xwl_output *xwl_output, *tmp_xwl_output;
+    struct xwl_drm_lease_device *lease_device, *tmp_lease_device;
+
+    xorg_list_for_each_entry_safe(xwl_output, tmp_xwl_output,
+                                  &xwl_screen->output_list, link) {
+        if (xwl_output->server_output_id == name) {
+            xwl_output_remove(xwl_output);
+            break;
+        }
+    }
+
+    xorg_list_for_each_entry_safe(lease_device, tmp_lease_device,
+                                  &xwl_screen->drm_lease_devices, link) {
+        if (lease_device->id == name) {
+            wp_drm_lease_device_v1_release(lease_device->drm_lease_device);
+            break;
+        }
+    }
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_global,
+    global_remove
+};
+
+static void
+xwl_read_events (struct xwl_screen *xwl_screen)
+{
+    int ret;
+
+    if (xwl_screen->wait_flush)
+        return;
+
+    ret = wl_display_read_events(xwl_screen->display);
+    if (ret == -1)
+        xwl_give_up("failed to read Wayland events: %s\n", strerror(errno));
+
+    xwl_screen->prepare_read = 0;
+
+    ret = wl_display_dispatch_pending(xwl_screen->display);
+    if (ret == -1)
+        xwl_give_up("failed to dispatch Wayland events: %s\n", strerror(errno));
+}
+
+static int
+xwl_display_pollout (struct xwl_screen *xwl_screen, int timeout)
+{
+    struct pollfd poll_fd;
+
+    poll_fd.fd = wl_display_get_fd(xwl_screen->display);
+    poll_fd.events = POLLOUT;
+
+    return xserver_poll(&poll_fd, 1, timeout);
+}
+
+#ifdef XWL_HAS_LIBDECOR
+static void
+xwl_dispatch_events_with_libdecor(struct xwl_screen *xwl_screen)
+{
+    int ret = 0;
+
+    assert(!xwl_screen->rootless);
+
+    ret = libdecor_dispatch(xwl_screen->libdecor_context, 0);
+    if (ret == -1)
+        xwl_give_up("failed to dispatch Wayland events with libdecor: %s\n",
+                    strerror(errno));
+}
+
+static void
+handle_libdecor_error(struct libdecor *context,
+                      enum libdecor_error error,
+                      const char *message)
+{
+    xwl_give_up("libdecor error (%d): %s\n", error, message);
+}
+
+static struct libdecor_interface libdecor_iface = {
+    .error = handle_libdecor_error,
+};
+#endif
+
+static void
+xwl_dispatch_events (struct xwl_screen *xwl_screen)
+{
+    int ret = 0;
+    int ready;
+
+    if (xwl_screen->wait_flush)
+        goto pollout;
+
+    while (xwl_screen->prepare_read == 0 &&
+           wl_display_prepare_read(xwl_screen->display) == -1) {
+        ret = wl_display_dispatch_pending(xwl_screen->display);
+        if (ret == -1)
+            xwl_give_up("failed to dispatch Wayland events: %s\n",
+                       strerror(errno));
+    }
+
+    xwl_screen->prepare_read = 1;
+
+pollout:
+    ready = xwl_display_pollout(xwl_screen, 5);
+    if (ready == -1 && errno != EINTR)
+        xwl_give_up("error polling on Xwayland fd: %s\n", strerror(errno));
+
+    if (ready > 0)
+        ret = wl_display_flush(xwl_screen->display);
+
+    if (ret == -1 && errno != EAGAIN)
+        xwl_give_up("failed to write to Xwayland fd: %s\n", strerror(errno));
+
+    xwl_screen->wait_flush = (ready == 0 || ready == -1 || ret == -1);
+}
+
+static void
+socket_handler(int fd, int ready, void *data)
+{
+    struct xwl_screen *xwl_screen = data;
+
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_screen->libdecor_context) {
+        xwl_dispatch_events_with_libdecor(xwl_screen);
+        return;
+    }
+#endif
+    xwl_read_events (xwl_screen);
+}
+
+static void
+wakeup_handler(void *data, int err)
+{
+}
+
+static void
+block_handler(void *data, void *timeout)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    xwl_screen_post_damage(xwl_screen);
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_screen->libdecor_context) {
+        xwl_dispatch_events_with_libdecor(xwl_screen);
+        return;
+    }
+#endif
+    xwl_dispatch_events (xwl_screen);
+}
+
+void
+xwl_sync_events (struct xwl_screen *xwl_screen)
+{
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_screen->libdecor_context) {
+        xwl_dispatch_events_with_libdecor(xwl_screen);
+        return;
+    }
+#endif
+    xwl_dispatch_events (xwl_screen);
+    xwl_read_events (xwl_screen);
+}
+
+void xwl_surface_damage(struct xwl_screen *xwl_screen,
+                        struct wl_surface *surface,
+                        int32_t x, int32_t y, int32_t width, int32_t height)
+{
+    if (wl_surface_get_version(surface) >= WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION)
+        wl_surface_damage_buffer(surface, x, y, width, height);
+    else
+        wl_surface_damage(surface, x, y, width, height);
+}
+
+void
+xwl_screen_roundtrip(struct xwl_screen *xwl_screen)
+{
+    int ret;
+
+    ret = wl_display_roundtrip(xwl_screen->display);
+    while (ret >= 0 && xwl_screen->expecting_event)
+        ret = wl_display_roundtrip(xwl_screen->display);
+
+    if (ret < 0)
+        xwl_give_up("could not connect to wayland server\n");
+}
+
+static int
+xwl_server_grab(ClientPtr client)
+{
+    struct xwl_screen *xwl_screen;
+
+    /* Allow GrabServer for the X11 window manager.
+     * Xwayland only has 1 screen (no Zaphod for Xwayland) so we check
+     * for the first and only screen here.
+     */
+    xwl_screen = xwl_screen_get(screenInfo.screens[0]);
+    if (xwl_screen->wm_client_id == client->index)
+        return xwl_screen->GrabServer(client);
+
+    /* For all other clients, just pretend it works for compatibility,
+       but do nothing */
+    return Success;
+}
+
+static int
+xwl_server_ungrab(ClientPtr client)
+{
+    struct xwl_screen *xwl_screen;
+
+    /* Same as above, allow UngrabServer for the X11 window manager only */
+    xwl_screen = xwl_screen_get(screenInfo.screens[0]);
+    if (xwl_screen->wm_client_id == client->index)
+        return xwl_screen->UngrabServer(client);
+
+    /* For all other clients, just pretend it works for compatibility,
+       but do nothing */
+    return Success;
+}
+
+static void
+xwl_screen_setup_custom_vector(struct xwl_screen *xwl_screen)
+{
+    /* Rootfull Xwayland does not need a custom ProcVector (yet?) */
+    if (!xwl_screen->rootless)
+        return;
+
+    xwl_screen->GrabServer = ProcVector[X_GrabServer];
+    xwl_screen->UngrabServer = ProcVector[X_UngrabServer];
+
+    ProcVector[X_GrabServer] = xwl_server_grab;
+    ProcVector[X_UngrabServer] = xwl_server_ungrab;
+}
+
+int
+xwl_screen_get_next_output_serial(struct xwl_screen *xwl_screen)
+{
+    return xwl_screen->output_name_serial++;
+}
+
+Bool
+xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
+{
+    static const char allow_commits[] = "_XWAYLAND_ALLOW_COMMITS";
+    struct xwl_screen *xwl_screen;
+    Pixel red_mask, blue_mask, green_mask;
+    int ret, bpc, green_bpc, i;
+    unsigned int xwl_width = 0;
+    unsigned int xwl_height = 0;
+#ifdef XWL_HAS_GLAMOR
+    Bool use_eglstreams = FALSE;
+#endif
+    Bool use_fixed_size = FALSE;
+
+    if (!dixRegisterPrivateKey(&xwl_screen_private_key, PRIVATE_SCREEN, 0))
+        return FALSE;
+    if (!xwl_pixmap_init())
+        return FALSE;
+    if (!xwl_window_init())
+        return FALSE;
+    /* There are no easy to use new / delete client hooks, we could use a
+     * ClientStateCallback, but it is easier to let the dix code manage the
+     * memory for us. This will zero fill the initial xwl_client data.
+     */
+    if (!dixRegisterPrivateKey(&xwl_client_private_key, PRIVATE_CLIENT,
+                               sizeof(struct xwl_client)))
+        return FALSE;
+
+    xwl_screen = calloc(1, sizeof *xwl_screen);
+    if (xwl_screen == NULL)
+        return FALSE;
+
+    dixSetPrivate(&pScreen->devPrivates, &xwl_screen_private_key, xwl_screen);
+    xwl_screen->screen = pScreen;
+
+#ifdef XWL_HAS_GLAMOR
+    xwl_screen->glamor = 1;
+#endif
+
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-rootless") == 0) {
+            xwl_screen->rootless = 1;
+
+            /* Disable the XSS extension on Xwayland rootless.
+             *
+             * Xwayland is just a Wayland client, no X11 screensaver
+             * should be expected to work reliably on Xwayland rootless.
+             */
+#ifdef SCREENSAVER
+            noScreenSaverExtension = TRUE;
+#endif
+            ScreenSaverTime = 0;
+            ScreenSaverInterval = 0;
+            defaultScreenSaverTime = 0;
+            defaultScreenSaverInterval = 0;
+        }
+        else if (strcmp(argv[i], "-shm") == 0) {
+            xwl_screen->glamor = 0;
+        }
+        else if (strcmp(argv[i], "-eglstream") == 0) {
+#ifdef XWL_HAS_EGLSTREAM
+            use_eglstreams = TRUE;
+#else
+            ErrorF("xwayland glamor: this build does not have EGLStream support\n");
+#endif
+        }
+        else if (strcmp(argv[i], "-force-xrandr-emulation") == 0) {
+            xwl_screen->force_xrandr_emulation = 1;
+        }
+        else if (strcmp(argv[i], "-geometry") == 0) {
+            sscanf(argv[i + 1], "%ix%i", &xwl_width, &xwl_height);
+            if (xwl_width == 0 || xwl_height == 0) {
+                ErrorF("invalid argument for -geometry %s\n", argv[i + 1]);
+                return FALSE;
+            }
+            use_fixed_size = 1;
+        }
+        else if (strcmp(argv[i], "-fullscreen") == 0) {
+            xwl_screen->fullscreen = 1;
+        }
+        else if (strcmp(argv[i], "-host-grab") == 0) {
+            xwl_screen->host_grab = 1;
+            xwl_screen->has_grab = 1;
+        }
+        else if (strcmp(argv[i], "-decorate") == 0) {
+#ifdef XWL_HAS_LIBDECOR
+            xwl_screen->decorate = 1;
+#else
+            ErrorF("This build does not have libdecor support\n");
+#endif
+        }
+    }
+
+    if (use_fixed_size) {
+        if (xwl_screen->rootless) {
+            ErrorF("error, cannot set a geometry when running rootless\n");
+            return FALSE;
+        } else {
+            xwl_screen->width = xwl_width;
+            xwl_screen->height = xwl_height;
+        }
+    }
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->glamor)
+        xwl_glamor_init_backends(xwl_screen, use_eglstreams);
+#endif
+
+    /* In rootless mode, we don't have any screen storage, and the only
+     * rendering should be to redirected mode. */
+    if (xwl_screen->rootless)
+        xwl_screen->root_clip_mode = ROOT_CLIP_INPUT_ONLY;
+    else
+        xwl_screen->root_clip_mode = ROOT_CLIP_FULL;
+
+    xorg_list_init(&xwl_screen->output_list);
+    xorg_list_init(&xwl_screen->seat_list);
+    xorg_list_init(&xwl_screen->damage_window_list);
+    xorg_list_init(&xwl_screen->window_list);
+    xorg_list_init(&xwl_screen->drm_lease_devices);
+    xorg_list_init(&xwl_screen->queued_drm_lease_devices);
+    xorg_list_init(&xwl_screen->drm_leases);
+    xorg_list_init(&xwl_screen->pending_wl_surface_destroy);
+    xwl_screen->depth = 24;
+
+    if (!monitorResolution)
+        monitorResolution = DEFAULT_DPI;
+
+    xwl_screen->display = wl_display_connect(NULL);
+    if (xwl_screen->display == NULL) {
+        ErrorF("could not connect to wayland server\n");
+        return FALSE;
+    }
+
+    if (use_fixed_size) {
+        if (!xwl_screen_init_randr_fixed(xwl_screen))
+            return FALSE;
+    } else {
+        if (!xwl_screen_init_output(xwl_screen))
+            return FALSE;
+    }
+
+    xwl_screen->expecting_event = 0;
+    xwl_screen->registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->registry,
+                             &registry_listener, xwl_screen);
+    xwl_screen_roundtrip(xwl_screen);
+
+
+    if (xwl_screen->fullscreen && xwl_screen->rootless) {
+        ErrorF("error, cannot set fullscreen when running rootless\n");
+        return FALSE;
+    }
+
+    if (xwl_screen->fullscreen && xwl_screen->decorate) {
+        ErrorF("error, cannot use the decorate option when running fullscreen\n");
+        return FALSE;
+    }
+
+    if (xwl_screen->fullscreen && !xwl_screen_has_viewport_support(xwl_screen)) {
+        ErrorF("missing viewport support in the compositor, ignoring fullscreen\n");
+        xwl_screen->fullscreen = FALSE;
+    }
+
+    if (xwl_screen->host_grab && xwl_screen->rootless) {
+        ErrorF("error, cannot use host grab when running rootless\n");
+        return FALSE;
+    }
+
+    if (!xwl_screen->rootless && !xwl_screen->xdg_wm_base) {
+        ErrorF("missing XDG-WM-Base protocol\n");
+        return FALSE;
+    }
+
+    bpc = xwl_screen->depth / 3;
+    green_bpc = xwl_screen->depth - 2 * bpc;
+    blue_mask = (1 << bpc) - 1;
+    green_mask = ((1 << green_bpc) - 1) << bpc;
+    red_mask = blue_mask << (green_bpc + bpc);
+
+    miSetVisualTypesAndMasks(xwl_screen->depth,
+                             ((1 << TrueColor) | (1 << DirectColor)),
+                             green_bpc, TrueColor,
+                             red_mask, green_mask, blue_mask);
+
+    miSetPixmapDepths();
+
+    ret = fbScreenInit(pScreen, NULL,
+                       xwl_screen->width, xwl_screen->height,
+                       monitorResolution, monitorResolution, 0,
+                       BitsPerPixel(xwl_screen->depth));
+    if (!ret)
+        return FALSE;
+
+    fbPictureInit(pScreen, 0, 0);
+
+#ifdef MITSHM
+    ShmRegisterFbFuncs(pScreen);
+#endif
+
+#ifdef HAVE_XSHMFENCE
+    if (!miSyncShmScreenInit(pScreen))
+        return FALSE;
+#endif
+
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_screen->decorate && !xwl_screen->rootless) {
+        xwl_screen->libdecor_context = libdecor_new(xwl_screen->display, &libdecor_iface);
+        xwl_screen->wayland_fd = libdecor_get_fd(xwl_screen->libdecor_context);
+    }
+    else
+#endif
+    {
+        xwl_screen->wayland_fd = wl_display_get_fd(xwl_screen->display);
+    }
+    SetNotifyFd(xwl_screen->wayland_fd, socket_handler, X_NOTIFY_READ, xwl_screen);
+    RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, xwl_screen);
+
+    pScreen->blackPixel = 0;
+    pScreen->whitePixel = 1;
+
+    ret = fbCreateDefColormap(pScreen);
+
+    if (!xwl_screen_init_cursor(xwl_screen))
+        return FALSE;
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->glamor) {
+        xwl_glamor_select_backend(xwl_screen, use_eglstreams);
+
+        if (xwl_screen->egl_backend == NULL || !xwl_glamor_init(xwl_screen)) {
+           ErrorF("Failed to initialize glamor, falling back to sw\n");
+           xwl_screen->glamor = 0;
+        }
+    }
+
+    if (xwl_screen->glamor && xwl_screen->rootless)
+        xwl_screen->present = xwl_present_init(pScreen);
+#endif
+
+    if (!xwl_screen->glamor) {
+        xwl_screen->CreateScreenResources = pScreen->CreateScreenResources;
+        pScreen->CreateScreenResources = xwl_shm_create_screen_resources;
+        pScreen->CreatePixmap = xwl_shm_create_pixmap;
+        pScreen->DestroyPixmap = xwl_shm_destroy_pixmap;
+    }
+
+    xwl_screen->RealizeWindow = pScreen->RealizeWindow;
+    pScreen->RealizeWindow = xwl_realize_window;
+
+    xwl_screen->UnrealizeWindow = pScreen->UnrealizeWindow;
+    pScreen->UnrealizeWindow = xwl_unrealize_window;
+
+    xwl_screen->DestroyWindow = pScreen->DestroyWindow;
+    pScreen->DestroyWindow = xwl_destroy_window;
+
+    xwl_screen->CloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = xwl_close_screen;
+
+    xwl_screen->ChangeWindowAttributes = pScreen->ChangeWindowAttributes;
+    pScreen->ChangeWindowAttributes = xwl_change_window_attributes;
+
+    xwl_screen->ResizeWindow = pScreen->ResizeWindow;
+    pScreen->ResizeWindow = xwl_resize_window;
+
+    xwl_screen->MoveWindow = pScreen->MoveWindow;
+    pScreen->MoveWindow = xwl_move_window;
+
+    xwl_screen->SetWindowPixmap = pScreen->SetWindowPixmap;
+    pScreen->SetWindowPixmap = xwl_window_set_window_pixmap;
+
+    pScreen->CursorWarpedTo = xwl_cursor_warped_to;
+    pScreen->CursorConfinedTo = xwl_cursor_confined_to;
+
+    xwl_screen->allow_commits_prop = MakeAtom(allow_commits,
+                                              strlen(allow_commits),
+                                              TRUE);
+    if (xwl_screen->allow_commits_prop == BAD_RESOURCE)
+        return FALSE;
+
+    AddCallback(&PropertyStateCallback, xwl_property_callback, pScreen);
+    AddCallback(&RootWindowFinalizeCallback, xwl_root_window_finalized_callback, pScreen);
+
+    xwl_screen_setup_custom_vector(xwl_screen);
+
+    xwl_screen_roundtrip(xwl_screen);
+
+    return ret;
+}
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
new file mode 100644
index 000000000..fadd0526e
--- /dev/null
+++ b/hw/xwayland/xwayland-screen.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_SCREEN_H
+#define XWAYLAND_SCREEN_H
+
+#include <xwayland-config.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <X11/X.h>
+#include <dix.h>
+
+#include "xwayland-types.h"
+#include "xwayland-window.h"
+#include "xwayland-output.h"
+#include "xwayland-glamor.h"
+#include "xwayland-drm-lease.h"
+
+#ifdef XWL_HAS_LIBDECOR
+#include <libdecor.h>
+#endif
+
+struct xwl_format {
+    uint32_t format;
+    int num_modifiers;
+    uint64_t *modifiers;
+};
+
+struct xwl_screen {
+    int width;
+    int height;
+    int depth;
+    int output_name_serial;
+    ScreenPtr screen;
+    int wm_client_id;
+    int expecting_event;
+    enum RootClipMode root_clip_mode;
+
+    int rootless;
+    int glamor;
+    int present;
+    int force_xrandr_emulation;
+    int fullscreen;
+    int host_grab;
+    int has_grab;
+    int decorate;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    CloseScreenProcPtr CloseScreen;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    XYToWindowProcPtr XYToWindow;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    ResizeWindowProcPtr ResizeWindow;
+    MoveWindowProcPtr MoveWindow;
+
+    int (*GrabServer) (ClientPtr client);
+    int (*UngrabServer) (ClientPtr client);
+
+    struct xorg_list output_list;
+    struct xorg_list seat_list;
+    struct xorg_list damage_window_list;
+    struct xorg_list window_list;
+
+    int wayland_fd;
+    struct wl_display *display;
+    struct wl_registry *registry;
+    struct wl_registry *input_registry;
+    struct wl_compositor *compositor;
+    struct zwp_tablet_manager_v2 *tablet_manager;
+    struct wl_shm *shm;
+    struct xdg_wm_base *xdg_wm_base;
+    struct zwp_relative_pointer_manager_v1 *relative_pointer_manager;
+    struct zwp_pointer_constraints_v1 *pointer_constraints;
+    struct zwp_pointer_gestures_v1 *pointer_gestures;
+    struct zwp_xwayland_keyboard_grab_manager_v1 *wp_grab;
+    struct zwp_keyboard_shortcuts_inhibit_manager_v1 *shortcuts_inhibit_manager;
+    struct zwp_keyboard_shortcuts_inhibitor_v1 *shortcuts_inhibit;
+    struct zwp_linux_dmabuf_v1 *dmabuf;
+    int dmabuf_protocol_version;
+    struct xwl_dmabuf_feedback default_feedback;
+    struct zxdg_output_manager_v1 *xdg_output_manager;
+    struct wp_viewporter *viewporter;
+    struct xwayland_shell_v1 *xwayland_shell;
+    struct xorg_list drm_lease_devices;
+    struct xorg_list queued_drm_lease_devices;
+    struct xorg_list drm_leases;
+    struct xwl_output *fixed_output;
+    struct xorg_list pending_wl_surface_destroy;
+    uint64_t surface_association_serial;
+    uint32_t serial;
+
+#define XWL_FORMAT_ARGB8888 (1 << 0)
+#define XWL_FORMAT_XRGB8888 (1 << 1)
+#define XWL_FORMAT_RGB565   (1 << 2)
+
+    int prepare_read;
+    int wait_flush;
+
+    uint32_t num_formats;
+    struct xwl_format *formats;
+    void *egl_display, *egl_context;
+
+    struct xwl_egl_backend gbm_backend;
+    struct xwl_egl_backend eglstream_backend;
+    /* pointer to the current backend for creating pixmaps on wayland */
+    struct xwl_egl_backend *egl_backend;
+
+    struct glamor_context *glamor_ctx;
+
+    Atom allow_commits_prop;
+
+    /* The preferred GLVND vendor. If NULL, "mesa" is assumed. */
+    const char *glvnd_vendor;
+#ifdef XWL_HAS_LIBDECOR
+    int libdecor_fd;
+    struct libdecor *libdecor_context;
+#endif
+};
+
+/* Apps which use randr/vidmode to change the mode when going fullscreen,
+ * usually change the mode of only a single monitor, so this should be plenty.
+ */
+#define XWL_CLIENT_MAX_EMULATED_MODES 16
+
+struct xwl_client {
+    struct xwl_emulated_mode emulated_modes[XWL_CLIENT_MAX_EMULATED_MODES];
+};
+
+struct xwl_client *xwl_client_get(ClientPtr client);
+struct xwl_screen *xwl_screen_get(ScreenPtr screen);
+Bool xwl_screen_has_viewport_support(struct xwl_screen *xwl_screen);
+Bool xwl_screen_has_resolution_change_emulation(struct xwl_screen *xwl_screen);
+void xwl_screen_check_resolution_change_emulation(struct xwl_screen *xwl_screen);
+struct xwl_output *xwl_screen_get_first_output(struct xwl_screen *xwl_screen);
+struct xwl_output *xwl_screen_get_fixed_or_first_output(struct xwl_screen *xwl_screen);
+Bool xwl_close_screen(ScreenPtr screen);
+Bool xwl_screen_init(ScreenPtr pScreen, int argc, char **argv);
+void xwl_sync_events (struct xwl_screen *xwl_screen);
+void xwl_screen_roundtrip (struct xwl_screen *xwl_screen);
+void xwl_surface_damage(struct xwl_screen *xwl_screen,
+                        struct wl_surface *surface,
+                        int32_t x, int32_t y, int32_t width, int32_t height);
+int xwl_screen_get_next_output_serial(struct xwl_screen * xwl_screen);
+
+#endif /* XWAYLAND_SCREEN_H */
diff --git a/hw/xwayland/xwayland-shm.c b/hw/xwayland/xwayland-shm.c
new file mode 100644
index 000000000..ff128316d
--- /dev/null
+++ b/hw/xwayland/xwayland-shm.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#include "os.h"
+
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "fb.h"
+#include "pixmapstr.h"
+
+#include "xwayland-pixmap.h"
+#include "xwayland-screen.h"
+#include "xwayland-shm.h"
+
+struct xwl_pixmap {
+    struct wl_buffer *buffer;
+    void *data;
+    size_t size;
+};
+
+#ifndef HAVE_MKOSTEMP
+static int
+set_cloexec_or_close(int fd)
+{
+    long flags;
+
+    if (fd == -1)
+        return -1;
+
+    flags = fcntl(fd, F_GETFD);
+    if (flags == -1)
+        goto err;
+
+    if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+        goto err;
+
+    return fd;
+
+ err:
+    close(fd);
+    return -1;
+}
+#endif
+
+static int
+create_tmpfile_cloexec(char *tmpname)
+{
+    int fd;
+
+#ifdef HAVE_MKOSTEMP
+    fd = mkostemp(tmpname, O_CLOEXEC);
+    if (fd >= 0)
+        unlink(tmpname);
+#else
+    fd = mkstemp(tmpname);
+    if (fd >= 0) {
+        fd = set_cloexec_or_close(fd);
+        unlink(tmpname);
+    }
+#endif
+
+    return os_move_fd(fd);
+}
+
+/*
+ * Create a new, unique, anonymous file of the given size, and
+ * return the file descriptor for it. The file descriptor is set
+ * CLOEXEC. The file is immediately suitable for mmap()'ing
+ * the given size at offset zero.
+ *
+ * The file should not have a permanent backing store like a disk,
+ * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
+ *
+ * The file name is deleted from the file system.
+ *
+ * The file is suitable for buffer sharing between processes by
+ * transmitting the file descriptor over Unix sockets using the
+ * SCM_RIGHTS methods.
+ *
+ * If the C library implements posix_fallocate(), it is used to
+ * guarantee that disk space is available for the file at the
+ * given size. If disk space is insufficient, errno is set to ENOSPC.
+ * If posix_fallocate() is not supported, program may receive
+ * SIGBUS on accessing mmap()'ed file contents instead.
+ *
+ * If the C library implements memfd_create(), it is used to create the
+ * file purely in memory, without any backing file name on the file
+ * system, and then sealing off the possibility of shrinking it.  This
+ * can then be checked before accessing mmap()'ed file contents, to
+ * make sure SIGBUS can't happen.  It also avoids requiring
+ * XDG_RUNTIME_DIR.
+ */
+static int
+os_create_anonymous_file(off_t size)
+{
+    static const char template[] = "/xwayland-shared-XXXXXX";
+    const char *path;
+    char *name;
+    int fd;
+    int ret;
+
+#ifdef HAVE_MEMFD_CREATE
+    fd = memfd_create("xwayland-shared", MFD_CLOEXEC | MFD_ALLOW_SEALING);
+    if (fd >= 0) {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK);
+    } else
+#endif
+    {
+        path = getenv("XDG_RUNTIME_DIR");
+        if (!path) {
+            errno = ENOENT;
+            return -1;
+        }
+
+        name = malloc(strlen(path) + sizeof(template));
+        if (!name)
+            return -1;
+
+        strcpy(name, path);
+        strcat(name, template);
+
+        fd = create_tmpfile_cloexec(name);
+
+        free(name);
+
+        if (fd < 0)
+            return -1;
+    }
+
+#ifdef HAVE_POSIX_FALLOCATE
+    /*
+     * posix_fallocate does an explicit rollback if it gets EINTR.
+     * Temporarily block signals to allow the call to succeed on
+     * slow systems where the smart scheduler's SIGALRM prevents
+     * large allocation attempts from ever succeeding.
+     */
+    OsBlockSignals();
+    do {
+        ret = posix_fallocate(fd, 0, size);
+    } while (ret == EINTR);
+    OsReleaseSignals();
+
+    if (ret != 0) {
+        close(fd);
+        errno = ret;
+        return -1;
+    }
+#else
+    do {
+        ret = ftruncate(fd, size);
+    } while (ret == -1 && errno == EINTR);
+
+    if (ret < 0) {
+        close(fd);
+        return -1;
+    }
+#endif
+
+    return fd;
+}
+
+static uint32_t
+shm_format_for_depth(int depth)
+{
+    switch (depth) {
+    case 32:
+        return WL_SHM_FORMAT_ARGB8888;
+    case 24:
+    default:
+        return WL_SHM_FORMAT_XRGB8888;
+#ifdef WL_SHM_FORMAT_RGB565
+    case 16:
+        /* XXX: Check run-time protocol version too */
+        return WL_SHM_FORMAT_RGB565;
+#endif
+    }
+}
+
+static const struct wl_buffer_listener xwl_shm_buffer_listener = {
+    xwl_pixmap_buffer_release_cb,
+};
+
+PixmapPtr
+xwl_shm_create_pixmap(ScreenPtr screen,
+                      int width, int height, int depth, unsigned int hint)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_pixmap *xwl_pixmap;
+    struct wl_shm_pool *pool;
+    PixmapPtr pixmap;
+    size_t size, stride;
+    uint32_t format;
+    int fd;
+
+    if (hint == CREATE_PIXMAP_USAGE_GLYPH_PICTURE ||
+        (!xwl_screen->rootless && hint != CREATE_PIXMAP_USAGE_BACKING_PIXMAP) ||
+        (width == 0 && height == 0) || depth < 15)
+        return fbCreatePixmap(screen, width, height, depth, hint);
+
+    stride = PixmapBytePad(width, depth);
+    size = stride * height;
+    /* Size in the protocol is an integer, make sure we don't exceed
+     * INT32_MAX or else the Wayland compositor will raise an error and
+     * kill the Wayland connection!
+     */
+    if (size > INT32_MAX)
+        return NULL;
+
+    pixmap = fbCreatePixmap(screen, 0, 0, depth, hint);
+    if (!pixmap)
+        return NULL;
+
+    xwl_pixmap = calloc(1, sizeof(*xwl_pixmap));
+    if (xwl_pixmap == NULL)
+        goto err_destroy_pixmap;
+
+    xwl_pixmap->buffer = NULL;
+    xwl_pixmap->size = size;
+    fd = os_create_anonymous_file(size);
+    if (fd < 0)
+        goto err_free_xwl_pixmap;
+
+    xwl_pixmap->data = mmap(NULL, size, PROT_READ | PROT_WRITE,
+                                  MAP_SHARED, fd, 0);
+    if (xwl_pixmap->data == MAP_FAILED)
+        goto err_close_fd;
+
+    if (!(*screen->ModifyPixmapHeader) (pixmap, width, height, depth,
+                                        BitsPerPixel(depth),
+                                        stride, xwl_pixmap->data))
+        goto err_munmap;
+
+    format = shm_format_for_depth(pixmap->drawable.depth);
+    pool = wl_shm_create_pool(xwl_screen->shm, fd, xwl_pixmap->size);
+    xwl_pixmap->buffer = wl_shm_pool_create_buffer(pool, 0,
+                                                   pixmap->drawable.width,
+                                                   pixmap->drawable.height,
+                                                   pixmap->devKind, format);
+    wl_shm_pool_destroy(pool);
+    close(fd);
+
+    wl_buffer_add_listener(xwl_pixmap->buffer,
+                           &xwl_shm_buffer_listener, pixmap);
+
+    xwl_pixmap_set_private(pixmap, xwl_pixmap);
+
+    return pixmap;
+
+ err_munmap:
+    munmap(xwl_pixmap->data, size);
+ err_close_fd:
+    close(fd);
+ err_free_xwl_pixmap:
+    free(xwl_pixmap);
+ err_destroy_pixmap:
+    fbDestroyPixmap(pixmap);
+
+    return NULL;
+}
+
+Bool
+xwl_shm_destroy_pixmap(PixmapPtr pixmap)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+
+    if (xwl_pixmap && pixmap->refcnt == 1) {
+        xwl_pixmap_del_buffer_release_cb(pixmap);
+        if (xwl_pixmap->buffer)
+            wl_buffer_destroy(xwl_pixmap->buffer);
+        munmap(xwl_pixmap->data, xwl_pixmap->size);
+        free(xwl_pixmap);
+    }
+
+    return fbDestroyPixmap(pixmap);
+}
+
+struct wl_buffer *
+xwl_shm_pixmap_get_wl_buffer(PixmapPtr pixmap)
+{
+    return xwl_pixmap_get(pixmap)->buffer;
+}
+
+Bool
+xwl_shm_create_screen_resources(ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    int ret;
+
+    screen->CreateScreenResources = xwl_screen->CreateScreenResources;
+    ret = (*screen->CreateScreenResources) (screen);
+    xwl_screen->CreateScreenResources = screen->CreateScreenResources;
+    screen->CreateScreenResources = xwl_shm_create_screen_resources;
+
+    if (!ret)
+        return ret;
+
+    if (xwl_screen->rootless)
+        screen->devPrivate =
+            fbCreatePixmap(screen, 0, 0, screen->rootDepth, 0);
+    else
+        screen->devPrivate =
+            xwl_shm_create_pixmap(screen, screen->width, screen->height,
+                                  screen->rootDepth,
+                                  CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+
+    SetRootClip(screen, xwl_screen->root_clip_mode);
+
+    return screen->devPrivate != NULL;
+}
diff --git a/hw/xwayland/xwayland-shm.h b/hw/xwayland/xwayland-shm.h
new file mode 100644
index 000000000..3c94000b6
--- /dev/null
+++ b/hw/xwayland/xwayland-shm.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ * Copyright © 2012 Collabora, Ltd.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_SHM_H
+#define XWAYLAND_SHM_H
+
+#include <xwayland-config.h>
+
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+
+Bool xwl_shm_create_screen_resources(ScreenPtr screen);
+PixmapPtr xwl_shm_create_pixmap(ScreenPtr screen, int width, int height,
+                                int depth, unsigned int hint);
+Bool xwl_shm_destroy_pixmap(PixmapPtr pixmap);
+struct wl_buffer *xwl_shm_pixmap_get_wl_buffer(PixmapPtr pixmap);
+
+#endif /* XWAYLAND_SHM_H */
diff --git a/hw/xwayland/xwayland-types.h b/hw/xwayland/xwayland-types.h
new file mode 100644
index 000000000..e70e56320
--- /dev/null
+++ b/hw/xwayland/xwayland-types.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_TYPES_H
+#define XWAYLAND_TYPES_H
+
+struct xwl_pixmap;
+struct xwl_window;
+struct xwl_screen;
+struct xwl_egl_backend;
+struct xwl_drm_lease;
+
+#endif /* XWAYLAND_TYPES_H */
diff --git a/hw/xwayland/xwayland-vidmode.c b/hw/xwayland/xwayland-vidmode.c
new file mode 100644
index 000000000..eed60256e
--- /dev/null
+++ b/hw/xwayland/xwayland-vidmode.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <X11/X.h>
+#include "misc.h"
+#include "os.h"
+#include "extinit.h"
+
+#ifdef XF86VIDMODE
+
+#include "randrstr.h"
+#include "vidmodestr.h"
+
+#include "xwayland-screen.h"
+#include "xwayland-vidmode.h"
+
+static DevPrivateKeyRec xwlVidModePrivateKeyRec;
+#define xwlVidModePrivateKey (&xwlVidModePrivateKeyRec)
+
+/* Taken from xrandr, h sync frequency in KHz */
+static double
+mode_hsync(const xRRModeInfo *mode_info)
+{
+    double rate;
+
+    if (mode_info->hTotal)
+        rate = (double) mode_info->dotClock / (double) mode_info->hTotal;
+    else
+        rate = 0.0;
+
+    return rate / 1000.0;
+}
+
+/* Taken from xrandr, v refresh frequency in Hz */
+static double
+mode_refresh(const xRRModeInfo *mode_info)
+{
+    double rate;
+    double vTotal = mode_info->vTotal;
+
+    if (mode_info->modeFlags & RR_DoubleScan)
+	vTotal *= 2.0;
+
+    if (mode_info->modeFlags & RR_Interlace)
+	vTotal /= 2.0;
+
+    if (mode_info->hTotal > 0.0 && vTotal > 0.0)
+	rate = ((double) mode_info->dotClock /
+		((double) mode_info->hTotal * (double) vTotal));
+    else
+        rate = 0.0;
+
+    return rate;
+}
+
+static void
+xwlRRModeToDisplayMode(RRModePtr rrmode, DisplayModePtr mode)
+{
+    const xRRModeInfo *mode_info = &rrmode->mode;
+
+    mode->next = mode;
+    mode->prev = mode;
+    mode->name = "";
+    mode->VScan = 1;
+    mode->Private = NULL;
+    mode->HDisplay = mode_info->width;
+    mode->HSyncStart = mode_info->hSyncStart;
+    mode->HSyncEnd = mode_info->hSyncEnd;
+    mode->HTotal = mode_info->hTotal;
+    mode->HSkew = mode_info->hSkew;
+    mode->VDisplay = mode_info->height;
+    mode->VSyncStart = mode_info->vSyncStart;
+    mode->VSyncEnd = mode_info->vSyncEnd;
+    mode->VTotal = mode_info->vTotal;
+    mode->Flags = mode_info->modeFlags;
+    mode->Clock = mode_info->dotClock / 1000.0;
+    mode->VRefresh = mode_refresh(mode_info); /* Or RRVerticalRefresh() */
+    mode->HSync = mode_hsync(mode_info);
+}
+
+static RRModePtr
+xwlVidModeGetRRMode(ScreenPtr pScreen, int32_t width, int32_t height)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (!xwl_output)
+        return NULL;
+
+    return xwl_output_find_mode(xwl_output, width, height);
+}
+
+static RRModePtr
+xwlVidModeGetCurrentRRMode(ScreenPtr pScreen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_emulated_mode *emulated_mode;
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (!xwl_output)
+        return NULL;
+
+    emulated_mode =
+        xwl_output_get_emulated_mode_for_client(xwl_output, GetCurrentClient());
+
+    if (emulated_mode) {
+        return xwl_output_find_mode(xwl_output,
+                                    emulated_mode->width,
+                                    emulated_mode->height);
+    } else {
+        return xwl_output_find_mode(xwl_output, -1, -1);
+    }
+}
+
+static Bool
+xwlVidModeGetCurrentModeline(ScreenPtr pScreen, DisplayModePtr *mode, int *dotClock)
+{
+    DisplayModePtr pMod;
+    RRModePtr rrmode;
+
+    pMod = dixLookupPrivate(&pScreen->devPrivates, xwlVidModePrivateKey);
+    if (pMod == NULL)
+        return FALSE;
+
+    rrmode = xwlVidModeGetCurrentRRMode(pScreen);
+    if (rrmode == NULL)
+        return FALSE;
+
+    xwlRRModeToDisplayMode(rrmode, pMod);
+
+    *mode = pMod;
+    if (dotClock != NULL)
+        *dotClock = pMod->Clock;
+
+    return TRUE;
+}
+
+static vidMonitorValue
+xwlVidModeGetMonitorValue(ScreenPtr pScreen, int valtyp, int indx)
+{
+    vidMonitorValue ret = { NULL, };
+    RRModePtr rrmode;
+
+    rrmode = xwlVidModeGetCurrentRRMode(pScreen);
+    if (rrmode == NULL)
+        return ret;
+
+    switch (valtyp) {
+    case VIDMODE_MON_VENDOR:
+        ret.ptr = XVENDORNAME;
+        break;
+    case VIDMODE_MON_MODEL:
+        ret.ptr = "XWAYLAND";
+        break;
+    case VIDMODE_MON_NHSYNC:
+        ret.i = 1;
+        break;
+    case VIDMODE_MON_NVREFRESH:
+        ret.i = 1;
+        break;
+    case VIDMODE_MON_HSYNC_LO:
+    case VIDMODE_MON_HSYNC_HI:
+        ret.f = mode_hsync(&rrmode->mode) * 100.0;
+        break;
+    case VIDMODE_MON_VREFRESH_LO:
+    case VIDMODE_MON_VREFRESH_HI:
+        ret.f = mode_refresh(&rrmode->mode) * 100.0;
+        break;
+    }
+    return ret;
+}
+
+static int
+xwlVidModeGetDotClock(ScreenPtr pScreen, int Clock)
+{
+    return Clock;
+}
+
+static int
+xwlVidModeGetNumOfClocks(ScreenPtr pScreen, Bool *progClock)
+{
+    /* We emulate a programmable clock, rather then a fixed set of clocks */
+    *progClock = TRUE;
+    return 0;
+}
+
+static Bool
+xwlVidModeGetClocks(ScreenPtr pScreen, int *Clocks)
+{
+    return FALSE; /* Programmable clock, no clock list */
+}
+
+/* GetFirstModeline and GetNextModeline are used from Xext/vidmode.c like this:
+ *  if (pVidMode->GetFirstModeline(pScreen, &mode, &dotClock)) {
+ *      do {
+ *          ...
+ *          if (...)
+ *              break;
+ *      } while (pVidMode->GetNextModeline(pScreen, &mode, &dotClock));
+ *  }
+ * IOW our caller basically always loops over all the modes. There never is a
+ * return to the mainloop between GetFirstModeline and NextModeline calls where
+ * other parts of the server may change our state so we do not need to worry
+ * about xwl_output->randr_output->modes changing underneath us.
+ * Thus we can simply implement these two callbacks by storing the enumeration
+ * index in pVidMode->Next.
+ */
+
+static Bool
+xwlVidModeGetNextModeline(ScreenPtr pScreen, DisplayModePtr *mode, int *dotClock)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+    VidModePtr pVidMode;
+    DisplayModePtr pMod;
+    intptr_t index;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (xwl_output == NULL)
+        return FALSE;
+
+    pMod = dixLookupPrivate(&pScreen->devPrivates, xwlVidModePrivateKey);
+    pVidMode = VidModeGetPtr(pScreen);
+    if (pMod == NULL || pVidMode == NULL)
+        return FALSE;
+
+    index = (intptr_t)pVidMode->Next;
+    if (index >= xwl_output->randr_output->numModes)
+        return FALSE;
+    xwlRRModeToDisplayMode(xwl_output->randr_output->modes[index], pMod);
+    index++;
+    pVidMode->Next = (void *)index;
+
+    *mode = pMod;
+    if (dotClock != NULL)
+        *dotClock = pMod->Clock;
+
+    return TRUE;
+}
+
+static Bool
+xwlVidModeGetFirstModeline(ScreenPtr pScreen, DisplayModePtr *mode, int *dotClock)
+{
+    VidModePtr pVidMode;
+    intptr_t index = 0;
+
+    pVidMode = VidModeGetPtr(pScreen);
+    if (pVidMode == NULL)
+        return FALSE;
+
+    pVidMode->Next = (void *)index; /* 0 */
+    return xwlVidModeGetNextModeline(pScreen, mode, dotClock);
+}
+
+static Bool
+xwlVidModeDeleteModeline(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    /* Unsupported */
+    return FALSE;
+}
+
+static Bool
+xwlVidModeZoomViewport(ScreenPtr pScreen, int zoom)
+{
+    /* Support only no zoom */
+    return (zoom == 1);
+}
+
+static Bool
+xwlVidModeSetViewPort(ScreenPtr pScreen, int x, int y)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (xwl_output == NULL)
+        return FALSE;
+
+    /* Support only default viewport */
+    return (x == xwl_output->x && y == xwl_output->y);
+}
+
+static Bool
+xwlVidModeGetViewPort(ScreenPtr pScreen, int *x, int *y)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (xwl_output == NULL)
+        return FALSE;
+
+    *x = xwl_output->x;
+    *y = xwl_output->y;
+
+    return TRUE;
+}
+
+static Bool
+xwlVidModeSwitchMode(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+    RRModePtr rrmode;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (xwl_output == NULL)
+        return FALSE;
+
+    rrmode = xwl_output_find_mode(xwl_output, mode->HDisplay, mode->VDisplay);
+    if (rrmode == NULL)
+        return FALSE;
+
+    if (xwl_screen->rootless)
+        xwl_output_set_emulated_mode(xwl_output, GetCurrentClient(), rrmode, TRUE);
+    else if (xwl_screen->fixed_output)
+        xwl_output_set_mode_fixed(xwl_screen->fixed_output, rrmode);
+
+    return TRUE;
+}
+
+static Bool
+xwlVidModeLockZoom(ScreenPtr pScreen, Bool lock)
+{
+    /* Unsupported for now, but pretend it works */
+    return TRUE;
+}
+
+static ModeStatus
+xwlVidModeCheckModeForMonitor(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    RRModePtr rrmode;
+
+    rrmode = xwlVidModeGetRRMode(pScreen, mode->HDisplay, mode->VDisplay);
+    if (rrmode == NULL)
+        return MODE_ERROR;
+
+    /* Only support mode with the same HSync/VRefresh as we advertise */
+    if (mode->HSync == mode_hsync(&rrmode->mode) &&
+        mode->VRefresh == mode_refresh(&rrmode->mode))
+        return MODE_OK;
+
+    /* All the rest is unsupported - If we want to succeed, return MODE_OK instead */
+    return MODE_ONE_SIZE;
+}
+
+static ModeStatus
+xwlVidModeCheckModeForDriver(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    RRModePtr rrmode;
+
+    rrmode = xwlVidModeGetRRMode(pScreen, mode->HDisplay, mode->VDisplay);
+    return rrmode ? MODE_OK : MODE_ERROR;
+}
+
+static void
+xwlVidModeSetCrtcForMode(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    /* Unsupported */
+    return;
+}
+
+static Bool
+xwlVidModeAddModeline(ScreenPtr pScreen, DisplayModePtr mode)
+{
+    /* Unsupported */
+    return FALSE;
+}
+
+static int
+xwlVidModeGetNumOfModes(ScreenPtr pScreen)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+
+    return xwl_output ? xwl_output->randr_output->numModes : 0;
+}
+
+static Bool
+xwlVidModeSetGamma(ScreenPtr pScreen, float red, float green, float blue)
+{
+    /* Unsupported for now, but pretend it works */
+    return TRUE;
+}
+
+static Bool
+xwlVidModeGetGamma(ScreenPtr pScreen, float *red, float *green, float *blue)
+{
+    /* Unsupported for now, but pretend it works */
+    *red = *green = *blue = 1.0f;
+    return TRUE;
+}
+
+static Bool
+xwlVidModeSetGammaRamp(ScreenPtr pScreen, int size, CARD16 *r, CARD16 *g, CARD16 *b)
+{
+    /* Unsupported for now */
+    return FALSE;
+}
+
+static Bool
+xwlVidModeGetGammaRamp(ScreenPtr pScreen, int size, CARD16 *r, CARD16 *g, CARD16 *b)
+{
+    /* Unsupported for now */
+    return FALSE;
+}
+
+static int
+xwlVidModeGetGammaRampSize(ScreenPtr pScreen)
+{
+    /* Unsupported for now */
+    return 0;
+}
+
+static Bool
+xwlVidModeInit(ScreenPtr pScreen)
+{
+    VidModePtr pVidMode = NULL;
+
+    pVidMode = VidModeInit(pScreen);
+    if (!pVidMode)
+        return FALSE;
+
+    pVidMode->Flags = 0;
+    pVidMode->Next = NULL;
+
+    pVidMode->GetMonitorValue = xwlVidModeGetMonitorValue;
+    pVidMode->GetCurrentModeline = xwlVidModeGetCurrentModeline;
+    pVidMode->GetFirstModeline = xwlVidModeGetFirstModeline;
+    pVidMode->GetNextModeline = xwlVidModeGetNextModeline;
+    pVidMode->DeleteModeline = xwlVidModeDeleteModeline;
+    pVidMode->ZoomViewport = xwlVidModeZoomViewport;
+    pVidMode->GetViewPort = xwlVidModeGetViewPort;
+    pVidMode->SetViewPort = xwlVidModeSetViewPort;
+    pVidMode->SwitchMode = xwlVidModeSwitchMode;
+    pVidMode->LockZoom = xwlVidModeLockZoom;
+    pVidMode->GetNumOfClocks = xwlVidModeGetNumOfClocks;
+    pVidMode->GetClocks = xwlVidModeGetClocks;
+    pVidMode->CheckModeForMonitor = xwlVidModeCheckModeForMonitor;
+    pVidMode->CheckModeForDriver = xwlVidModeCheckModeForDriver;
+    pVidMode->SetCrtcForMode = xwlVidModeSetCrtcForMode;
+    pVidMode->AddModeline = xwlVidModeAddModeline;
+    pVidMode->GetDotClock = xwlVidModeGetDotClock;
+    pVidMode->GetNumOfModes = xwlVidModeGetNumOfModes;
+    pVidMode->SetGamma = xwlVidModeSetGamma;
+    pVidMode->GetGamma = xwlVidModeGetGamma;
+    pVidMode->SetGammaRamp = xwlVidModeSetGammaRamp;
+    pVidMode->GetGammaRamp = xwlVidModeGetGammaRamp;
+    pVidMode->GetGammaRampSize = xwlVidModeGetGammaRampSize;
+
+    return TRUE;
+}
+
+void
+xwlVidModeExtensionInit(void)
+{
+    int i;
+    Bool enabled = FALSE;
+
+    for (i = 0; i < screenInfo.numScreens; i++) {
+        if (xwlVidModeInit (screenInfo.screens[i]))
+            enabled = TRUE;
+    }
+    /* This means that the DDX doesn't want the vidmode extension enabled */
+    if (!enabled)
+        return;
+
+    if (!dixRegisterPrivateKey(xwlVidModePrivateKey, PRIVATE_SCREEN,
+                               sizeof(DisplayModeRec)))
+        return;
+
+    VidModeAddExtension(FALSE);
+}
+
+#endif                          /* XF86VIDMODE */
diff --git a/hw/xwayland/xwayland-vidmode.h b/hw/xwayland/xwayland-vidmode.h
new file mode 100644
index 000000000..4e3236eb1
--- /dev/null
+++ b/hw/xwayland/xwayland-vidmode.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef XWAYLAND_VIDMODE_H
+#define XWAYLAND_VIDMODE_H
+
+#include <xwayland-config.h>
+
+#ifdef XF86VIDMODE
+void xwlVidModeExtensionInit(void);
+#endif
+
+#endif /* XWAYLAND_VIDMODE_H */
diff --git a/hw/xwayland/xwayland-window-buffers.c b/hw/xwayland/xwayland-window-buffers.c
new file mode 100644
index 000000000..f04c79a8a
--- /dev/null
+++ b/hw/xwayland/xwayland-window-buffers.c
@@ -0,0 +1,367 @@
+/*
+ * Copyright © 2019 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *      Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#include <xwayland-config.h>
+
+#include "gcstruct.h"
+
+#include "xwayland-window.h"
+#include "xwayland-pixmap.h"
+#include "xwayland-screen.h"
+#include "xwayland-window-buffers.h"
+
+#define BUFFER_TIMEOUT 1 * 1000 /* ms */
+
+struct xwl_window_buffer {
+    struct xwl_window *xwl_window;
+    PixmapPtr pixmap;
+    RegionPtr damage_region;
+    Bool recycle_on_release;
+    int refcnt;
+    uint32_t time;
+    struct xorg_list link_buffer;
+};
+
+static Bool
+copy_pixmap_area(PixmapPtr src_pixmap, PixmapPtr dst_pixmap,
+                 int x, int y, int width, int height)
+{
+    GCPtr pGC;
+    pGC = GetScratchGC(dst_pixmap->drawable.depth,
+                       dst_pixmap->drawable.pScreen);
+    if (pGC) {
+        ValidateGC(&dst_pixmap->drawable, pGC);
+        (void) (*pGC->ops->CopyArea) (&src_pixmap->drawable,
+                                      &dst_pixmap->drawable,
+                                      pGC,
+                                      x, y,
+                                      width, height,
+                                      x, y);
+        FreeScratchGC(pGC);
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct xwl_window_buffer *
+xwl_window_buffer_new(struct xwl_window *xwl_window)
+{
+    struct xwl_window_buffer *xwl_window_buffer;
+
+    xwl_window_buffer = calloc (1, sizeof(struct xwl_window_buffer));
+    if (!xwl_window_buffer)
+        return NULL;
+
+    xwl_window_buffer->xwl_window = xwl_window;
+    xwl_window_buffer->damage_region = RegionCreate(NullBox, 1);
+    xwl_window_buffer->pixmap = NullPixmap;
+    xwl_window_buffer->refcnt = 1;
+
+    xorg_list_append(&xwl_window_buffer->link_buffer,
+                     &xwl_window->window_buffers_available);
+
+    return xwl_window_buffer;
+}
+
+static void
+xwl_window_buffer_destroy_pixmap(struct xwl_window_buffer *xwl_window_buffer)
+{
+    ScreenPtr pScreen = xwl_window_buffer->pixmap->drawable.pScreen;
+
+    xwl_pixmap_del_buffer_release_cb(xwl_window_buffer->pixmap);
+    (*pScreen->DestroyPixmap) (xwl_window_buffer->pixmap);
+    xwl_window_buffer->pixmap = NullPixmap;
+}
+
+static Bool
+xwl_window_buffer_dispose(struct xwl_window_buffer *xwl_window_buffer)
+{
+    assert(xwl_window_buffer->refcnt > 0);
+
+    if (--xwl_window_buffer->refcnt)
+        return FALSE;
+
+    RegionDestroy(xwl_window_buffer->damage_region);
+
+    if (xwl_window_buffer->pixmap)
+        xwl_window_buffer_destroy_pixmap (xwl_window_buffer);
+
+    xorg_list_del(&xwl_window_buffer->link_buffer);
+    free(xwl_window_buffer);
+
+    return TRUE;
+}
+
+static void
+xwl_window_buffer_recycle(struct xwl_window_buffer *xwl_window_buffer)
+{
+    RegionEmpty(xwl_window_buffer->damage_region);
+    xwl_window_buffer->recycle_on_release = FALSE;
+
+    if (xwl_window_buffer->pixmap)
+        xwl_window_buffer_destroy_pixmap (xwl_window_buffer);
+}
+
+static void
+xwl_window_buffer_add_damage_region(struct xwl_window *xwl_window,
+                                    RegionPtr damage_region)
+{
+    struct xwl_window_buffer *xwl_window_buffer;
+
+    /* Add damage region to all buffers */
+    xorg_list_for_each_entry(xwl_window_buffer,
+                             &xwl_window->window_buffers_available,
+                             link_buffer) {
+        RegionUnion(xwl_window_buffer->damage_region,
+                    xwl_window_buffer->damage_region,
+                    damage_region);
+    }
+    xorg_list_for_each_entry(xwl_window_buffer,
+                             &xwl_window->window_buffers_unavailable,
+                             link_buffer) {
+        RegionUnion(xwl_window_buffer->damage_region,
+                    xwl_window_buffer->damage_region,
+                    damage_region);
+    }
+}
+
+static struct xwl_window_buffer *
+xwl_window_buffer_get_available(struct xwl_window *xwl_window)
+{
+    if (xorg_list_is_empty(&xwl_window->window_buffers_available))
+        return xwl_window_buffer_new(xwl_window);
+
+    return xorg_list_last_entry(&xwl_window->window_buffers_available,
+                                struct xwl_window_buffer,
+                                link_buffer);
+}
+
+static CARD32
+xwl_window_buffer_timer_callback(OsTimerPtr timer, CARD32 time, void *arg)
+{
+    struct xwl_window *xwl_window = arg;
+    struct xwl_window_buffer *xwl_window_buffer, *tmp;
+
+    /* Dispose older available buffers */
+    xorg_list_for_each_entry_safe(xwl_window_buffer, tmp,
+                                  &xwl_window->window_buffers_available,
+                                  link_buffer) {
+        if ((int64_t)(time - xwl_window_buffer->time) >= BUFFER_TIMEOUT)
+            xwl_window_buffer_dispose(xwl_window_buffer);
+    }
+
+    /* If there are still available buffers, re-arm the timer */
+    if (!xorg_list_is_empty(&xwl_window->window_buffers_available)) {
+        struct xwl_window_buffer *oldest_available_buffer =
+            xorg_list_first_entry(&xwl_window->window_buffers_available,
+                                  struct xwl_window_buffer,
+                                  link_buffer);
+
+        return oldest_available_buffer->time + BUFFER_TIMEOUT - time;
+    }
+
+    /* Don't re-arm the timer */
+    return 0;
+}
+
+static void
+xwl_window_buffer_release_callback(void *data)
+{
+    struct xwl_window_buffer *xwl_window_buffer = data;
+    struct xwl_window *xwl_window = xwl_window_buffer->xwl_window;
+    struct xwl_window_buffer *oldest_available_buffer;
+
+    /* Drop the reference on the buffer we took in get_pixmap. If that
+     * frees the window buffer, we're done.
+     */
+    if (xwl_window_buffer_dispose(xwl_window_buffer))
+        return;
+
+    if (xwl_window_buffer->recycle_on_release)
+        xwl_window_buffer_recycle(xwl_window_buffer);
+
+    /* We append the buffers to the end of the list, as we pick the last
+     * entry again when looking for new available buffers, that means the
+     * least used buffers will remain at the beginning of the list so that
+     * they can be garbage collected automatically after some time unused.
+     */
+
+    xorg_list_del(&xwl_window_buffer->link_buffer);
+    xorg_list_append(&xwl_window_buffer->link_buffer,
+                     &xwl_window->window_buffers_available);
+    xwl_window_buffer->time = (uint32_t) GetTimeInMillis();
+
+    oldest_available_buffer =
+        xorg_list_first_entry(&xwl_window->window_buffers_available,
+                             struct xwl_window_buffer,
+                             link_buffer);
+
+    /* Schedule next timer based on time of the oldest buffer */
+    xwl_window->window_buffers_timer =
+        TimerSet(xwl_window->window_buffers_timer,
+                 TimerAbsolute,
+                 oldest_available_buffer->time + BUFFER_TIMEOUT,
+                 &xwl_window_buffer_timer_callback,
+                 xwl_window);
+}
+
+void
+xwl_window_buffers_init(struct xwl_window *xwl_window)
+{
+    xorg_list_init(&xwl_window->window_buffers_available);
+    xorg_list_init(&xwl_window->window_buffers_unavailable);
+}
+
+void
+xwl_window_buffers_recycle(struct xwl_window *xwl_window)
+{
+    struct xwl_window_buffer *xwl_window_buffer, *tmp;
+
+    /* Dispose available buffers */
+    xorg_list_for_each_entry_safe(xwl_window_buffer, tmp,
+                                  &xwl_window->window_buffers_available,
+                                  link_buffer) {
+        xwl_window_buffer_dispose(xwl_window_buffer);
+    }
+
+    if (xwl_window->window_buffers_timer)
+        TimerCancel(xwl_window->window_buffers_timer);
+
+    /* Mark the others for recycle on release */
+    xorg_list_for_each_entry(xwl_window_buffer,
+                             &xwl_window->window_buffers_unavailable,
+                             link_buffer) {
+        xwl_window_buffer->recycle_on_release = TRUE;
+    }
+}
+
+void
+xwl_window_buffers_dispose(struct xwl_window *xwl_window)
+{
+    struct xwl_window_buffer *xwl_window_buffer, *tmp;
+
+    /* This is called prior to free the xwl_window, make sure to untie
+     * the buffers from the xwl_window so that we don't point at freed
+     * memory if we get a release buffer later.
+     */
+    xorg_list_for_each_entry_safe(xwl_window_buffer, tmp,
+                                  &xwl_window->window_buffers_available,
+                                  link_buffer) {
+        xorg_list_del(&xwl_window_buffer->link_buffer);
+        xwl_window_buffer_dispose(xwl_window_buffer);
+    }
+
+    xorg_list_for_each_entry_safe(xwl_window_buffer, tmp,
+                                  &xwl_window->window_buffers_unavailable,
+                                  link_buffer) {
+        xorg_list_del(&xwl_window_buffer->link_buffer);
+        xwl_window_buffer_dispose(xwl_window_buffer);
+    }
+
+    if (xwl_window->window_buffers_timer) {
+        TimerFree(xwl_window->window_buffers_timer);
+        xwl_window->window_buffers_timer = 0;
+    }
+}
+
+PixmapPtr
+xwl_window_buffers_get_pixmap(struct xwl_window *xwl_window,
+                              RegionPtr damage_region)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_window_buffer *xwl_window_buffer;
+    PixmapPtr window_pixmap;
+    RegionPtr full_damage;
+
+    window_pixmap = (*xwl_screen->screen->GetWindowPixmap) (xwl_window->window);
+
+#ifdef XWL_HAS_GLAMOR
+    if (!xwl_glamor_needs_n_buffering(xwl_screen))
+        return window_pixmap;
+#endif /* XWL_HAS_GLAMOR */
+
+    xwl_window_buffer = xwl_window_buffer_get_available(xwl_window);
+    if (!xwl_window_buffer)
+        return window_pixmap;
+
+    xwl_window_buffer_add_damage_region(xwl_window, damage_region);
+
+    full_damage = xwl_window_buffer->damage_region;
+
+    if (xwl_window_buffer->pixmap) {
+        BoxPtr pBox = RegionRects(full_damage);
+        int nBox = RegionNumRects(full_damage);
+        while (nBox--) {
+            if (!copy_pixmap_area(window_pixmap,
+                                  xwl_window_buffer->pixmap,
+                                  pBox->x1 + xwl_window->window->borderWidth,
+                                  pBox->y1 + xwl_window->window->borderWidth,
+                                  pBox->x2 - pBox->x1,
+                                  pBox->y2 - pBox->y1))
+                return window_pixmap;
+
+            pBox++;
+        }
+    } else {
+        xwl_window_buffer->pixmap =
+            (*xwl_screen->screen->CreatePixmap) (window_pixmap->drawable.pScreen,
+                                                 window_pixmap->drawable.width,
+                                                 window_pixmap->drawable.height,
+                                                 window_pixmap->drawable.depth,
+                                                 CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+
+        if (!xwl_window_buffer->pixmap)
+            return window_pixmap;
+
+        if (!copy_pixmap_area(window_pixmap,
+                              xwl_window_buffer->pixmap,
+                              0, 0,
+                              window_pixmap->drawable.width,
+                              window_pixmap->drawable.height)) {
+            xwl_window_buffer_recycle(xwl_window_buffer);
+            return window_pixmap;
+        }
+    }
+
+    RegionEmpty(xwl_window_buffer->damage_region);
+
+    /* Hold a reference on the buffer until it's released by the compositor */
+    xwl_window_buffer->refcnt++;
+    xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
+                                     xwl_window_buffer_release_callback,
+                                     xwl_window_buffer);
+
+    xorg_list_del(&xwl_window_buffer->link_buffer);
+    xorg_list_append(&xwl_window_buffer->link_buffer,
+                     &xwl_window->window_buffers_unavailable);
+
+    if (xorg_list_is_empty(&xwl_window->window_buffers_available))
+        TimerCancel(xwl_window->window_buffers_timer);
+
+    return xwl_window_buffer->pixmap;
+}
diff --git a/hw/xwayland/xwayland-window-buffers.h b/hw/xwayland/xwayland-window-buffers.h
new file mode 100644
index 000000000..8031f24d5
--- /dev/null
+++ b/hw/xwayland/xwayland-window-buffers.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright © 2019 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *      Olivier Fourdan <ofourdan@redhat.com>
+ */
+
+#ifndef XWAYLAND_WINDOW_BUFFERS_H
+#define XWAYLAND_WINDOW_BUFFERS_H
+
+#include <xwayland-config.h>
+
+#include "xwayland-types.h"
+#include "regionstr.h"
+
+void xwl_window_buffers_init(struct xwl_window *xwl_window);
+void xwl_window_buffers_recycle(struct xwl_window *xwl_window);
+void xwl_window_buffers_dispose(struct xwl_window *xwl_window);
+PixmapPtr xwl_window_buffers_get_pixmap(struct xwl_window *xwl_window,
+                                        RegionPtr damage_region);
+
+#endif /* XWAYLAND_WINDOW_BUFFERS_H */
diff --git a/hw/xwayland/xwayland-window.c b/hw/xwayland/xwayland-window.c
new file mode 100644
index 000000000..941c1b01b
--- /dev/null
+++ b/hw/xwayland/xwayland-window.c
@@ -0,0 +1,1360 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <sys/mman.h>
+
+#include <X11/X.h>
+#include <X11/Xatom.h>
+
+#include "compositeext.h"
+#include "compint.h"
+#include "inputstr.h"
+#include "propertyst.h"
+
+#include "xwayland-types.h"
+#include "xwayland-input.h"
+#include "xwayland-present.h"
+#include "xwayland-screen.h"
+#include "xwayland-window.h"
+#include "xwayland-window-buffers.h"
+#include "xwayland-shm.h"
+
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "viewporter-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
+#include "xwayland-shell-v1-client-protocol.h"
+
+#define DELAYED_WL_SURFACE_DESTROY 1000 /* ms */
+
+static DevPrivateKeyRec xwl_window_private_key;
+static DevPrivateKeyRec xwl_damage_private_key;
+static const char *xwl_surface_tag = "xwl-surface";
+
+static void
+xwl_window_set_allow_commits(struct xwl_window *xwl_window, Bool allow,
+                             const char *debug_msg)
+{
+    xwl_window->allow_commits = allow;
+    DebugF("xwayland: win %d allow_commits = %d (%s)\n",
+           xwl_window->window->drawable.id, allow, debug_msg);
+}
+
+static void
+xwl_window_set_allow_commits_from_property(struct xwl_window *xwl_window,
+                                           PropertyPtr prop)
+{
+    static Bool warned = FALSE;
+    CARD32 *propdata;
+
+    if (prop->propertyName != xwl_window->xwl_screen->allow_commits_prop)
+        FatalError("Xwayland internal error: prop mismatch in %s.\n", __func__);
+
+    if (prop->type != XA_CARDINAL || prop->format != 32 || prop->size != 1) {
+        /* Not properly set, so fall back to safe and glitchy */
+        xwl_window_set_allow_commits(xwl_window, TRUE, "WM fault");
+
+        if (!warned) {
+            LogMessageVerb(X_WARNING, 0, "Window manager is misusing property %s.\n",
+                           NameForAtom(prop->propertyName));
+            warned = TRUE;
+        }
+        return;
+    }
+
+    propdata = prop->data;
+    xwl_window_set_allow_commits(xwl_window, !!propdata[0], "from property");
+}
+
+struct xwl_window *
+xwl_window_get(WindowPtr window)
+{
+    return dixLookupPrivate(&window->devPrivates, &xwl_window_private_key);
+}
+
+static DamagePtr
+window_get_damage(WindowPtr window)
+{
+    return dixLookupPrivate(&window->devPrivates, &xwl_damage_private_key);
+}
+
+struct xwl_window *
+xwl_window_from_window(WindowPtr window)
+{
+    struct xwl_window *xwl_window;
+
+    while (window) {
+        xwl_window = xwl_window_get(window);
+        if (xwl_window)
+            return xwl_window;
+
+        window = window->parent;
+    }
+
+    return NULL;
+}
+
+static void
+xwl_window_set_xwayland_tag(struct xwl_window *xwl_window)
+{
+    wl_proxy_set_tag((struct wl_proxy *)xwl_window->surface, &xwl_surface_tag);
+}
+
+static void
+xwl_window_clear_xwayland_tag(struct xwl_window *xwl_window)
+{
+    wl_proxy_set_tag((struct wl_proxy *)xwl_window->surface, NULL);
+}
+
+Bool
+is_surface_from_xwl_window(struct wl_surface *surface)
+{
+    return wl_proxy_get_tag((struct wl_proxy *) surface) == &xwl_surface_tag;
+}
+
+void
+xwl_window_update_property(struct xwl_window *xwl_window,
+                           PropertyStateRec *propstate)
+{
+    switch (propstate->state) {
+    case PropertyNewValue:
+        xwl_window_set_allow_commits_from_property(xwl_window, propstate->prop);
+        break;
+
+    case PropertyDelete:
+        xwl_window_set_allow_commits(xwl_window, TRUE, "property deleted");
+        break;
+
+    default:
+        break;
+    }
+}
+
+static void
+damage_report(DamagePtr pDamage, RegionPtr pRegion, void *data)
+{
+    WindowPtr window = data;
+    struct xwl_window *xwl_window = xwl_window_get(window);
+    struct xwl_screen *xwl_screen;
+
+    if (!xwl_window)
+        return;
+
+    xwl_screen = xwl_window->xwl_screen;
+
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_window->present_flipped) {
+        /* This damage is from a Present flip, which already committed a new
+         * buffer for the surface, so we don't need to do anything in response
+         */
+        RegionEmpty(DamageRegion(pDamage));
+        xorg_list_del(&xwl_window->link_damage);
+        xwl_window->present_flipped = FALSE;
+        return;
+    }
+#endif
+
+    xorg_list_add(&xwl_window->link_damage, &xwl_screen->damage_window_list);
+}
+
+static void
+damage_destroy(DamagePtr pDamage, void *data)
+{
+}
+
+static Bool
+register_damage(WindowPtr window)
+{
+    DamagePtr damage;
+
+    damage = DamageCreate(damage_report, damage_destroy, DamageReportNonEmpty,
+                          FALSE, window->drawable.pScreen, window);
+    if (damage == NULL) {
+        ErrorF("Failed creating damage\n");
+        return FALSE;
+    }
+
+    DamageRegister(&window->drawable, damage);
+    DamageSetReportAfterOp(damage, TRUE);
+
+    dixSetPrivate(&window->devPrivates, &xwl_damage_private_key, damage);
+
+    return TRUE;
+}
+
+static void
+unregister_damage(WindowPtr window)
+{
+    DamagePtr damage;
+
+    damage = dixLookupPrivate(&window->devPrivates, &xwl_damage_private_key);
+    if (!damage)
+        return;
+
+    DamageUnregister(damage);
+    DamageDestroy(damage);
+
+    dixSetPrivate(&window->devPrivates, &xwl_damage_private_key, NULL);
+}
+
+Bool
+xwl_window_has_viewport_enabled(struct xwl_window *xwl_window)
+{
+    return (xwl_window->viewport != NULL);
+}
+
+static void
+xwl_window_disable_viewport(struct xwl_window *xwl_window)
+{
+    assert (xwl_window->viewport);
+
+    DebugF("XWAYLAND: disabling viewport\n");
+    wp_viewport_destroy(xwl_window->viewport);
+    xwl_window->viewport = NULL;
+}
+
+static void
+xwl_window_enable_viewport(struct xwl_window *xwl_window,
+                           struct xwl_output *xwl_output,
+                           struct xwl_emulated_mode *emulated_mode)
+{
+    if (!xwl_window_has_viewport_enabled(xwl_window)) {
+        DebugF("XWAYLAND: enabling viewport %dx%d -> %dx%d\n",
+               emulated_mode->width, emulated_mode->height,
+               xwl_output->width, xwl_output->height);
+        xwl_window->viewport = wp_viewporter_get_viewport(xwl_window->xwl_screen->viewporter,
+                                                          xwl_window->surface);
+    }
+
+    wp_viewport_set_source(xwl_window->viewport,
+                           wl_fixed_from_int(0),
+                           wl_fixed_from_int(0),
+                           wl_fixed_from_int(emulated_mode->width),
+                           wl_fixed_from_int(emulated_mode->height));
+    wp_viewport_set_destination(xwl_window->viewport,
+                                xwl_output->width,
+                                xwl_output->height);
+
+    xwl_window->scale_x = (float)emulated_mode->width  / xwl_output->width;
+    xwl_window->scale_y = (float)emulated_mode->height / xwl_output->height;
+}
+
+static Bool
+window_is_wm_window(WindowPtr window)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
+
+    return CLIENT_ID(window->drawable.id) == xwl_screen->wm_client_id;
+}
+
+static WindowPtr
+window_get_client_toplevel(WindowPtr window)
+{
+    assert(window);
+
+    /* If the toplevel window is owned by the window-manager, then the
+     * actual client toplevel window has been reparented to some window-manager
+     * decoration/wrapper windows. In that case recurse by checking the client
+     * of the first *and only* child of the decoration/wrapper window.
+     */
+    while (window_is_wm_window(window)) {
+        if (!window->firstChild || window->firstChild != window->lastChild)
+            return NULL; /* Should never happen, skip resolution emulation */
+
+        window = window->firstChild;
+    }
+
+    return window;
+}
+
+static struct xwl_output *
+xwl_window_get_output(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_output_from_wl_output(xwl_screen, xwl_window->wl_output);
+
+    if (xwl_output)
+        return xwl_output;
+
+    return xwl_screen_get_first_output(xwl_screen);
+}
+
+static Bool
+xwl_window_should_enable_viewport_fullscreen(struct xwl_window *xwl_window,
+                                             struct xwl_output **xwl_output_ret,
+                                             struct xwl_emulated_mode *emulated_mode_ret)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_output *xwl_output;
+
+    xwl_output = xwl_window_get_output(xwl_window);
+    if (!xwl_output)
+        return FALSE;
+
+    *xwl_output_ret = xwl_output;
+    emulated_mode_ret->server_output_id = 0;
+    emulated_mode_ret->width = xwl_screen->width;
+    emulated_mode_ret->height = xwl_screen->height;
+    emulated_mode_ret->from_vidmode = FALSE;
+
+    return TRUE;
+}
+
+static Bool
+xwl_window_should_enable_viewport(struct xwl_window *xwl_window,
+                                  struct xwl_output **xwl_output_ret,
+                                  struct xwl_emulated_mode *emulated_mode_ret)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_emulated_mode *emulated_mode;
+    struct xwl_output *xwl_output;
+    ClientPtr owner;
+    WindowPtr window;
+    DrawablePtr drawable;
+
+    if (!xwl_screen_has_viewport_support(xwl_screen))
+        return FALSE;
+
+    if (xwl_screen->fullscreen)
+        return xwl_window_should_enable_viewport_fullscreen(xwl_window,
+                                                            xwl_output_ret,
+                                                            emulated_mode_ret);
+
+    if (!xwl_screen->rootless)
+        return FALSE;
+
+    window = window_get_client_toplevel(xwl_window->window);
+    if (!window)
+        return FALSE;
+
+    owner = wClient(window);
+    drawable = &window->drawable;
+
+    /* 1. Test if the window matches the emulated mode on one of the outputs
+     * This path gets hit by most games / libs (e.g. SDL, SFML, OGRE)
+     */
+    xorg_list_for_each_entry(xwl_output, &xwl_screen->output_list, link) {
+        emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, owner);
+        if (!emulated_mode)
+            continue;
+
+        if (drawable->x == xwl_output->x &&
+            drawable->y == xwl_output->y &&
+            drawable->width  == emulated_mode->width &&
+            drawable->height == emulated_mode->height) {
+
+            memcpy(emulated_mode_ret, emulated_mode, sizeof(struct xwl_emulated_mode));
+            *xwl_output_ret = xwl_output;
+            return TRUE;
+        }
+    }
+
+    /* 2. Test if the window uses override-redirect + vidmode
+     * and matches (fully covers) the entire screen.
+     * This path gets hit by: allegro4, ClanLib-1.0.
+     */
+    xwl_output = xwl_screen_get_first_output(xwl_screen);
+    emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, owner);
+    if (xwl_output && xwl_window->window->overrideRedirect &&
+        emulated_mode && emulated_mode->from_vidmode &&
+        drawable->x == 0 && drawable->y == 0 &&
+        drawable->width  == xwl_screen->width &&
+        drawable->height == xwl_screen->height) {
+
+        memcpy(emulated_mode_ret, emulated_mode, sizeof(struct xwl_emulated_mode));
+        *xwl_output_ret = xwl_output;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+void
+xwl_window_check_resolution_change_emulation(struct xwl_window *xwl_window)
+{
+    struct xwl_emulated_mode emulated_mode;
+    struct xwl_output *xwl_output;
+
+    if (xwl_window_should_enable_viewport(xwl_window, &xwl_output, &emulated_mode))
+        xwl_window_enable_viewport(xwl_window, xwl_output, &emulated_mode);
+    else if (xwl_window_has_viewport_enabled(xwl_window))
+        xwl_window_disable_viewport(xwl_window);
+}
+
+/* This checks if the passed in Window is a toplevel client window, note this
+ * returns false for window-manager decoration windows and returns true for
+ * the actual client top-level window even if it has been reparented to
+ * a window-manager decoration window.
+ */
+Bool
+xwl_window_is_toplevel(WindowPtr window)
+{
+    if (window_is_wm_window(window))
+        return FALSE;
+
+    /* CSD and override-redirect toplevel windows */
+    if (window_get_damage(window))
+        return TRUE;
+
+    /* Normal toplevel client windows, reparented to a window-manager window */
+    return window->parent && window_is_wm_window(window->parent);
+}
+
+static void
+xwl_window_init_allow_commits(struct xwl_window *xwl_window)
+{
+    PropertyPtr prop = NULL;
+    int ret;
+
+    ret = dixLookupProperty(&prop, xwl_window->window,
+                            xwl_window->xwl_screen->allow_commits_prop,
+                            serverClient, DixReadAccess);
+    if (ret == Success && prop)
+        xwl_window_set_allow_commits_from_property(xwl_window, prop);
+    else
+        xwl_window_set_allow_commits(xwl_window, TRUE, "no property");
+}
+
+static uint32_t
+serial_lo(uint64_t value)
+{
+    return value & 0xFFFFFFFFu;
+}
+
+static uint32_t
+serial_hi(uint64_t value)
+{
+    return value >> 32u;
+}
+
+static void
+send_window_client_message(struct xwl_window *xwl_window, Atom type_atom, uint64_t value)
+{
+    DeviceIntPtr dev;
+    xEvent e;
+
+    e.u.u.type = ClientMessage;
+    e.u.u.detail = 32;
+    e.u.clientMessage.window = xwl_window->window->drawable.id;
+    e.u.clientMessage.u.l.type = type_atom;
+    e.u.clientMessage.u.l.longs0 = serial_lo(value);
+    e.u.clientMessage.u.l.longs1 = serial_hi(value);
+    e.u.clientMessage.u.l.longs2 = 0;
+    e.u.clientMessage.u.l.longs3 = 0;
+    e.u.clientMessage.u.l.longs4 = 0;
+
+    dev = PickPointer(serverClient);
+    DeliverEventsToWindow(dev, xwl_window->xwl_screen->screen->root,
+                          &e, 1, SubstructureRedirectMask, NullGrab);
+}
+
+static void
+send_surface_id_event_serial(struct xwl_window *xwl_window)
+{
+    static const char atom_name[] = "WL_SURFACE_SERIAL";
+    static Atom type_atom;
+    uint64_t serial;
+
+    if (type_atom == None)
+        type_atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+
+    serial = ++xwl_window->xwl_screen->surface_association_serial;
+
+    send_window_client_message(xwl_window, type_atom, serial);
+    xwayland_surface_v1_set_serial(xwl_window->xwayland_surface,
+        serial_lo(serial), serial_hi(serial));
+    wl_surface_commit(xwl_window->surface);
+
+    /* Flush wayland display *after* commit in the new path. */
+    wl_display_flush(xwl_window->xwl_screen->display);
+}
+
+static void
+send_surface_id_event_legacy(struct xwl_window *xwl_window)
+{
+    static const char atom_name[] = "WL_SURFACE_ID";
+    static Atom type_atom;
+    uint32_t surface_id;
+
+    if (type_atom == None)
+        type_atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+
+    surface_id = wl_proxy_get_id((struct wl_proxy *) xwl_window->surface);
+
+    /* Flush wayland display *before* setting the atom in the legacy path */
+    wl_display_flush(xwl_window->xwl_screen->display);
+
+    send_window_client_message(xwl_window, type_atom, (uint64_t)surface_id);
+}
+
+static void
+send_surface_id_event(struct xwl_window *xwl_window)
+{
+    return xwl_window->xwayland_surface
+        ? send_surface_id_event_serial(xwl_window)
+        : send_surface_id_event_legacy(xwl_window);
+
+}
+
+static Bool
+xwl_window_set_fullscreen(struct xwl_window *xwl_window)
+{
+    struct xwl_output *xwl_output;
+    struct wl_output *wl_output = NULL;
+
+    if (!xwl_window->xdg_toplevel)
+        return FALSE;
+
+    xwl_output = xwl_window_get_output(xwl_window);
+    if (xwl_output)
+        wl_output = xwl_output->output;
+
+    if (wl_output && xwl_window->wl_output_fullscreen == wl_output)
+        return FALSE;
+
+    xdg_toplevel_set_fullscreen(xwl_window->xdg_toplevel, wl_output);
+    xwl_window_check_resolution_change_emulation(xwl_window);
+    wl_surface_commit(xwl_window->surface);
+
+    xwl_window->wl_output_fullscreen = wl_output;
+
+    return TRUE;
+}
+
+void
+xwl_window_rootful_update_title(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    char title[128];
+    const char *grab_message = "";
+
+    if (xwl_screen->host_grab) {
+        if (xwl_screen->has_grab)
+            grab_message = " - ([ctrl]+[shift] releases mouse and keyboard)";
+        else
+            grab_message = " - ([ctrl]+[shift] grabs mouse and keyboard)";
+    }
+
+    snprintf(title, sizeof(title), "Xwayland on :%s%s", display, grab_message);
+
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_window->libdecor_frame)
+        libdecor_frame_set_title(xwl_window->libdecor_frame, title);
+    else
+#endif
+    if (xwl_window->xdg_toplevel)
+        xdg_toplevel_set_title(xwl_window->xdg_toplevel, title);
+}
+
+static void
+xwl_window_rootful_set_app_id(struct xwl_window *xwl_window)
+{
+    const char *app_id = "org.freedesktop.Xwayland";
+
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_window->libdecor_frame)
+        libdecor_frame_set_app_id(xwl_window->libdecor_frame, app_id);
+    else
+#endif
+    if (xwl_window->xdg_toplevel)
+        xdg_toplevel_set_app_id(xwl_window->xdg_toplevel, app_id);
+}
+
+#ifdef XWL_HAS_LIBDECOR
+static void
+xwl_window_update_libdecor_size(struct xwl_window *xwl_window, int width, int height)
+{
+    struct libdecor_state *state;
+
+    if (xwl_window->libdecor_frame) {
+	state = libdecor_state_new(width, height);
+	libdecor_frame_commit(xwl_window->libdecor_frame, state, NULL);
+	libdecor_state_free(state);
+    }
+}
+
+static void
+handle_libdecor_configure(struct libdecor_frame *frame,
+                          struct libdecor_configuration *configuration,
+                          void *data)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct libdecor_state *state;
+
+    state = libdecor_state_new(xwl_screen->width, xwl_screen->height);
+    libdecor_frame_commit(frame, state, configuration);
+    libdecor_state_free(state);
+
+    if (libdecor_frame_has_capability(frame, LIBDECOR_ACTION_RESIZE))
+        libdecor_frame_unset_capabilities(frame, LIBDECOR_ACTION_RESIZE);
+    if (libdecor_frame_has_capability(frame, LIBDECOR_ACTION_FULLSCREEN))
+        libdecor_frame_unset_capabilities(frame, LIBDECOR_ACTION_FULLSCREEN);
+}
+
+static void
+handle_libdecor_close(struct libdecor_frame *frame,
+                      void *data)
+{
+    DebugF("Terminating on compositor request");
+    GiveUp(0);
+}
+
+static void
+handle_libdecor_commit(struct libdecor_frame *frame,
+                       void *data)
+{
+    struct xwl_window *xwl_window = data;
+    wl_surface_commit(xwl_window->surface);
+}
+
+static void
+handle_libdecor_dismiss_popup(struct libdecor_frame *frame,
+                              const char *seat_name,
+                              void *data)
+{
+}
+
+static struct libdecor_frame_interface libdecor_frame_iface = {
+    handle_libdecor_configure,
+    handle_libdecor_close,
+    handle_libdecor_commit,
+    handle_libdecor_dismiss_popup,
+};
+#endif
+
+static void
+xdg_surface_handle_configure(void *data,
+                             struct xdg_surface *xdg_surface,
+                             uint32_t serial)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (xwl_screen->fullscreen)
+        xwl_window_set_fullscreen(xwl_window);
+
+    xdg_surface_ack_configure(xdg_surface, serial);
+    wl_surface_commit(xwl_window->surface);
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    xdg_surface_handle_configure,
+};
+
+static void
+xwl_window_surface_enter(void *data,
+                         struct wl_surface *wl_surface,
+                         struct wl_output *wl_output)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (xwl_window->wl_output != wl_output) {
+        xwl_window->wl_output = wl_output;
+
+        if (xwl_screen->fullscreen)
+            xwl_window_set_fullscreen(xwl_window);
+    }
+}
+
+static void
+xwl_window_surface_leave(void *data,
+                         struct wl_surface *wl_surface,
+                         struct wl_output *wl_output)
+{
+    struct xwl_window *xwl_window = data;
+
+    if (xwl_window->wl_output == wl_output)
+        xwl_window->wl_output = NULL;
+}
+
+static const struct wl_surface_listener surface_listener = {
+    xwl_window_surface_enter,
+    xwl_window_surface_leave
+};
+
+static void
+xdg_toplevel_handle_configure(void *data,
+                              struct xdg_toplevel *xdg_toplevel,
+                              int32_t width,
+                              int32_t height,
+                              struct wl_array *states)
+{
+}
+
+static void
+xdg_toplevel_handle_close(void *data,
+                          struct xdg_toplevel *xdg_toplevel)
+{
+    DebugF("Terminating on compositor request");
+    GiveUp(0);
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    xdg_toplevel_handle_configure,
+    xdg_toplevel_handle_close,
+};
+
+static Bool
+xwl_create_root_surface(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    WindowPtr window = xwl_window->window;
+    struct wl_region *region;
+
+
+#ifdef XWL_HAS_LIBDECOR
+    if (xwl_screen->decorate) {
+        xwl_window->libdecor_frame =
+            libdecor_decorate(xwl_screen->libdecor_context,
+                              xwl_window->surface,
+                              &libdecor_frame_iface,
+                              xwl_window);
+        libdecor_frame_map(xwl_window->libdecor_frame);
+    }
+    else
+#endif
+    {
+        xwl_window->xdg_surface =
+            xdg_wm_base_get_xdg_surface(xwl_screen->xdg_wm_base, xwl_window->surface);
+        if (xwl_window->xdg_surface == NULL) {
+            ErrorF("Failed creating xdg_wm_base xdg_surface\n");
+            goto err_surf;
+        }
+
+        xwl_window->xdg_toplevel =
+            xdg_surface_get_toplevel(xwl_window->xdg_surface);
+        if (xwl_window->xdg_surface == NULL) {
+            ErrorF("Failed creating xdg_toplevel\n");
+            goto err_surf;
+        }
+
+        wl_surface_add_listener(xwl_window->surface,
+                                &surface_listener, xwl_window);
+
+        xdg_surface_add_listener(xwl_window->xdg_surface,
+                                 &xdg_surface_listener, xwl_window);
+
+        xdg_toplevel_add_listener(xwl_window->xdg_toplevel,
+                                  &xdg_toplevel_listener,
+                                  NULL);
+    }
+
+    xwl_window_rootful_update_title(xwl_window);
+    xwl_window_rootful_set_app_id(xwl_window);
+
+    wl_surface_commit(xwl_window->surface);
+
+    region = wl_compositor_create_region(xwl_screen->compositor);
+    if (region == NULL) {
+        ErrorF("Failed creating region\n");
+        goto err_surf;
+    }
+
+    wl_region_add(region, 0, 0,
+                  window->drawable.width, window->drawable.height);
+    wl_surface_set_opaque_region(xwl_window->surface, region);
+    wl_region_destroy(region);
+
+    return TRUE;
+
+err_surf:
+    if (xwl_window->xdg_toplevel)
+        xdg_toplevel_destroy(xwl_window->xdg_toplevel);
+    if (xwl_window->xdg_surface)
+        xdg_surface_destroy(xwl_window->xdg_surface);
+    wl_surface_destroy(xwl_window->surface);
+
+    return FALSE;
+}
+
+static Bool
+ensure_surface_for_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+    WindowPtr toplevel;
+
+    if (xwl_window_from_window(window))
+        return TRUE;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    if (xwl_screen->rootless) {
+        if (window->redirectDraw != RedirectDrawManual)
+            return TRUE;
+    }
+    else {
+        if (window->parent)
+            return TRUE;
+    }
+
+    xwl_window = calloc(1, sizeof *xwl_window);
+    if (xwl_window == NULL)
+        return FALSE;
+
+    xwl_window->xwl_screen = xwl_screen;
+    xwl_window->window = window;
+    xwl_window->surface = wl_compositor_create_surface(xwl_screen->compositor);
+    if (xwl_window->surface == NULL) {
+        ErrorF("wl_display_create_surface failed\n");
+        goto err;
+    }
+
+    if (xwl_screen->xwayland_shell) {
+        xwl_window->xwayland_surface = xwayland_shell_v1_get_xwayland_surface(
+            xwl_screen->xwayland_shell, xwl_window->surface);
+    }
+
+    if (!xwl_screen->rootless && !xwl_create_root_surface(xwl_window))
+        goto err;
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->dmabuf_protocol_version >= 4)
+        xwl_dmabuf_setup_feedback_for_window(xwl_window);
+#endif
+
+    wl_display_flush(xwl_screen->display);
+
+    send_surface_id_event(xwl_window);
+
+    wl_surface_set_user_data(xwl_window->surface, xwl_window);
+    xwl_window_set_xwayland_tag(xwl_window);
+
+    compRedirectWindow(serverClient, window, CompositeRedirectManual);
+
+    dixSetPrivate(&window->devPrivates, &xwl_window_private_key, xwl_window);
+    xorg_list_init(&xwl_window->link_damage);
+    xorg_list_add(&xwl_window->link_window, &xwl_screen->window_list);
+
+#ifdef GLAMOR_HAS_GBM
+    xorg_list_init(&xwl_window->frame_callback_list);
+#endif
+
+    xwl_window_buffers_init(xwl_window);
+
+    xwl_window_init_allow_commits(xwl_window);
+
+    /* When a new window-manager window is realized, then the randr emulation
+     * props may have not been set on the managed client window yet.
+     */
+    if (!xwl_screen->fullscreen && window_is_wm_window(window)) {
+        toplevel = window_get_client_toplevel(window);
+        if (toplevel)
+            xwl_output_set_window_randr_emu_props(xwl_screen, toplevel);
+    } else {
+        /* CSD or O-R toplevel window, check viewport on creation */
+        xwl_window_check_resolution_change_emulation(xwl_window);
+    }
+
+    return TRUE;
+
+err:
+    free(xwl_window);
+    return FALSE;
+}
+
+Bool
+xwl_realize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    CompScreenPtr comp_screen = GetCompScreen(screen);
+    struct xwl_screen *xwl_screen;
+    Bool ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->RealizeWindow = xwl_screen->RealizeWindow;
+    ret = (*screen->RealizeWindow) (window);
+    xwl_screen->RealizeWindow = screen->RealizeWindow;
+    screen->RealizeWindow = xwl_realize_window;
+
+    if (!ret)
+        return FALSE;
+
+    if (xwl_screen->rootless) {
+        /* We do not want the COW to be mapped when rootless in Xwayland */
+        if (window == comp_screen->pOverlayWin) {
+            window->mapped = FALSE;
+            return TRUE;
+        }
+
+        if (!window->parent) {
+            BoxRec box = { 0, 0, xwl_screen->width, xwl_screen->height };
+
+            RegionReset(&window->winSize, &box);
+            RegionNull(&window->clipList);
+            RegionNull(&window->borderClip);
+        }
+    }
+
+    if (xwl_screen->rootless ?
+        (window->drawable.class == InputOutput &&
+         window->parent == window->drawable.pScreen->root) :
+        !window->parent) {
+        if (!register_damage(window))
+            return FALSE;
+    }
+
+    return ensure_surface_for_window(window);
+}
+
+static void
+xwl_surface_destroy_free_timer(struct xwl_wl_surface *xwl_wl_surface)
+{
+    if (xwl_wl_surface->wl_surface_destroy_timer) {
+        TimerFree(xwl_wl_surface->wl_surface_destroy_timer);
+        xwl_wl_surface->wl_surface_destroy_timer = NULL;
+    }
+}
+
+void
+xwl_window_surface_do_destroy(struct xwl_wl_surface *xwl_wl_surface)
+{
+    wl_surface_destroy(xwl_wl_surface->wl_surface);
+    xorg_list_del(&xwl_wl_surface->link);
+    xwl_surface_destroy_free_timer(xwl_wl_surface);
+    free(xwl_wl_surface);
+}
+
+static CARD32
+xwl_surface_destroy_callback(OsTimerPtr timer, CARD32 now, void *arg)
+{
+    struct xwl_wl_surface *xwl_wl_surface = arg;
+
+    xwl_window_surface_do_destroy(xwl_wl_surface);
+
+    return 0;
+}
+
+static void
+release_wl_surface_for_window_legacy_delay(struct xwl_window *xwl_window)
+{
+    struct xwl_wl_surface *xwl_wl_surface;
+
+    /* If the Xserver is terminating, destroy the surface immediately */
+    if ((dispatchException & DE_TERMINATE) == DE_TERMINATE) {
+        wl_surface_destroy(xwl_window->surface);
+        return;
+    }
+
+    /* Break the wl_surface / xwl_window relationship */
+    wl_surface_set_user_data(xwl_window->surface, NULL);
+    xwl_window_clear_xwayland_tag(xwl_window);
+
+    /* Schedule the destruction later, to mitigate the race between X11
+     * and Wayland processing so that the compositor has the time to
+     * establish the association before the wl_surface is destroyed.
+     */
+    xwl_wl_surface = xnfcalloc(1, sizeof *xwl_wl_surface);
+    xwl_wl_surface->wl_surface = xwl_window->surface;
+    xorg_list_add(&xwl_wl_surface->link,
+                  &xwl_window->xwl_screen->pending_wl_surface_destroy);
+    xwl_wl_surface->wl_surface_destroy_timer =
+        TimerSet(NULL, 0, DELAYED_WL_SURFACE_DESTROY,
+                 xwl_surface_destroy_callback, xwl_wl_surface);
+}
+
+static void
+release_wl_surface_for_window_shell(struct xwl_window *xwl_window)
+{
+    xwayland_surface_v1_destroy(xwl_window->xwayland_surface);
+    wl_surface_destroy(xwl_window->surface);
+}
+
+static void
+release_wl_surface_for_window(struct xwl_window *xwl_window)
+{
+    if (xwl_window->xwayland_surface)
+        release_wl_surface_for_window_shell(xwl_window);
+    else
+        release_wl_surface_for_window_legacy_delay(xwl_window);
+}
+
+void
+xwl_device_formats_destroy(struct xwl_device_formats *dev_formats)
+{
+    for (int j = 0; j < dev_formats->num_formats; j++)
+        free(dev_formats->formats[j].modifiers);
+    free(dev_formats->formats);
+}
+
+void
+xwl_dmabuf_feedback_clear_dev_formats(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    if (xwl_feedback->dev_formats_len == 0)
+        return;
+
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        struct xwl_device_formats *dev_format = &xwl_feedback->dev_formats[i];
+        xwl_device_formats_destroy(dev_format);
+    }
+    free(xwl_feedback->dev_formats);
+    xwl_feedback->dev_formats = NULL;
+    xwl_feedback->dev_formats_len = 0;
+}
+
+void
+xwl_dmabuf_feedback_destroy(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    munmap(xwl_feedback->format_table.entry,
+           xwl_feedback->format_table.len * sizeof(struct xwl_format_table_entry));
+    xwl_dmabuf_feedback_clear_dev_formats(xwl_feedback);
+
+    if (xwl_feedback->dmabuf_feedback)
+        zwp_linux_dmabuf_feedback_v1_destroy(xwl_feedback->dmabuf_feedback);
+
+    xwl_feedback->dmabuf_feedback = NULL;
+}
+
+Bool
+xwl_unrealize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+    struct xwl_seat *xwl_seat;
+    Bool ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (xwl_seat->focus_window && xwl_seat->focus_window->window == window)
+            xwl_seat->focus_window = NULL;
+        if (xwl_seat->tablet_focus_window && xwl_seat->tablet_focus_window->window == window)
+            xwl_seat->tablet_focus_window = NULL;
+        if (xwl_seat->last_xwindow == window)
+            xwl_seat->last_xwindow = NullWindow;
+        if (xwl_seat->cursor_confinement_window &&
+            xwl_seat->cursor_confinement_window->window == window)
+            xwl_seat_unconfine_pointer(xwl_seat);
+        if (xwl_seat->pointer_warp_emulator &&
+            xwl_seat->pointer_warp_emulator->locked_window &&
+            xwl_seat->pointer_warp_emulator->locked_window->window == window)
+            xwl_seat_destroy_pointer_warp_emulator(xwl_seat);
+        xwl_seat_clear_touch(xwl_seat, window);
+    }
+
+    compUnredirectWindow(serverClient, window, CompositeRedirectManual);
+
+    screen->UnrealizeWindow = xwl_screen->UnrealizeWindow;
+    ret = (*screen->UnrealizeWindow) (window);
+    xwl_screen->UnrealizeWindow = screen->UnrealizeWindow;
+    screen->UnrealizeWindow = xwl_unrealize_window;
+
+    xwl_window = xwl_window_get(window);
+    if (!xwl_window)
+        return ret;
+
+    if (xwl_window_has_viewport_enabled(xwl_window))
+        xwl_window_disable_viewport(xwl_window);
+
+    xwl_dmabuf_feedback_destroy(&xwl_window->feedback);
+
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_screen->present) {
+        struct xwl_present_window *xwl_present_window, *tmp;
+
+        xorg_list_for_each_entry_safe(xwl_present_window, tmp,
+                                      &xwl_window->frame_callback_list,
+                                      frame_callback_list) {
+            xwl_present_unrealize_window(xwl_present_window);
+        }
+    }
+#endif
+
+    release_wl_surface_for_window(xwl_window);
+    xorg_list_del(&xwl_window->link_damage);
+    xorg_list_del(&xwl_window->link_window);
+    unregister_damage(window);
+
+    xwl_window_buffers_dispose(xwl_window);
+
+    if (xwl_window->frame_callback)
+        wl_callback_destroy(xwl_window->frame_callback);
+
+    free(xwl_window);
+    dixSetPrivate(&window->devPrivates, &xwl_window_private_key, NULL);
+
+    return ret;
+}
+
+void
+xwl_window_set_window_pixmap(WindowPtr window,
+                             PixmapPtr pixmap)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+    PixmapPtr old_pixmap;
+
+    old_pixmap = (*screen->GetWindowPixmap) (window);
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->SetWindowPixmap = xwl_screen->SetWindowPixmap;
+    (*screen->SetWindowPixmap) (window, pixmap);
+    xwl_screen->SetWindowPixmap = screen->SetWindowPixmap;
+    screen->SetWindowPixmap = xwl_window_set_window_pixmap;
+
+    if (!RegionNotEmpty(&window->winSize))
+        return;
+
+    ensure_surface_for_window(window);
+
+    if (old_pixmap->drawable.width == pixmap->drawable.width &&
+        old_pixmap->drawable.height == pixmap->drawable.height)
+       return;
+
+    xwl_window = xwl_window_get(window);
+    if (xwl_window)
+            xwl_window_buffers_recycle(xwl_window);
+}
+
+Bool
+xwl_change_window_attributes(WindowPtr window, unsigned long mask)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    OtherClients *others;
+    Bool ret;
+
+    screen->ChangeWindowAttributes = xwl_screen->ChangeWindowAttributes;
+    ret = (*screen->ChangeWindowAttributes) (window, mask);
+    xwl_screen->ChangeWindowAttributes = screen->ChangeWindowAttributes;
+    screen->ChangeWindowAttributes = xwl_change_window_attributes;
+
+    if (window != screen->root || !(mask & CWEventMask))
+        return ret;
+
+    for (others = wOtherClients(window); others; others = others->next) {
+        if (others->mask & (SubstructureRedirectMask | ResizeRedirectMask))
+            xwl_screen->wm_client_id = CLIENT_ID(others->resource);
+    }
+
+    return ret;
+}
+
+void
+xwl_resize_window(WindowPtr window,
+                  int x, int y,
+                  unsigned int width, unsigned int height,
+                  WindowPtr sib)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+
+    xwl_screen = xwl_screen_get(screen);
+    xwl_window = xwl_window_from_window(window);
+
+    screen->ResizeWindow = xwl_screen->ResizeWindow;
+    (*screen->ResizeWindow) (window, x, y, width, height, sib);
+    xwl_screen->ResizeWindow = screen->ResizeWindow;
+    screen->ResizeWindow = xwl_resize_window;
+
+    if (xwl_window) {
+        if (xwl_window_get(window) || xwl_window_is_toplevel(window))
+            xwl_window_check_resolution_change_emulation(xwl_window);
+#ifdef XWL_HAS_LIBDECOR
+        if (window == screen->root)
+            xwl_window_update_libdecor_size(xwl_window, width, height);
+#endif
+    }
+}
+
+void
+xwl_move_window(WindowPtr window,
+                int x, int y,
+                WindowPtr next_sib,
+                VTKind kind)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+
+    xwl_screen = xwl_screen_get(screen);
+    xwl_window = xwl_window_from_window(window);
+
+    screen->MoveWindow = xwl_screen->MoveWindow;
+    (*screen->MoveWindow) (window, x, y, next_sib, kind);
+    xwl_screen->MoveWindow = screen->MoveWindow;
+    screen->MoveWindow = xwl_move_window;
+
+    if (xwl_window && (xwl_window_get(window) || xwl_window_is_toplevel(window)))
+        xwl_window_check_resolution_change_emulation(xwl_window);
+}
+
+static void
+frame_callback(void *data,
+               struct wl_callback *callback,
+               uint32_t time)
+{
+    struct xwl_window *xwl_window = data;
+
+    wl_callback_destroy (xwl_window->frame_callback);
+    xwl_window->frame_callback = NULL;
+
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_window->xwl_screen->present) {
+        struct xwl_present_window *xwl_present_window, *tmp;
+
+        xorg_list_for_each_entry_safe(xwl_present_window, tmp,
+                                      &xwl_window->frame_callback_list,
+                                      frame_callback_list) {
+            xwl_present_frame_callback(xwl_present_window);
+        }
+    }
+#endif
+}
+
+static const struct wl_callback_listener frame_listener = {
+    frame_callback
+};
+
+void
+xwl_window_create_frame_callback(struct xwl_window *xwl_window)
+{
+    xwl_window->frame_callback = wl_surface_frame(xwl_window->surface);
+    wl_callback_add_listener(xwl_window->frame_callback, &frame_listener,
+                             xwl_window);
+
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_window->xwl_screen->present) {
+        struct xwl_present_window *xwl_present_window, *tmp;
+
+        xorg_list_for_each_entry_safe(xwl_present_window, tmp,
+                                      &xwl_window->frame_callback_list,
+                                      frame_callback_list) {
+            xwl_present_reset_timer(xwl_present_window);
+        }
+    }
+#endif
+}
+
+Bool
+xwl_destroy_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    Bool ret;
+
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_screen->present)
+        xwl_present_cleanup(window);
+#endif
+
+    screen->DestroyWindow = xwl_screen->DestroyWindow;
+
+    if (screen->DestroyWindow)
+        ret = screen->DestroyWindow (window);
+    else
+        ret = TRUE;
+
+    xwl_screen->DestroyWindow = screen->DestroyWindow;
+    screen->DestroyWindow = xwl_destroy_window;
+
+    return ret;
+}
+
+void
+xwl_window_post_damage(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    RegionPtr region;
+    BoxPtr box;
+    struct wl_buffer *buffer;
+    PixmapPtr pixmap;
+    int i;
+
+    assert(!xwl_window->frame_callback);
+
+    region = DamageRegion(window_get_damage(xwl_window->window));
+    pixmap = xwl_window_buffers_get_pixmap(xwl_window, region);
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->glamor)
+        buffer = xwl_glamor_pixmap_get_wl_buffer(pixmap);
+    else
+#endif
+        buffer = xwl_shm_pixmap_get_wl_buffer(pixmap);
+
+    if (!buffer) {
+        ErrorF("Error getting buffer\n");
+        return;
+    }
+
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->glamor) {
+        if (!xwl_glamor_post_damage(xwl_window, pixmap, region)) {
+            ErrorF("glamor: Failed to post damage\n");
+            return;
+        }
+    }
+#endif
+
+    wl_surface_attach(xwl_window->surface, buffer, 0, 0);
+
+    /* Arbitrary limit to try to avoid flooding the Wayland
+     * connection. If we flood it too much anyway, this could
+     * abort in libwayland-client.
+     */
+    if (RegionNumRects(region) > 256) {
+        box = RegionExtents(region);
+        xwl_surface_damage(xwl_screen, xwl_window->surface,
+                           box->x1 + xwl_window->window->borderWidth,
+                           box->y1 + xwl_window->window->borderWidth,
+                           box->x2 - box->x1, box->y2 - box->y1);
+    } else {
+        box = RegionRects(region);
+        for (i = 0; i < RegionNumRects(region); i++, box++) {
+            xwl_surface_damage(xwl_screen, xwl_window->surface,
+                               box->x1 + xwl_window->window->borderWidth,
+                               box->y1 + xwl_window->window->borderWidth,
+                               box->x2 - box->x1, box->y2 - box->y1);
+        }
+    }
+
+    xwl_window_create_frame_callback(xwl_window);
+    DamageEmpty(window_get_damage(xwl_window->window));
+}
+
+Bool
+xwl_window_init(void)
+{
+    if (!dixRegisterPrivateKey(&xwl_window_private_key, PRIVATE_WINDOW, 0))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&xwl_damage_private_key, PRIVATE_WINDOW, 0))
+        return FALSE;
+
+    return TRUE;
+}
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
new file mode 100644
index 000000000..2e8313f56
--- /dev/null
+++ b/hw/xwayland/xwayland-window.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_WINDOW_H
+#define XWAYLAND_WINDOW_H
+
+#include <xwayland-config.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <X11/X.h>
+#include <dix.h>
+#include <propertyst.h>
+#include <validate.h>
+#include <wayland-util.h>
+
+#include "xwayland-types.h"
+
+struct xwl_wl_surface {
+    OsTimerPtr wl_surface_destroy_timer;
+    struct wl_surface *wl_surface;
+    struct xorg_list link;
+};
+
+struct xwl_format_table_entry {
+    uint32_t format;
+    uint32_t pad;
+    uint64_t modifier;
+};
+
+struct xwl_device_formats {
+    dev_t drm_dev;
+    int supports_scanout;
+    uint32_t num_formats;
+    struct xwl_format *formats;
+};
+
+struct xwl_format_table {
+    /* This is mmapped from the fd given to us by the compositor */
+    int len;
+    struct xwl_format_table_entry *entry;
+};
+
+/*
+ * Helper struct for sharing dmabuf feedback logic between
+ * a screen and a window. The screen will get the default
+ * feedback, and a window will get a per-surface feedback.
+ */
+struct xwl_dmabuf_feedback {
+    struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback;
+    struct xwl_format_table format_table;
+    dev_t main_dev;
+    /*
+     * This will be filled in during wl events and copied to
+     * dev_formats on dmabuf_feedback.tranche_done
+     */
+    struct xwl_device_formats tmp_tranche;
+    int feedback_done;
+    int dev_formats_len;
+    struct xwl_device_formats *dev_formats;
+    /*
+     * This flag is used to identify if the feedback
+     * has been resent. If this is true, then the xwayland
+     * clients need to be sent PresentCompleteModeSuboptimalCopy
+     * to tell them to re-request modifiers.
+     */
+    int unprocessed_feedback_pending;
+};
+
+struct xwl_window {
+    struct xwl_screen *xwl_screen;
+    struct wl_surface *surface;
+    struct wp_viewport *viewport;
+    float scale_x, scale_y;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    WindowPtr window;
+    struct xorg_list link_damage;
+    struct xorg_list link_window;
+    struct wl_callback *frame_callback;
+    Bool allow_commits;
+    struct xorg_list window_buffers_available;
+    struct xorg_list window_buffers_unavailable;
+    OsTimerPtr window_buffers_timer;
+    struct wl_output *wl_output;
+    struct wl_output *wl_output_fullscreen;
+#ifdef GLAMOR_HAS_GBM
+    struct xorg_list frame_callback_list;
+    Bool present_flipped;
+#endif
+#ifdef XWL_HAS_LIBDECOR
+    struct libdecor_frame *libdecor_frame;
+#endif
+    struct xwayland_surface_v1 *xwayland_surface;
+    struct xwl_dmabuf_feedback feedback;
+};
+
+struct xwl_window *xwl_window_get(WindowPtr window);
+struct xwl_window *xwl_window_from_window(WindowPtr window);
+
+Bool is_surface_from_xwl_window(struct wl_surface *surface);
+
+void xwl_window_update_property(struct xwl_window *xwl_window,
+                                PropertyStateRec *propstate);
+Bool xwl_window_has_viewport_enabled(struct xwl_window *xwl_window);
+Bool xwl_window_is_toplevel(WindowPtr window);
+void xwl_window_check_resolution_change_emulation(struct xwl_window *xwl_window);
+void xwl_window_rootful_update_title(struct xwl_window *xwl_window);
+
+void xwl_window_set_window_pixmap(WindowPtr window, PixmapPtr pixmap);
+
+Bool xwl_realize_window(WindowPtr window);
+Bool xwl_unrealize_window(WindowPtr window);
+Bool xwl_change_window_attributes(WindowPtr window, unsigned long mask);
+void xwl_resize_window(WindowPtr window,
+                       int x, int y,
+                       unsigned int width, unsigned int height,
+                       WindowPtr sib);
+void xwl_move_window(WindowPtr window,
+                     int x, int y,
+                     WindowPtr next_sib,
+                     VTKind kind);
+Bool xwl_destroy_window(WindowPtr window);
+void xwl_window_post_damage(struct xwl_window *xwl_window);
+void xwl_window_create_frame_callback(struct xwl_window *xwl_window);
+void xwl_window_surface_do_destroy(struct xwl_wl_surface *xwl_wl_surface);
+
+Bool xwl_window_init(void);
+
+void xwl_dmabuf_feedback_destroy(struct xwl_dmabuf_feedback *xwl_feedback);
+void xwl_dmabuf_feedback_clear_dev_formats(struct xwl_dmabuf_feedback *xwl_feedback);
+void xwl_device_formats_destroy(struct xwl_device_formats *dev_formats);
+
+#endif /* XWAYLAND_WINDOW_H */
diff --git a/hw/xwayland/xwayland.c b/hw/xwayland/xwayland.c
new file mode 100644
index 000000000..9a1f4a6da
--- /dev/null
+++ b/hw/xwayland/xwayland.c
@@ -0,0 +1,447 @@
+/*
+ * Copyright © 2011-2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include <xwayland-config.h>
+
+#if !defined(SYSV) && !defined(WIN32)
+#include <sys/resource.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+
+#include <X11/Xatom.h>
+#include <selection.h>
+#include <micmap.h>
+#include <misyncshm.h>
+#include <compositeext.h>
+#include <compint.h>
+#include <glx_extinit.h>
+#include <opaque.h>
+#include <os.h>
+#include <xserver_poll.h>
+#include <propertyst.h>
+#include <version-config.h>
+
+#include "xwayland-screen.h"
+#include "xwayland-vidmode.h"
+
+#ifdef XF86VIDMODE
+#include <X11/extensions/xf86vmproto.h>
+extern _X_EXPORT Bool noXFree86VidModeExtension;
+#endif
+
+void
+ddxGiveUp(enum ExitCode error)
+{
+}
+
+void
+OsVendorInit(void)
+{
+    if (serverGeneration == 1)
+        ForceClockId(CLOCK_MONOTONIC);
+}
+
+void
+OsVendorFatalError(const char *f, va_list args)
+{
+}
+
+#if defined(DDXBEFORERESET)
+void
+ddxBeforeReset(void)
+{
+    return;
+}
+#endif
+
+#if INPUTTHREAD
+/** This function is called in Xserver/os/inputthread.c when starting
+    the input thread. */
+void
+ddxInputThreadInit(void)
+{
+}
+#endif
+
+void
+ddxUseMsg(void)
+{
+    ErrorF("-rootless              run rootless, requires wm support\n");
+    ErrorF("-fullscreen            run fullscreen when rootful\n");
+    ErrorF("-geometry WxH          set Xwayland window size when rootful\n");
+    ErrorF("-host-grab             disable host keyboard shortcuts when rootful\n");
+    ErrorF("-wm fd                 create X client for wm on given fd\n");
+    ErrorF("-initfd fd             add given fd as a listen socket for initialization clients\n");
+    ErrorF("-listenfd fd           add given fd as a listen socket\n");
+    ErrorF("-listen fd             deprecated, use \"-listenfd\" instead\n");
+#ifdef XWL_HAS_EGLSTREAM
+    ErrorF("-eglstream             use eglstream backend for nvidia GPUs\n");
+#endif
+    ErrorF("-shm                   use shared memory for passing buffers\n");
+    ErrorF("-verbose [n]           verbose startup messages\n");
+    ErrorF("-version               show the server version and exit\n");
+    ErrorF("-noTouchPointerEmulation  disable touch pointer emulation\n");
+    ErrorF("-force-xrandr-emulation   force non-native modes to be exposed when viewporter is not exposed by the compositor\n");
+#ifdef XWL_HAS_LIBDECOR
+    ErrorF("-decorate              add decorations to Xwayland when rootful (experimental)\n");
+#endif
+}
+
+static int init_fd = -1;
+static int wm_fd = -1;
+static int listen_fds[5] = { -1, -1, -1, -1, -1 };
+static int listen_fd_count = 0;
+static int verbosity = 0;
+
+static void
+xwl_show_version(void)
+{
+    ErrorF("%s Xwayland %s (%d)\n", VENDOR_NAME, VENDOR_MAN_VERSION, VENDOR_RELEASE);
+    ErrorF("X Protocol Version %d, Revision %d\n", X_PROTOCOL, X_PROTOCOL_REVISION);
+#if defined(BUILDERSTRING)
+    if (strlen(BUILDERSTRING))
+        ErrorF("%s\n", BUILDERSTRING);
+#endif
+}
+
+static void
+try_raising_nofile_limit(void)
+{
+#ifdef RLIMIT_NOFILE
+    struct rlimit rlim;
+
+    /* Only fiddle with the limit if not set explicitly from the command line */
+    if (limitNoFile >= 0)
+        return;
+
+    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {
+        ErrorF("Failed to get the current nofile limit: %s\n", strerror(errno));
+        return;
+    }
+
+    rlim.rlim_cur = rlim.rlim_max;
+
+    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
+        ErrorF("Failed to set the current nofile limit: %s\n", strerror(errno));
+        return;
+    }
+
+    LogMessageVerb(X_INFO, 3, "Raising the file descriptors limit to %li\n",
+                   rlim.rlim_max);
+#endif
+}
+
+static void
+xwl_add_listen_fd(int argc, char *argv[], int i)
+{
+    NoListenAll = TRUE;
+    if (listen_fd_count == ARRAY_SIZE(listen_fds))
+        FatalError("Too many -listen arguments given, max is %zu\n",
+                   ARRAY_SIZE(listen_fds));
+
+    listen_fds[listen_fd_count++] = atoi(argv[i + 1]);
+}
+
+int
+ddxProcessArgument(int argc, char *argv[], int i)
+{
+    if (strcmp(argv[i], "-rootless") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-listen") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+
+        /* Not an FD */
+        if (!isdigit(*argv[i + 1]))
+            return 0;
+
+        LogMessageVerb(X_WARNING, 0, "Option \"-listen\" for file descriptors is deprecated\n"
+                                     "Please use \"-listenfd\" instead.\n");
+
+        xwl_add_listen_fd (argc, argv, i);
+        return 2;
+    }
+    else if (strcmp(argv[i], "-listenfd") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+
+        xwl_add_listen_fd (argc, argv, i);
+        return 2;
+    }
+    else if (strcmp(argv[i], "-wm") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+        wm_fd = atoi(argv[i + 1]);
+        return 2;
+    }
+    else if (strcmp(argv[i], "-initfd") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+        init_fd = atoi(argv[i + 1]);
+        return 2;
+    }
+    else if (strcmp(argv[i], "-shm") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-verbose") == 0) {
+        if (++i < argc && argv[i]) {
+            char *end;
+            long val;
+
+            val = strtol(argv[i], &end, 0);
+            if (*end == '\0') {
+                verbosity = val;
+                LogSetParameter(XLOG_VERBOSITY, verbosity);
+                return 2;
+            }
+        }
+        LogSetParameter(XLOG_VERBOSITY, ++verbosity);
+        return 1;
+    }
+    else if (strcmp(argv[i], "-eglstream") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-version") == 0) {
+        xwl_show_version();
+        exit(0);
+    }
+    else if (strcmp(argv[i], "-noTouchPointerEmulation") == 0) {
+        touchEmulatePointer = FALSE;
+        return 1;
+    }
+    else if (strcmp(argv[i], "-force-xrandr-emulation") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-geometry") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+        return 2;
+    }
+    else if (strcmp(argv[i], "-fullscreen") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-host-grab") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-decorate") == 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+static CARD32
+add_client_fd(OsTimerPtr timer, CARD32 time, void *arg)
+{
+    if (!AddClientOnOpenFD(wm_fd))
+        FatalError("Failed to add wm client\n");
+
+    TimerFree(timer);
+
+    return 0;
+}
+
+static void
+listen_on_fds(void)
+{
+    int i;
+
+    for (i = 0; i < listen_fd_count; i++)
+        ListenOnOpenFD(listen_fds[i], FALSE);
+}
+
+static void
+wm_selection_callback(CallbackListPtr *p, void *data, void *arg)
+{
+    SelectionInfoRec *info = arg;
+    struct xwl_screen *xwl_screen = data;
+    static const char atom_name[] = "WM_S0";
+    static Atom atom_wm_s0;
+
+    if (atom_wm_s0 == None)
+        atom_wm_s0 = MakeAtom(atom_name, strlen(atom_name), TRUE);
+    if (info->selection->selection != atom_wm_s0 ||
+        info->kind != SelectionSetOwner)
+        return;
+
+    listen_on_fds();
+
+    DeleteCallback(&SelectionCallback, wm_selection_callback, xwl_screen);
+}
+
+_X_NORETURN
+static void _X_ATTRIBUTE_PRINTF(1, 0)
+xwl_log_handler(const char *format, va_list args)
+{
+    char msg[256];
+
+    vsnprintf(msg, sizeof msg, format, args);
+    FatalError("%s", msg);
+}
+
+#ifdef XWL_HAS_XWAYLAND_EXTENSION
+#include <X11/extensions/xwaylandproto.h>
+
+Bool noXWaylandExtension = FALSE;
+
+static int
+ProcXwlQueryVersion(ClientPtr client)
+{
+    xXwlQueryVersionReply reply;
+    int major, minor;
+
+    REQUEST(xXwlQueryVersionReq);
+    REQUEST_SIZE_MATCH(xXwlQueryVersionReq);
+
+    if (version_compare(stuff->majorVersion, stuff->minorVersion,
+                        XWAYLAND_EXTENSION_MAJOR,
+                        XWAYLAND_EXTENSION_MINOR) < 0) {
+        major = stuff->majorVersion;
+        minor = stuff->minorVersion;
+    } else {
+        major = XWAYLAND_EXTENSION_MAJOR;
+        minor = XWAYLAND_EXTENSION_MINOR;
+    }
+
+    reply = (xXwlQueryVersionReply) {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0,
+        .majorVersion = major,
+        .minorVersion = minor,
+    };
+
+    if (client->swapped) {
+        swaps(&reply.sequenceNumber);
+        swapl(&reply.length);
+        swaps(&reply.majorVersion);
+        swaps(&reply.minorVersion);
+    }
+
+    WriteReplyToClient(client, sizeof(reply), &reply);
+    return Success;
+}
+
+static int _X_COLD
+SProcXwlQueryVersion(ClientPtr client)
+{
+    REQUEST(xXwlQueryVersionReq);
+
+    swaps(&stuff->length);
+    REQUEST_AT_LEAST_SIZE(xXwlQueryVersionReq);
+    swaps(&stuff->majorVersion);
+    swaps(&stuff->minorVersion);
+
+    return ProcXwlQueryVersion(client);
+}
+
+static int
+ProcXWaylandDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+
+    switch (stuff->data) {
+    case X_XwlQueryVersion:
+        return ProcXwlQueryVersion(client);
+    }
+    return BadRequest;
+}
+
+static int
+SProcXWaylandDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+
+    switch (stuff->data) {
+    case X_XwlQueryVersion:
+        return SProcXwlQueryVersion(client);
+    }
+    return BadRequest;
+}
+
+static void
+xwlExtensionInit(void)
+{
+    AddExtension(XWAYLAND_EXTENSION_NAME,
+                 XwlNumberEvents, XwlNumberErrors,
+                 ProcXWaylandDispatch, SProcXWaylandDispatch,
+                 NULL, StandardMinorOpcode);
+}
+
+#endif
+
+static const ExtensionModule xwayland_extensions[] = {
+#ifdef XF86VIDMODE
+    { xwlVidModeExtensionInit, XF86VIDMODENAME, &noXFree86VidModeExtension },
+#endif
+#ifdef XWL_HAS_XWAYLAND_EXTENSION
+    { xwlExtensionInit, XWAYLAND_EXTENSION_NAME, &noXWaylandExtension },
+#endif
+};
+
+void
+InitOutput(ScreenInfo * screen_info, int argc, char **argv)
+{
+    int depths[] = { 1, 4, 8, 15, 16, 24, 32 };
+    int bpp[] =    { 1, 8, 8, 16, 16, 32, 32 };
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(depths); i++) {
+        screen_info->formats[i].depth = depths[i];
+        screen_info->formats[i].bitsPerPixel = bpp[i];
+        screen_info->formats[i].scanlinePad = BITMAP_SCANLINE_PAD;
+    }
+
+    screen_info->imageByteOrder = IMAGE_BYTE_ORDER;
+    screen_info->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
+    screen_info->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
+    screen_info->bitmapBitOrder = BITMAP_BIT_ORDER;
+    screen_info->numPixmapFormats = ARRAY_SIZE(depths);
+
+    if (serverGeneration == 1) {
+        try_raising_nofile_limit();
+        LoadExtensionList(xwayland_extensions,
+                          ARRAY_SIZE(xwayland_extensions), FALSE);
+    }
+
+    wl_log_set_handler_client(xwl_log_handler);
+
+    if (AddScreen(xwl_screen_init, argc, argv) == -1) {
+        FatalError("Couldn't add screen\n");
+    }
+
+    xorgGlxCreateVendor();
+
+    LocalAccessScopeUser();
+
+    if (wm_fd >= 0 || init_fd >= 0) {
+        if (wm_fd >= 0)
+            TimerSet(NULL, 0, 1, add_client_fd, NULL);
+        if (init_fd >= 0)
+            ListenOnOpenFD(init_fd, FALSE);
+        AddCallback(&SelectionCallback, wm_selection_callback, NULL);
+    }
+    else if (listen_fd_count > 0) {
+        listen_on_fds();
+    }
+}
diff --git a/hw/xwayland/xwayland.pc.in b/hw/xwayland/xwayland.pc.in
new file mode 100644
index 000000000..d65d52e51
--- /dev/null
+++ b/hw/xwayland/xwayland.pc.in
@@ -0,0 +1,20 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+
+Name: Xwayland
+Description: X Server for Wayland
+Version: @PACKAGE_VERSION@
+xwayland=@xwayland_path@/Xwayland
+have_glamor=@have_glamor@
+have_eglstream=@have_eglstream@
+have_initfd=true
+have_listenfd=true
+have_verbose=true
+have_terminate_delay=true
+have_no_touch_pointer_emulation=true
+have_force_xrandr_emulation=true
+have_geometry=true
+have_fullscreen=true
+have_host_grab=true
+have_decorate=@have_libdecor@
+have_byteswappedclients=true
diff --git a/hw/xwin/Makefile.am b/hw/xwin/Makefile.am
deleted file mode 100644
index 75c2b2058..000000000
--- a/hw/xwin/Makefile.am
+++ /dev/null
@@ -1,162 +0,0 @@
-bin_PROGRAMS = XWin
-
-SRCS_CLIPBOARD = \
-	winclipboardinit.c \
-	winclipboardwrappers.c
-CLIPBOARD_LIBS = $(top_builddir)/hw/xwin/winclipboard/libXWinclipboard.la
-
-if XWIN_GLX_WINDOWS
-GLX_DIR =
-DEFS_GLX_WINDOWS =
-XWIN_GLX_LIBS =
-if XWIN_WINDOWS_DRI
-GLX_DIR += dri
-DEFS_GLX_WINDOWS += -DXWIN_WINDOWS_DRI
-XWIN_GLX_LIBS += $(top_builddir)/hw/xwin/dri/libWindowsDRI.la
-endif
-GLX_DIR += glx
-DEFS_GLX_WINDOWS += -DXWIN_GLX_WINDOWS
-XWIN_GLX_LIBS += $(top_builddir)/hw/xwin/glx/libXwinGLX.la
-XWIN_GLX_SYS_LIBS = -lopengl32
-endif
-
-SRCS_MULTIWINDOW = \
-	winmultiwindowshape.c \
-	winmultiwindowwindow.c \
-	winmultiwindowwm.c \
-	winmultiwindowwndproc.c \
-	propertystore.h \
-	winSetAppUserModelID.c
-MULTIWINDOW_SYS_LIBS = -lshlwapi -lole32 -ldwmapi
-
-SRCS_RANDR = \
-	winrandr.c
-
-SRCS =	InitInput.c \
-	InitOutput.c \
-	winallpriv.c \
-	winauth.c \
-	winblock.c \
-	wincmap.c \
-	winconfig.c \
-	wincreatewnd.c \
-	wincursor.c \
-	windialogs.c \
-	winengine.c \
-	winerror.c \
-	winglobals.c \
-	winkeybd.c \
-	winkeyhook.c \
-	winmisc.c \
-	winmonitors.c \
-	winmouse.c \
-	winmsg.c \
-	winmsgwindow.c \
-	winmultiwindowclass.c \
-	winmultiwindowicons.c \
-	winos.c \
-	winprefs.c \
-	winprefsyacc.y \
-	winprefslex.l \
-	winprocarg.c \
-	winscrinit.c \
-	winshadddnl.c \
-	winshadgdi.c \
-	wintaskbar.c \
-	wintrayicon.c \
-	winvalargs.c \
-	winwakeup.c \
-	winwindow.c \
-	winwndproc.c \
-	ddraw.h \
-	winconfig.h \
-	win.h \
-	winglobals.h \
-	winkeybd.h \
-	winkeynames.h \
-	winlayouts.h \
-	winmessages.h \
-	winmonitors.h \
-	winmsg.h \
-	winms.h \
-	winmultiwindowclass.h \
-	winmultiwindowicons.h \
-	winprefs.h \
-	winresource.h \
-	winwindow.h \
-	windisplay.c \
-	windisplay.h \
-	XWin.rc \
-	$(top_srcdir)/mi/miinitext.c \
-	$(top_srcdir)/mi/miinitext.h \
-	$(SRCS_CLIPBOARD) \
-	$(SRCS_MULTIWINDOW) \
-	$(SRCS_RANDR)
-
-DEFS = \
-	$(DEFS_GLX_WINDOWS) \
-	$(DEFS_MULTIWINDOWEXTWM)
-
-XWin_SOURCES = $(SRCS)
-
-XWIN_SYS_LIBS += -ldxguid
-
-XWIN_LIBS += \
-	$(top_builddir)/pseudoramiX/libPseudoramiX.la \
-	$(top_builddir)/Xi/libXistubs.la
-
-XWin_DEPENDENCIES = \
-	$(XWIN_GLX_LIBS) \
-	$(XWIN_LIBS) \
-	$(CLIPBOARD_LIBS) \
-	$(XSERVER_LIBS)
-
-
-XWin_LDADD = \
-	$(XWIN_GLX_LIBS) \
-	$(XWIN_LIBS) \
-	$(CLIPBOARD_LIBS) \
-	$(XSERVER_LIBS) \
-	$(XWIN_GLX_SYS_LIBS) \
-	$(XSERVER_SYS_LIBS) \
-	$(XWIN_SYS_LIBS) \
-	$(MULTIWINDOW_SYS_LIBS)
-
-XWin_LDFLAGS = -mwindows -Wl,--disable-stdcall-fixup $(LD_EXPORT_SYMBOLS_FLAG)
-
-
-.rc.o:
-	$(AM_V_GEN)$(WINDRES) --use-temp-file -i $< --input-format=rc -o $@ -O coff -I $(top_builddir)/include
-
-XWin.o: XWin.rc XWin.exe.manifest X.ico
-
-winprefsyacc.h: winprefsyacc.c
-winprefslex.c: winprefslex.l winprefsyacc.c winprefsyacc.h
-
-BUILT_SOURCES = winprefsyacc.h winprefsyacc.c winprefslex.c
-CLEANFILES = $(BUILT_SOURCES)
-
-AM_YFLAGS = -d
-AM_LFLAGS = -i
-AM_CFLAGS = -DHAVE_XWIN_CONFIG_H $(DIX_CFLAGS) \
-            $(XWINMODULES_CFLAGS) \
-            -I$(top_srcdir) \
-            -Wno-bad-function-cast
-
-xwinconfigdir = $(sysconfdir)/X11
-xwinconfig_DATA = system.XWinrc
-
-install-exec-hook:
-	(cd $(DESTDIR)$(bindir) && rm -f X && $(LN_S) XWin$(EXEEXT) X)
-
-EXTRA_DIST = \
-	$(xwinconfig_DATA) \
-	X.ico \
-	XWin.rc \
-	XWin.exe.manifest
-
-relink:
-	$(AM_V_at)rm -f XWin$(EXEEXT) && $(MAKE) XWin$(EXEEXT)
-
-SUBDIRS = man $(GLX_DIR) winclipboard .
-DIST_SUBDIRS = man dri glx winclipboard .
diff --git a/hw/xwin/dri/Makefile.am b/hw/xwin/dri/Makefile.am
deleted file mode 100644
index 948c2b5c6..000000000
--- a/hw/xwin/dri/Makefile.am
+++ /dev/null
@@ -1,9 +0,0 @@
-noinst_LTLIBRARIES = libWindowsDRI.la
-
-libWindowsDRI_la_SOURCES = \
-	windowsdri.c \
-	windowsdri.h
-
-AM_CFLAGS =  $(DIX_CFLAGS) \
-	     @WINDOWSDRI_CFLAGS@ \
-	     -I$(top_srcdir)/hw/xwin/
diff --git a/hw/xwin/glx/Makefile.am b/hw/xwin/glx/Makefile.am
deleted file mode 100644
index ae9debe5c..000000000
--- a/hw/xwin/glx/Makefile.am
+++ /dev/null
@@ -1,64 +0,0 @@
-noinst_LTLIBRARIES = libXwinGLX.la
-lib_LTLIBRARIES = libnativeGLthunk.la
-
-libXwinGLX_la_SOURCES = \
-	winpriv.c \
-	winpriv.h \
-	glwindows.h \
-	glshim.c \
-	indirect.c \
-	indirect.h \
-	wgl_ext_api.c \
-	wgl_ext_api.h
-
-if XWIN_WINDOWS_DRI
-libXwinGLX_la_SOURCES += \
-	dri_helpers.c \
-	dri_helpers.h
-endif
-
-libnativeGLthunk_la_SOURCES = \
-	glthunk.c
-
-if XWIN_GLX_WINDOWS
-DEFS_GLX_WINDOWS = -DXWIN_GLX_WINDOWS
-endif
-
-DEFS = \
-	$(DEFS_GLX_WINDOWS)
-
-AM_CFLAGS = -DHAVE_XWIN_CONFIG_H $(DIX_CFLAGS) \
-            $(XWINMODULES_CFLAGS) \
-            -I$(top_srcdir) \
-            -I$(top_srcdir)/hw/xwin/
-
-libnativeGLthunk_la_CFLAGS = $(AM_CFLAGS) -Wno-unused-function -Wno-missing-prototypes -Wno-missing-declarations
-libnativeGLthunk_la_LDFLAGS = -shared -no-undefined -avoid-version -lopengl32 -export-symbols generated_gl_thunks.def
-EXTRA_libnativeGLthunk_la_DEPENDENCIES = generated_gl_thunks.def
-
-if XWIN_GLX_WINDOWS
-
-if DEBUG
-GENGLWRAPPERSOPTS=""
-else
-GENGLWRAPPERSOPTS="-nodebug"
-endif
-
-generated_wgl_wrappers.ic: $(srcdir)/gen_gl_wrappers.py $(KHRONOS_SPEC_DIR)/wgl.xml $(KHRONOS_SPEC_DIR)/reg.py
-	$(AM_V_GEN)PYTHONPATH=$(KHRONOS_SPEC_DIR) $(PYTHON3) $(srcdir)/gen_gl_wrappers.py -registry $(KHRONOS_SPEC_DIR)/wgl.xml -prefix wgl -wrapper -preresolve $(GENGLWRAPPERSOPTS) -outfile $@
-
-generated_gl_shim.ic: $(srcdir)/gen_gl_wrappers.py $(KHRONOS_SPEC_DIR)/gl.xml $(KHRONOS_SPEC_DIR)/reg.py
-	$(AM_V_GEN)PYTHONPATH=$(KHRONOS_SPEC_DIR) $(PYTHON3) $(srcdir)/gen_gl_wrappers.py -registry $(KHRONOS_SPEC_DIR)/gl.xml -shim $(GENGLWRAPPERSOPTS) -outfile $@
-
-generated_gl_thunks.ic: $(srcdir)/gen_gl_wrappers.py $(KHRONOS_SPEC_DIR)/gl.xml $(KHRONOS_SPEC_DIR)/reg.py
-	$(AM_V_GEN)PYTHONPATH=$(KHRONOS_SPEC_DIR) $(PYTHON3) $(srcdir)/gen_gl_wrappers.py -registry $(KHRONOS_SPEC_DIR)/gl.xml -thunk $(GENGLWRAPPERSOPTS) -outfile $@
-
-generated_gl_thunks.def: $(srcdir)/gen_gl_wrappers.py $(KHRONOS_SPEC_DIR)/gl.xml $(KHRONOS_SPEC_DIR)/reg.py
-	$(AM_V_GEN)PYTHONPATH=$(KHRONOS_SPEC_DIR) $(PYTHON3) $(srcdir)/gen_gl_wrappers.py -registry $(KHRONOS_SPEC_DIR)/gl.xml -thunkdefs $(GENGLWRAPPERSOPTS) -outfile $@
-
-BUILT_SOURCES = generated_gl_shim.ic generated_gl_thunks.ic generated_gl_thunks.def generated_wgl_wrappers.ic
-CLEANFILES = $(BUILT_SOURCES)
-
-endif
-
-EXTRA_DIST = gen_gl_wrappers.py
diff --git a/hw/xwin/glx/gen_gl_wrappers.py b/hw/xwin/glx/gen_gl_wrappers.py
index b9e8dda75..256f2d752 100755
--- a/hw/xwin/glx/gen_gl_wrappers.py
+++ b/hw/xwin/glx/gen_gl_wrappers.py
@@ -24,7 +24,7 @@
 # TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 # MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
 
-import sys, time, pdb, string, cProfile
+import sys
 from reg import *
 
 # Default input / log files
diff --git a/hw/xwin/glx/indirect.c b/hw/xwin/glx/indirect.c
index ff015f763..e34437ace 100644
--- a/hw/xwin/glx/indirect.c
+++ b/hw/xwin/glx/indirect.c
@@ -1134,7 +1134,7 @@ glxWinSetPixelFormat(HDC hdc, int bppOverride, int drawableTypeOverride,
                     winConfig->pixelFormatIndex);
 
     /*
-       Normally, we can just use the the pixelFormatIndex corresponding
+       Normally, we can just use the pixelFormatIndex corresponding
        to the fbconfig which has been specified by the client
      */
 
diff --git a/hw/xwin/man/Makefile.am b/hw/xwin/man/Makefile.am
deleted file mode 100644
index d19c2729f..000000000
--- a/hw/xwin/man/Makefile.am
+++ /dev/null
@@ -1,3 +0,0 @@
-include $(top_srcdir)/manpages.am
-appman_PRE = XWin.man
-fileman_PRE = XWinrc.man
diff --git a/hw/xwin/meson.build b/hw/xwin/meson.build
index e9940ccc3..546777c64 100644
--- a/hw/xwin/meson.build
+++ b/hw/xwin/meson.build
@@ -107,7 +107,11 @@ srcs_windows += [
     '../../mi/miinitext.h',
 ]
 
-rsrc = windows.compile_resources('XWin.rc', include_directories: include_directories('../../include/'))
+rsrc = windows.compile_resources(
+     'XWin.rc',
+     include_directories: include_directories('../../include/'),
+     depend_files: ['XWin.exe.manifest', 'X.ico'],
+)
 srcs_windows += rsrc
 
 flex = find_program('flex')
diff --git a/hw/xwin/winclipboard/Makefile.am b/hw/xwin/winclipboard/Makefile.am
deleted file mode 100644
index bfd302413..000000000
--- a/hw/xwin/winclipboard/Makefile.am
+++ /dev/null
@@ -1,26 +0,0 @@
-noinst_LTLIBRARIES = libXWinclipboard.la
-
-libXWinclipboard_la_SOURCES = \
-	internal.h \
-	winclipboard.h \
-	textconv.c \
-	thread.c \
-	wndproc.c \
-	xevents.c
-
-libXWinclipboard_la_CFLAGS = -DHAVE_XWIN_CONFIG_H \
-			     $(DIX_CFLAGS) \
-			     $(XWINMODULES_CFLAGS)
-
-libXWinclipboard_la_LDFLAGS = -static -no-undefined
-
-bin_PROGRAMS = xwinclip
-
-xwinclip_SOURCES = xwinclip.c debug.c
-
-xwinclip_CFLAGS = $(XWINMODULES_CFLAGS)
-
-xwinclip_LDADD = libXWinclipboard.la $(XWINMODULES_LIBS) -lgdi32 -lpthread
-
-include $(top_srcdir)/manpages.am
-appman_PRE = xwinclip.man
diff --git a/hw/xwin/winclipboard/meson.build b/hw/xwin/winclipboard/meson.build
index 2a46c670e..8db06a485 100644
--- a/hw/xwin/winclipboard/meson.build
+++ b/hw/xwin/winclipboard/meson.build
@@ -28,6 +28,7 @@ srcs_xwinclip = [
 executable(
     'xwinclip',
     srcs_xwinclip,
+    dependencies: dependency('xcb'),
     link_with: xwin_clipboard,
     link_args: ['-lgdi32', '-lpthread'],
     install: true,
diff --git a/include/Makefile.am b/include/Makefile.am
deleted file mode 100644
index 25b3a9033..000000000
--- a/include/Makefile.am
+++ /dev/null
@@ -1,96 +0,0 @@
-if XORG
-sdk_HEADERS =		\
-	XIstubs.h	\
-	Xprintf.h	\
-	callback.h	\
-	client.h	\
-	closestr.h	\
-	closure.h	\
-	colormap.h	\
-	colormapst.h	\
-	hotplug.h	\
-	cursor.h	\
-	cursorstr.h	\
-	dix.h		\
-	dixaccess.h	\
-	dixevents.h	\
-	dixfont.h	\
-	dixfontstr.h	\
-	dixgrabs.h	\
-	dixstruct.h	\
-	events.h	\
-	exevents.h	\
-	extension.h	\
-	extinit.h	\
-	extnsionst.h	\
-	fourcc.h	\
-	gc.h		\
-	gcstruct.h	\
-	globals.h	\
-	glx_extinit.h	\
-	glxvndabi.h	\
-	input.h		\
-	inputstr.h	\
-	list.h		\
-	misc.h		\
-	miscstruct.h	\
-	opaque.h	\
-	nonsdk_extinit.h	\
-	optionstr.h	\
-	os.h		\
-	pixmap.h	\
-	pixmapstr.h	\
-	privates.h	\
-	property.h	\
-	propertyst.h	\
-	ptrveloc.h  \
-	region.h	\
-	regionstr.h	\
-	registry.h	\
-	resource.h	\
-	rgb.h		\
-	screenint.h	\
-	scrnintstr.h	\
-	selection.h	\
-	servermd.h	\
-	validate.h	\
-	displaymode.h    \
-	window.h	\
-	windowstr.h	\
-	xkbfile.h	\
-	xkbsrv.h	\
-	xkbstr.h        \
-	xkbrules.h      \
-	xserver_poll.h	\
-	xserver-properties.h
-
-nodist_sdk_HEADERS = xorg-server.h
-endif
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-EXTRA_DIST = 	\
-	busfault.h dbus-core.h \
-	dix-config-apple-verbatim.h \
-	eventconvert.h eventstr.h inpututils.h \
-	probes.h \
-	protocol-versions.h \
-	swaprep.h \
-	swapreq.h \
-	systemd-logind.h \
-        vidmodestr.h \
-	xorg-config.h.meson.in \
-	xorg-server.h.meson.in \
-	xwin-config.h.meson.in \
-	xsha1.h \
-	Xserver.d
-
-if XSERVER_DTRACE
-# Generate dtrace header file for C sources to include
-BUILT_SOURCES = Xserver-dtrace.h
-
-Xserver-dtrace.h: $(srcdir)/Xserver.d
-	$(AM_V_GEN)$(DTRACE) -C -h -o $@ -s $(srcdir)/Xserver.d
-endif
-
-CLEANFILES = Xserver-dtrace.h
diff --git a/include/dix-config.h.in b/include/dix-config.h.in
deleted file mode 100644
index 382d70609..000000000
--- a/include/dix-config.h.in
+++ /dev/null
@@ -1,521 +0,0 @@
-/* dix-config.h.in: not at all generated.                      -*- c -*- */
-
-#ifndef _DIX_CONFIG_H_
-#define _DIX_CONFIG_H_
-
-/* Support BigRequests extension */
-#undef BIGREQS
-
-/* Builder address */
-#undef BUILDERADDR
-
-/* Builder string */
-#undef BUILDERSTRING
-
-/* Default font path */
-#undef COMPILEDDEFAULTFONTPATH
-
-/* Miscellaneous server configuration files path */
-#undef SERVER_MISC_CONFIG_PATH
-
-/* Support Composite Extension */
-#undef COMPOSITE
-
-/* Support Damage extension */
-#undef DAMAGE
-
-/* Use OsVendorVErrorF */
-#undef DDXOSVERRORF
-
-/* Use ddxBeforeReset */
-#undef DDXBEFORERESET
-
-/* Build DPMS extension */
-#undef DPMSExtension
-
-/* Build DRI3 extension */
-#undef DRI3
-
-/* Build GLX extension */
-#undef GLXEXT
-
-/* Build GLX DRI loader */
-#undef GLX_DRI
-
-/* Path to DRI drivers */
-#undef DRI_DRIVER_PATH
-
-/* Support XDM-AUTH*-1 */
-#undef HASXDMAUTH
-
-/* Support SHM */
-#undef HAS_SHM
-
-/* Has backtrace support */
-#undef HAVE_BACKTRACE
-
-/* Has libunwind support */
-#undef HAVE_LIBUNWIND
-
-/* Define to 1 if you have the `cbrt' function. */
-#undef HAVE_CBRT
-
-/* Define to 1 if you have the declaration of `program_invocation_short_name', and
-   to 0 if you don't. */
-#undef HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_DIRENT_H
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
-/* Have execinfo.h */
-#undef HAVE_EXECINFO_H
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#undef HAVE_FCNTL_H
-
-/* Define to 1 if you have the `getdtablesize' function. */
-#undef HAVE_GETDTABLESIZE
-
-/* Define to 1 if you have the `getifaddrs' function. */
-#undef HAVE_GETIFADDRS
-
-/* Define to 1 if you have the `getpeereid' function. */
-#undef HAVE_GETPEEREID
-
-/* Define to 1 if you have the `getpeerucred' function. */
-#undef HAVE_GETPEERUCRED
-
-/* Define to 1 if you have the `getprogname' function. */
-#undef HAVE_GETPROGNAME
-
-/* Define to 1 if you have the `getzoneid' function. */
-#undef HAVE_GETZONEID
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Have Quartz */
-#undef XQUARTZ
-
-/* Support application updating through sparkle. */
-#undef XQUARTZ_SPARKLE
-
-/* Prefix to use for bundle identifiers */
-#undef BUNDLE_ID_PREFIX
-
-/* Build a standalone xpbproxy */
-#undef STANDALONE_XPBPROXY
-
-/* Define to 1 if you have the `bsd' library (-lbsd). */
-#undef HAVE_LIBBSD
-
-/* Define to 1 if you have the `m' library (-lm). */
-#undef HAVE_LIBM
-
-/* Define to 1 if you have the <linux/agpgart.h> header file. */
-#undef HAVE_LINUX_AGPGART_H
-
-/* Define to 1 if you have the <linux/apm_bios.h> header file. */
-#undef HAVE_LINUX_APM_BIOS_H
-
-/* Define to 1 if you have the <linux/fb.h> header file. */
-#undef HAVE_LINUX_FB_H
-
-/* Define to 1 if you have the `memfd_create' function. */
-#undef HAVE_MEMFD_CREATE
-
-/* Define to 1 if you have the `mkostemp' function. */
-#undef HAVE_MKOSTEMP
-
-/* Define to 1 if you have the `mmap' function. */
-#undef HAVE_MMAP
-
-/* Define to 1 if you have the function pthread_setname_np(const char*) */
-#undef HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID
-
-/* Define to 1 if you have the function pthread_setname_np(pthread_t, const char*) */
-#undef HAVE_PTHREAD_SETNAME_NP_WITH_TID
-
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
-#undef HAVE_NDIR_H
-
-/* Define to 1 if you have the `reallocarray' function. */
-#undef HAVE_REALLOCARRAY
-
-/* Define to 1 if you have the `arc4random_buf' function. */
-#undef HAVE_ARC4RANDOM_BUF
-
-/* Define to use libc SHA1 functions */
-#undef HAVE_SHA1_IN_LIBC
-
-/* Define to use CommonCrypto SHA1 functions */
-#undef HAVE_SHA1_IN_COMMONCRYPTO
-
-/* Define to use CryptoAPI SHA1 functions */
-#undef HAVE_SHA1_IN_CRYPTOAPI
-
-/* Define to use libmd SHA1 functions */
-#undef HAVE_SHA1_IN_LIBMD
-
-/* Define to use libgcrypt SHA1 functions */
-#undef HAVE_SHA1_IN_LIBGCRYPT
-
-/* Define to use libnettle SHA1 functions */
-#undef HAVE_SHA1_IN_LIBNETTLE
-
-/* Define to use libsha1 for SHA1 */
-#undef HAVE_SHA1_IN_LIBSHA1
-
-/* Define to 1 if you have the `shmctl64' function. */
-#undef HAVE_SHMCTL64
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strcasecmp' function. */
-#undef HAVE_STRCASECMP
-
-/* Define to 1 if you have the `strcasestr' function. */
-#undef HAVE_STRCASESTR
-
-/* Define to 1 if you have the `strncasecmp' function. */
-#undef HAVE_STRNCASECMP
-
-/* Define to 1 if you have the `strlcat' function. */
-#undef HAVE_STRLCAT
-
-/* Define to 1 if you have the `strlcpy' function. */
-#undef HAVE_STRLCPY
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strndup' function. */
-#undef HAVE_STRNDUP
-
-/* Define to 1 if libsystemd-daemon is available */
-#undef HAVE_SYSTEMD_DAEMON
-
-/* Define to 1 if SYSV IPC is available */
-#undef HAVE_SYSV_IPC
-
-/* Define to 1 if you have the <sys/agpio.h> header file. */
-#undef HAVE_SYS_AGPIO_H
-
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_DIR_H
-
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_NDIR_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <sys/utsname.h> header file. */
-#undef HAVE_SYS_UTSNAME_H
-
-/* Define to 1 if you have the `timingsafe_memcmp' function. */
-#undef HAVE_TIMINGSAFE_MEMCMP
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to 1 if you have the <fnmatch.h> header file. */
-#undef HAVE_FNMATCH_H
-
-/* Have /dev/urandom */
-#undef HAVE_URANDOM
-
-/* Define to 1 if you have the `vasprintf' function. */
-#undef HAVE_VASPRINTF
-
-/* Support IPv6 for TCP connections */
-#undef IPv6
-
-/* Support os-specific local connections */
-#undef LOCALCONN
-
-/* Support MIT-SHM Extension */
-#undef MITSHM
-
-/* Enable some debugging code */
-#undef DEBUG
-
-/* Name of package */
-#undef PACKAGE
-
-/* Internal define for Xinerama */
-#undef PANORAMIX
-
-/* Support Present extension */
-#undef PRESENT
-
-/* Overall prefix */
-#undef PROJECTROOT
-
-/* Support RANDR extension */
-#undef RANDR
-
-/* Support Record extension */
-#undef XRECORD
-
-/* Support RENDER extension */
-#undef RENDER
-
-/* Support X resource extension */
-#undef RES
-
-/* Support client ID tracking in X resource extension */
-#undef CLIENTIDS
-
-/* Support MIT-SCREEN-SAVER extension */
-#undef SCREENSAVER
-
-/* Support Secure RPC ("SUN-DES-1") authentication for X11 clients */
-#undef SECURE_RPC
-
-/* Support SHAPE extension */
-#undef SHAPE
-
-/* Where to install Xorg.bin and Xorg.wrap */
-#undef SUID_WRAPPER_DIR
-
-/* Define to 1 on systems derived from System V Release 4 */
-#undef SVR4
-
-/* sysconfdir */
-#undef SYSCONFDIR
-
-/* Support TCP socket connections */
-#undef TCPCONN
-
-/* Support UNIX socket connections */
-#undef UNIXCONN
-
-/* Build X string registry */
-#undef XREGISTRY
-
-/* Build X-ACE extension */
-#undef XACE
-
-/* Build SELinux extension */
-#undef XSELINUX
-
-/* Support XCMisc extension */
-#undef XCMISC
-
-/* Build Security extension */
-#undef XCSECURITY
-
-/* Support Xdmcp */
-#undef XDMCP
-
-/* Build XFree86 BigFont extension */
-#undef XF86BIGFONT
-
-/* Support XFree86 Video Mode extension */
-#undef XF86VIDMODE
-
-/* Support XFixes extension */
-#undef XFIXES
-
-/* Build XDGA support */
-#undef XFreeXDGA
-
-/* Support Xinerama extension */
-#undef XINERAMA
-
-/* Current Xorg version */
-#undef XORG_VERSION_CURRENT
-
-/* Build Xv Extension */
-#undef XvExtension
-
-/* Build XvMC Extension */
-#undef XvMCExtension
-
-/* Support XSync extension */
-#undef XSYNC
-
-/* Support XTest extension */
-#undef XTEST
-
-/* Support Xv extension */
-#undef XV
-
-/* Support DRI extension */
-#undef XF86DRI
-
-/* Build DRI2 extension */
-#undef DRI2
-
-/* Build DBE support */
-#undef DBE
-
-/* Vendor name */
-#undef XVENDORNAME
-
-/* Number of bits in a file offset, on hosts where this is settable. */
-#undef _FILE_OFFSET_BITS
-
-/* Enable GNU and other extensions to the C environment for GLIBC */
-#undef _GNU_SOURCE
-
-/* Define for large files, on AIX-style hosts. */
-#undef _LARGE_FILES
-
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef pid_t
-
-/* Build Rootless code */
-#undef ROOTLESS
-
-/* Define to 1 if unsigned long is 64 bits. */
-#undef _XSERVER64
-
-/* System is BSD-like */
-#undef CSRG_BASED
-
-/* Define to 1 if `struct sockaddr_in' has a `sin_len' member */
-#undef BSD44SOCKETS
-
-/* Support D-Bus */
-#undef HAVE_DBUS
-
-/* Use libudev for input hotplug */
-#undef CONFIG_UDEV
-
-/* Use libudev for kms enumeration */
-#undef CONFIG_UDEV_KMS
-
-/* Use udev_monitor_filter_add_match_tag() */
-#undef HAVE_UDEV_MONITOR_FILTER_ADD_MATCH_TAG
-
-/* Use udev_enumerate_add_match_tag() */
-#undef HAVE_UDEV_ENUMERATE_ADD_MATCH_TAG
-
-/* Enable D-Bus core */
-#undef NEED_DBUS
-
-/* Support HAL for hotplug */
-#undef CONFIG_HAL
-
-/* Enable systemd-logind integration */
-#undef SYSTEMD_LOGIND 1
-
-/* Have a monotonic clock from clock_gettime() */
-#undef MONOTONIC_CLOCK
-
-/* Define to 1 if the DTrace Xserver provider probes should be built in */
-#undef XSERVER_DTRACE
-
-/* Define to 1 if typeof works with your compiler. */
-#undef HAVE_TYPEOF
-
-/* Define to __typeof__ if your compiler spells it that way. */
-#undef typeof
-
-/* Correctly set _XSERVER64 for OSX fat binaries */
-#ifdef __APPLE__
-#include "dix-config-apple-verbatim.h"
-#endif
-
-/* Enable general extensions on Solaris.  */
-#ifndef __EXTENSIONS__
-# undef __EXTENSIONS__
-#endif
-
-/* Defined if needed to expose struct msghdr.msg_control */
-#undef _XOPEN_SOURCE
-
-/* Have support for X shared memory fence library (xshmfence) */
-#undef HAVE_XSHMFENCE
-
-/* Use XTrans FD passing support */
-#undef XTRANS_SEND_FDS
-
-/* Wrap SIGBUS to catch MIT-SHM faults */
-#undef BUSFAULT
-
-/* Don't let Xdefs.h define 'pointer' */
-#define _XTYPEDEF_POINTER       1
-
-/* Don't let XIproto define 'Pointer' */
-#define _XITYPEDEF_POINTER      1
-
-/* Ask fontsproto to make font path element names const */
-#define FONT_PATH_ELEMENT_NAME_CONST    1
-
-/* Build GLAMOR */
-#undef GLAMOR
-
-/* Build glamor's GBM-based EGL support */
-#undef GLAMOR_HAS_GBM
-
-/* Build glamor/gbm has linear support */
-#undef GLAMOR_HAS_GBM_LINEAR
-
-/* GBM has modifiers support */
-#undef GBM_BO_WITH_MODIFIERS
-
-/* Glamor can use eglQueryDmaBuf* functions */
-#undef GLAMOR_HAS_EGL_QUERY_DMABUF
-
-/* Glamor can use EGL_MESA_query_driver functions */
-#undef GLAMOR_HAS_EGL_QUERY_DRIVER
-
-/* byte order */
-#undef X_BYTE_ORDER
-
-/* Listen on TCP socket */
-#undef LISTEN_TCP
-
-/* Listen on Unix socket */
-#undef LISTEN_UNIX
-
-/* Listen on local socket */
-#undef LISTEN_LOCAL
-
-/* Define if no local socket credentials interface exists */
-#undef NO_LOCAL_CLIENT_CRED
-
-/* Have setitimer support */
-#undef HAVE_SETITIMER
-
-/* Have posix_fallocate() */
-#undef HAVE_POSIX_FALLOCATE
-
-/* Use input thread */
-#undef INPUTTHREAD
-
-/* Have poll() */
-#undef HAVE_POLL
-
-/* Have epoll_create1() */
-#undef HAVE_EPOLL_CREATE1
-
-/* Have <sys/sysmacros.h> header */
-#undef HAVE_SYS_SYSMACROS_H
-
-/* Have sigprocmask */
-#undef HAVE_SIGPROCMASK
-
-/* Have isastream */
-#undef HAVE_ISASTREAM
-
-#endif /* _DIX_CONFIG_H_ */
diff --git a/include/meson.build b/include/meson.build
index 6b4a69dd4..e953dfa65 100644
--- a/include/meson.build
+++ b/include/meson.build
@@ -113,6 +113,8 @@ conf_data.set('GLAMOR_HAS_GBM_LINEAR',
               build_glamor and gbm_dep.found() and gbm_dep.version().version_compare('>= 10.6') ? '1' : false)
 conf_data.set('GBM_BO_WITH_MODIFIERS',
               build_glamor and gbm_dep.found() and gbm_dep.version().version_compare('>= 17.1') ? '1' : false)
+conf_data.set('GBM_BO_FD_FOR_PLANE',
+              build_glamor and gbm_dep.found() and gbm_dep.version().version_compare('>= 21.1') ? '1' : false)
 
 conf_data.set_quoted('SERVER_MISC_CONFIG_PATH', serverconfigdir)
 conf_data.set_quoted('PROJECTROOT', get_option('prefix'))
@@ -127,17 +129,13 @@ conf_data.set('SECURE_RPC', get_option('secure-rpc') ? '1' : false)
 
 conf_data.set('HAVE_DLFCN_H', cc.has_header('dlfcn.h') ? '1' : false)
 conf_data.set('HAVE_EXECINFO_H', cc.has_header('execinfo.h') ? '1' : false)
-conf_data.set('HAVE_FCNTL_H', cc.has_header('fcntl.h') ? '1' : false)
 conf_data.set('HAVE_FNMATCH_H', cc.has_header('fnmatch.h') ? '1' : false)
 conf_data.set('HAVE_LINUX_AGPGART_H', cc.has_header('linux/agpgart.h') ? '1' : false)
-conf_data.set('HAVE_STDLIB_H', cc.has_header('stdlib.h') ? '1' : false)
-conf_data.set('HAVE_STRING_H', cc.has_header('string.h') ? '1' : false)
 conf_data.set('HAVE_STRINGS_H', cc.has_header('strings.h') ? '1' : false)
 conf_data.set('HAVE_SYS_AGPGART_H', cc.has_header('sys/agpgart.h') ? '1' : false)
-conf_data.set('HAVE_SYS_AGPIO_H', cc.has_header('sys/agpio.h') ? '1' : false)
+conf_data.set('HAVE_SYS_UN_H', cc.has_header('sys/un.h') ? '1' : false)
 conf_data.set('HAVE_SYS_UTSNAME_H', cc.has_header('sys/utsname.h') ? '1' : false)
 conf_data.set('HAVE_SYS_SYSMACROS_H', cc.has_header('sys/sysmacros.h') ? '1' : false)
-conf_data.set('HAVE_UNISTD_H', cc.has_header('unistd.h') ? '1' : false)
 
 conf_data.set('HAVE_ARC4RANDOM_BUF', cc.has_function('arc4random_buf', dependencies: libbsd_dep) ? '1' : false)
 conf_data.set('HAVE_BACKTRACE', cc.has_function('backtrace') ? '1' : false)
@@ -155,6 +153,7 @@ conf_data.set('HAVE_GETZONEID', cc.has_function('getzoneid') ? '1' : false)
 conf_data.set('HAVE_MEMFD_CREATE', cc.has_function('memfd_create') ? '1' : false)
 conf_data.set('HAVE_MKOSTEMP', cc.has_function('mkostemp') ? '1' : false)
 conf_data.set('HAVE_MMAP', cc.has_function('mmap') ? '1' : false)
+conf_data.set('HAVE_OPEN_DEVICE', cc.has_function('open_device') ? '1' : false)
 conf_data.set('HAVE_POLL', cc.has_function('poll') ? '1' : false)
 conf_data.set('HAVE_POLLSET_CREATE', cc.has_function('pollset_create') ? '1' : false)
 conf_data.set('HAVE_POSIX_FALLOCATE', cc.has_function('posix_fallocate') ? '1' : false)
@@ -201,9 +200,7 @@ conf_data.set('UNIXCONN', host_machine.system() != 'windows' ? '1' : false)
 conf_data.set('IPv6', build_ipv6 ? '1' : false)
 
 conf_data.set('BIGREQS', '1')
-if build_composite
-    conf_data.set('COMPOSITE', '1')
-endif
+conf_data.set('COMPOSITE', '1')
 conf_data.set('DAMAGE', '1')
 conf_data.set('DBE', '1')
 conf_data.set('DGA', build_dga ? '1' : false)
@@ -377,6 +374,7 @@ xorg_data.set('WSCONS_SUPPORT',
 xorg_data.set('HAVE_STROPTS_H', cc.has_header('stropts.h') ? '1' : false)
 xorg_data.set('HAVE_SYS_KD_H', cc.has_header('sys/kd.h') ? '1' : false)
 xorg_data.set('HAVE_SYS_VT_H', cc.has_header('sys/vt.h') ? '1' : false)
+xorg_data.set('HAVE_MODESETTING_DRIVER', build_modesetting ? '1' : false)
 
 if host_machine.system() == 'freebsd' or host_machine.system() == 'dragonfly'
     if host_machine.cpu_family() == 'x86' or host_machine.cpu_family() == 'x86_64'
@@ -416,6 +414,17 @@ configure_file(output : 'xwin-config.h',
                input : 'xwin-config.h.meson.in',
                configuration : xwin_data)
 
+xwayland_data = configuration_data()
+xwayland_data.set('XWL_HAS_GLAMOR', build_glamor and (gbm_dep.found() or build_eglstream) ? '1' : false)
+xwayland_data.set('XWL_HAS_EGLSTREAM', build_eglstream ? '1' : false)
+xwayland_data.set('XWL_HAS_LIBDECOR', have_libdecor ? '1' : false)
+xwayland_data.set('XWL_HAS_XWAYLAND_EXTENSION', xwaylandproto_dep.found() ? '1' : false)
+xwayland_data.set('XWL_HAS_WL_POINTER_AXIS_V120', wayland_client_dep.found() and wayland_client_dep.version().version_compare('>= 1.21.0'))
+
+configure_file(output : 'xwayland-config.h',
+               input : 'xwayland-config.h.meson.in',
+               configuration : xwayland_data)
+
 dtrace_hdr = []
 dtrace_tmpl = files('Xserver.d')
 if with_dtrace
diff --git a/include/opaque.h b/include/opaque.h
index 256261c2a..398d4b4e5 100644
--- a/include/opaque.h
+++ b/include/opaque.h
@@ -74,4 +74,6 @@ extern _X_EXPORT Bool bgNoneRoot;
 extern _X_EXPORT Bool CoreDump;
 extern _X_EXPORT Bool NoListenAll;
 
+extern _X_EXPORT Bool AllowByteSwappedClients;
+
 #endif                          /* OPAQUE_H */
diff --git a/include/pixmap.h b/include/pixmap.h
index 7144bfb30..be6df9890 100644
--- a/include/pixmap.h
+++ b/include/pixmap.h
@@ -103,9 +103,7 @@ extern _X_EXPORT PixmapPtr GetScratchPixmapHeader(ScreenPtr pScreen,
 
 extern _X_EXPORT void FreeScratchPixmapHeader(PixmapPtr /*pPixmap */ );
 
-extern _X_EXPORT Bool CreateScratchPixmapsForScreen(ScreenPtr /*pScreen */ );
-
-extern _X_EXPORT void FreeScratchPixmapsForScreen(ScreenPtr /*pScreen */ );
+extern _X_EXPORT Bool PixmapScreenInit(ScreenPtr /*pScreen */ );
 
 extern _X_EXPORT PixmapPtr AllocatePixmap(ScreenPtr /*pScreen */ ,
                                           int /*pixDataSize */ );
@@ -134,4 +132,9 @@ PixmapStopDirtyTracking(DrawablePtr src, PixmapPtr slave_dst);
 extern _X_EXPORT Bool
 PixmapSyncDirtyHelper(PixmapDirtyUpdatePtr dirty);
 
+extern _X_EXPORT void
+PixmapDirtyCopyArea(PixmapPtr dst, DrawablePtr src,
+                    int x, int y, int dst_x, int dst_y,
+                    RegionPtr dirty_region);
+
 #endif                          /* PIXMAP_H */
diff --git a/include/pixmapstr.h b/include/pixmapstr.h
index faf54fa4d..54fc26508 100644
--- a/include/pixmapstr.h
+++ b/include/pixmapstr.h
@@ -78,7 +78,7 @@ typedef struct _Pixmap {
     int refcnt;
     int devKind;                /* This is the pitch of the pixmap, typically width*bpp/8. */
     DevUnion devPrivate;        /* When !NULL, devPrivate.ptr points to the raw pixel data. */
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     short screen_x;
     short screen_y;
 #endif
diff --git a/include/scrnintstr.h b/include/scrnintstr.h
index 24ca423f2..98f47bf51 100644
--- a/include/scrnintstr.h
+++ b/include/scrnintstr.h
@@ -604,8 +604,6 @@ typedef struct _Screen {
     SetScreenPixmapProcPtr SetScreenPixmap;
     NameWindowPixmapProcPtr NameWindowPixmap;
 
-    PixmapPtr pScratchPixmap;   /* scratch pixmap "pool" */
-
     unsigned int totalPixmapSize;
 
     MarkWindowProcPtr MarkWindow;
diff --git a/include/version-config.h.in b/include/version-config.h.in
deleted file mode 100644
index 8180dff8e..000000000
--- a/include/version-config.h.in
+++ /dev/null
@@ -1,16 +0,0 @@
-/* version-config.h.in: not generated */
-
-#ifndef VERSION_CONFIG_H
-#define VERSION_CONFIG_H
-
-/* Vendor man version */
-#undef VENDOR_MAN_VERSION
-
-/* Vendor name */
-#undef VENDOR_NAME
-
-/* Vendor release */
-#undef VENDOR_RELEASE
-
-#endif /* VERSION_CONFIG_H */
-
diff --git a/include/xkbsrv.h b/include/xkbsrv.h
index fbb5427e1..5b4f71f76 100644
--- a/include/xkbsrv.h
+++ b/include/xkbsrv.h
@@ -779,9 +779,6 @@ extern _X_EXPORT void XkbDeleteRulesDflts(void
 extern _X_EXPORT void XkbDeleteRulesUsed(void
     );
 
-extern _X_EXPORT int SProcXkbDispatch(ClientPtr /* client */
-    );
-
 extern _X_EXPORT XkbGeometryPtr XkbLookupNamedGeometry(DeviceIntPtr /* dev */ ,
                                                        Atom /* name */ ,
                                                        Bool *   /* shouldFree */
diff --git a/include/xorg-config.h.in b/include/xorg-config.h.in
deleted file mode 100644
index e3000274d..000000000
--- a/include/xorg-config.h.in
+++ /dev/null
@@ -1,154 +0,0 @@
-/* xorg-config.h.in: not at all generated.                      -*- c -*-
- * 
- * This file differs from xorg-server.h.in in that -server is installed
- * with the rest of the SDK for external drivers/modules to use, whereas
- * -config is for internal use only (i.e. building the DDX).
- *
- */
-
-#ifndef _XORG_CONFIG_H_
-#define _XORG_CONFIG_H_
-
-#include <dix-config.h>
-#include <xkb-config.h>
-
-/* Building Xorg server. */
-#undef XORGSERVER
-
-/* Current X.Org version. */
-#undef XORG_VERSION_CURRENT
-
-/* Name of X server. */
-#undef __XSERVERNAME__
-
-/* URL to go to for support. */
-#undef __VENDORDWEBSUPPORT__
-
-/* Built-in output drivers. */
-#undef DRIVERS
-
-/* Built-in input drivers. */
-#undef IDRIVERS
-
-/* Path to configuration file. */
-#undef XF86CONFIGFILE
-
-/* Path to configuration file. */
-#undef XCONFIGFILE
-
-/* Name of configuration directory. */
-#undef XCONFIGDIR
-
-/* Path to loadable modules. */
-#undef DEFAULT_MODULE_PATH
-
-/* Path to installed libraries. */
-#undef DEFAULT_LIBRARY_PATH
-
-/* Default log location */
-#undef DEFAULT_LOGDIR
-
-/* Default logfile prefix */
-#undef DEFAULT_LOGPREFIX
-
-/* Default XDG_DATA dir under HOME */
-#undef DEFAULT_XDG_DATA_HOME
-
-/* Default log dir under XDG_DATA_HOME */
-#undef DEFAULT_XDG_DATA_HOME_LOGDIR
-
-/* Building DRI-capable DDX. */
-#undef XF86DRI
-
-/* Build DRI2 extension */
-#undef DRI2
-
-/* Define to 1 if you have the <stropts.h> header file. */
-#undef HAVE_STROPTS_H
-
-/* Define to 1 if you have the <sys/kd.h> header file. */
-#undef HAVE_SYS_KD_H
-
-/* Define to 1 if you have the <sys/vt.h> header file. */
-#undef HAVE_SYS_VT_H
-
-/* Define to 1 if you have the `walkcontext' function (used on Solaris for
-   xorg_backtrace in hw/xfree86/common/xf86Events.c */
-#undef HAVE_WALKCONTEXT
-
-/* Define to 1 if unsigned long is 64 bits. */
-#undef _XSERVER64
-
-/* Building vgahw module */
-#undef WITH_VGAHW
-
-/* NetBSD PIO alpha IO */
-#undef USE_ALPHA_PIO
-
-/* BSD AMD64 iopl */
-#undef USE_AMD64_IOPL
-
-/* BSD /dev/io */
-#undef USE_DEV_IO
-
-/* BSD i386 iopl */
-#undef USE_I386_IOPL
-
-/* System is BSD-like */
-#undef CSRG_BASED
-
-/* System has PC console */
-#undef PCCONS_SUPPORT
-
-/* System has PCVT console */
-#undef PCVT_SUPPORT
-
-/* System has syscons console */
-#undef SYSCONS_SUPPORT
-
-/* System has wscons console */
-#undef WSCONS_SUPPORT
-
-/* System has /dev/xf86 aperture driver */
-#undef HAS_APERTURE_DRV
-
-/* Has backtrace support */
-#undef HAVE_BACKTRACE
-
-/* Name of the period field in struct kbd_repeat */
-#undef LNX_KBD_PERIOD_NAME
-
-/* Have execinfo.h */
-#undef HAVE_EXECINFO_H
-
-/* Define to 1 if you have the <sys/mkdev.h> header file. */
-#undef HAVE_SYS_MKDEV_H
-
-/* Define to 1 if you have the <sys/sysmacros.h> header file. */
-#undef HAVE_SYS_SYSMACROS_H
-
-/* Path to text files containing PCI IDs */
-#undef PCI_TXT_IDS_PATH
-
-/* Build with libdrm support */
-#undef WITH_LIBDRM
-
-/* Use libpciaccess */
-#undef XSERVER_LIBPCIACCESS
-
-/* Have setugid */
-#undef HAVE_ISSETUGID
-
-/* Have getresuid */
-#undef HAVE_GETRESUID
-
-/* Have X server platform bus support */
-#undef XSERVER_PLATFORM_BUS
-
-/* Define to 1 if you have the `seteuid' function. */
-#undef HAVE_SETEUID
-
-/* Fallback input driver if the assigned driver fails */
-#undef FALLBACK_INPUT_DRIVER
-
-#endif /* _XORG_CONFIG_H_ */
diff --git a/include/xorg-config.h.meson.in b/include/xorg-config.h.meson.in
index 59f1c2a8d..192c340dc 100644
--- a/include/xorg-config.h.meson.in
+++ b/include/xorg-config.h.meson.in
@@ -145,4 +145,7 @@
 /* Fallback input driver if the assigned driver fails */
 #mesondefine FALLBACK_INPUT_DRIVER
 
+/* Define if building the modesetting driver */
+#mesondefine HAVE_MODESETTING_DRIVER
+
 #endif /* _XORG_CONFIG_H_ */
diff --git a/include/xorg-server.h.in b/include/xorg-server.h.in
deleted file mode 100644
index e2a0ba0d0..000000000
--- a/include/xorg-server.h.in
+++ /dev/null
@@ -1,222 +0,0 @@
-/* xorg-server.h.in						-*- c -*-
- *
- * This file is the template file for the xorg-server.h file which gets
- * installed as part of the SDK.  The #defines in this file overlap
- * with those from config.h, but only for those options that we want
- * to export to external modules.  Boilerplate autotool #defines such
- * as HAVE_STUFF and PACKAGE_NAME is kept in config.h
- *
- * It is still possible to update config.h.in using autoheader, since
- * autoheader only creates a .h.in file for the first
- * AM_CONFIG_HEADER() line, and thus does not overwrite this file.
- *
- * However, it should be kept in sync with this file.
- */
-
-#ifndef _XORG_SERVER_H_
-#define _XORG_SERVER_H_
-
-#ifdef HAVE_XORG_CONFIG_H
-#error Include xorg-config.h when building the X server
-#endif
-
-/* Support BigRequests extension */
-#undef BIGREQS
-
-/* Default font path */
-#undef COMPILEDDEFAULTFONTPATH
-
-/* Support Composite Extension */
-#undef COMPOSITE
-
-/* Build DPMS extension */
-#undef DPMSExtension
-
-/* Build DRI3 extension */
-#undef DRI3
-
-/* Build GLX extension */
-#undef GLXEXT
-
-/* Support XDM-AUTH*-1 */
-#undef HASXDMAUTH
-
-/* Support SHM */
-#undef HAS_SHM
-
-/* Define to 1 if you have the `reallocarray' function. */
-#undef HAVE_REALLOCARRAY
-
-/* Define to 1 if you have the `strcasecmp' function. */
-#undef HAVE_STRCASECMP
-
-/* Define to 1 if you have the `strcasestr' function. */
-#undef HAVE_STRCASESTR
-
-/* Define to 1 if you have the `strlcat' function. */
-#undef HAVE_STRLCAT
-
-/* Define to 1 if you have the `strlcpy' function. */
-#undef HAVE_STRLCPY
-
-/* Define to 1 if you have the `strncasecmp' function. */
-#undef HAVE_STRNCASECMP
-
-/* Define to 1 if you have the `strndup' function. */
-#undef HAVE_STRNDUP
-
-/* Support IPv6 for TCP connections */
-#undef IPv6
-
-/* Support MIT-SHM Extension */
-#undef MITSHM
-
-/* Internal define for Xinerama */
-#undef PANORAMIX
-
-/* Support Present extension */
-#undef PRESENT
-
-/* Support RANDR extension */
-#undef RANDR
-
-/* Support RENDER extension */
-#undef RENDER
-
-/* Support X resource extension */
-#undef RES
-
-/* Support MIT-SCREEN-SAVER extension */
-#undef SCREENSAVER
-
-/* Support SHAPE extension */
-#undef SHAPE
-
-/* Define to 1 on systems derived from System V Release 4 */
-#undef SVR4
-
-/* Support TCP socket connections */
-#undef TCPCONN
-
-/* Support UNIX socket connections */
-#undef UNIXCONN
-
-/* Support XCMisc extension */
-#undef XCMISC
-
-/* Support Xdmcp */
-#undef XDMCP
-
-/* Build XFree86 BigFont extension */
-#undef XF86BIGFONT
-
-/* Support XFree86 Video Mode extension */
-#undef XF86VIDMODE
-
-/* Build XDGA support */
-#undef XFreeXDGA
-
-/* Support Xinerama extension */
-#undef XINERAMA
-
-/* Support X Input extension */
-#undef XINPUT
-
-/* XKB default rules */
-#undef XKB_DFLT_RULES
-
-/* Build DRI extension */
-#undef XF86DRI
-
-/* Build DRI2 extension */
-#undef DRI2
-
-/* Build Xorg server */
-#undef XORGSERVER
-
-/* Current Xorg version */
-#undef XORG_VERSION_CURRENT
-
-/* Build Xv Extension */
-#undef XvExtension
-
-/* Build XvMC Extension */
-#undef XvMCExtension
-
-/* Support XSync extension */
-#undef XSYNC
-
-/* Support XTest extension */
-#undef XTEST
-
-/* Support Xv Extension */
-#undef XV
-
-/* Vendor name */
-#undef XVENDORNAME
-
-/* BSD-compliant source */
-#undef _BSD_SOURCE
-
-/* POSIX-compliant source */
-#undef _POSIX_SOURCE
-
-/* X/Open-compliant source */
-#undef _XOPEN_SOURCE
-
-/* Vendor web address for support */
-#undef __VENDORDWEBSUPPORT__
-
-/* Location of configuration file */
-#undef XCONFIGFILE
-
-/* Name of X server */
-#undef __XSERVERNAME__
-
-/* Building vgahw module */
-#undef WITH_VGAHW
-
-/* System is BSD-like */
-#undef CSRG_BASED
-
-/* System has PC console */
-#undef PCCONS_SUPPORT
-
-/* System has PCVT console */
-#undef PCVT_SUPPORT
-
-/* System has syscons console */
-#undef SYSCONS_SUPPORT
-
-/* System has wscons console */
-#undef WSCONS_SUPPORT
-
-/* Loadable XFree86 server awesomeness */
-#define XFree86LOADER
-
-/* Use libpciaccess */
-#undef XSERVER_LIBPCIACCESS
-
-/* X Access Control Extension */
-#undef XACE
-
-/* Have X server platform bus support */
-#undef XSERVER_PLATFORM_BUS
-
-#ifdef _LP64
-#define _XSERVER64 1
-#endif
-
-/* Have support for X shared memory fence library (xshmfence) */
-#undef HAVE_XSHMFENCE
-
-/* Use XTrans FD passing support */
-#undef XTRANS_SEND_FDS
-
-/* Ask fontsproto to make font path element names const */
-#define FONT_PATH_ELEMENT_NAME_CONST    1
-
-/* byte order */
-#undef X_BYTE_ORDER
-
-#endif /* _XORG_SERVER_H_ */
diff --git a/include/xwayland-config.h.meson.in b/include/xwayland-config.h.meson.in
new file mode 100644
index 000000000..43b9ff29e
--- /dev/null
+++ b/include/xwayland-config.h.meson.in
@@ -0,0 +1,20 @@
+/* xwayland-config.h.meson.in: not at all generated */
+
+#pragma once
+
+#include <dix-config.h>
+
+/* Build glamor support for Xwayland */
+#mesondefine XWL_HAS_GLAMOR
+
+/* Build eglstream support for Xwayland */
+#mesondefine XWL_HAS_EGLSTREAM
+
+/* Build Xwayland with libdecor support*/
+#mesondefine XWL_HAS_LIBDECOR
+
+/* Build Xwayland with XWAYLAND extension */
+#mesondefine XWL_HAS_XWAYLAND_EXTENSION
+
+/* libwayland has support for wl_pointer.axis_v120 events */
+#mesondefine XWL_HAS_WL_POINTER_AXIS_V120
diff --git a/include/xwin-config.h.in b/include/xwin-config.h.in
deleted file mode 100644
index 176c01980..000000000
--- a/include/xwin-config.h.in
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * xwin-config.h.in
- *
- * This file has all defines used in the xwin ddx
- *
- */
-#include <dix-config.h>
-
-/* Winsock networking */
-#undef HAS_WINSOCK
-
-/* Cygwin has /dev/windows for signaling new win32 messages */
-#undef HAS_DEVWINDOWS
-
-/* Switch on debug messages */
-#undef CYGDEBUG
-#undef CYGWINDOWING_DEBUG
-#undef CYGMULTIWINDOW_DEBUG
-
-/* Define to 1 if unsigned long is 64 bits. */
-#undef _XSERVER64
-
-/* Short vendor name */
-#undef XVENDORNAMESHORT
-
-/* Vendor web address for support */
-#undef __VENDORDWEBSUPPORT__
-
-/* Default log location */
-#undef DEFAULT_LOGDIR
-
-/* Whether we should re-locate the root to where the executable lives */
-#undef RELOCATE_PROJECTROOT
diff --git a/man/Makefile.am b/man/Makefile.am
deleted file mode 100644
index 71d704917..000000000
--- a/man/Makefile.am
+++ /dev/null
@@ -1,6 +0,0 @@
-# Xserver.man covers options generic to all X servers built in this tree
-# (i.e. those handled in the os/utils.c options processing instead of in
-#  the DDX-level options processing)
-
-include $(top_srcdir)/manpages.am
-appman_PRE = Xserver.man
diff --git a/man/Xserver.man b/man/Xserver.man
index 764bd1d90..e7adf9eb3 100644
--- a/man/Xserver.man
+++ b/man/Xserver.man
@@ -114,6 +114,12 @@ pattern.   This is the default unless -retro or -wr is specified.
 .B \-bs
 disables backing store support on all screens.
 .TP 8
+.B \+byteswappedclients
+Allow connections from clients with an endianess different to that of the server.
+.TP 8
+.B \-byteswappedclients
+Prohibit connections from clients with an endianess different to that of the server.
+.TP 8
 .B \-c
 turns off key-click.
 .TP 8
diff --git a/manpages.am b/manpages.am
deleted file mode 100644
index 15056905c..000000000
--- a/manpages.am
+++ /dev/null
@@ -1,59 +0,0 @@
-appmandir = $(APP_MAN_DIR)
-#appman_PRE = list of application man page files set by calling Makefile.am
-appman_DATA = $(appman_PRE:man=$(APP_MAN_SUFFIX))
-
-drivermandir = $(DRIVER_MAN_DIR)
-#driverman_PRE = list of driver man page files set by calling Makefile.am
-driverman_DATA = $(driverman_PRE:man=$(DRIVER_MAN_SUFFIX))
-
-filemandir = $(FILE_MAN_DIR)
-#fileman_PRE = list of file man page files set by calling Makefile.am
-fileman_DATA = $(fileman_PRE:man=$(FILE_MAN_SUFFIX))
-
-# The calling Makefile should only contain man page targets
-# Otherwise the following three global variables may conflict
-EXTRA_DIST = $(appman_PRE) $(driverman_PRE) $(fileman_PRE)
-CLEANFILES = $(appman_DATA) $(driverman_DATA) $(fileman_DATA)
-SUFFIXES = .$(APP_MAN_SUFFIX) .$(DRIVER_MAN_SUFFIX) .$(FILE_MAN_SUFFIX) .man
-
-# xorg-macros.m4 has these bracketed by double underscores, but meson
-# wants ats.
-
-MAN_SUBSTS +=   -e 's|@vendorversion@|"$(PACKAGE_STRING)" "$(XORG_MAN_PAGE)"|' \
-                -e 's|@xorgversion@|"$(PACKAGE_STRING)" "$(XORG_MAN_PAGE)"|' \
-                -e 's|@xservername@|Xorg|g' \
-                -e 's|@xconfigfile@|xorg.conf|g' \
-                -e 's|@projectroot@|$(prefix)|g' \
-                -e 's|@apploaddir@|$(appdefaultdir)|g' \
-                -e 's|@appmansuffix@|$(APP_MAN_SUFFIX)|g' \
-                -e 's|@drivermansuffix@|$(DRIVER_MAN_SUFFIX)|g' \
-                -e 's|@adminmansuffix@|$(ADMIN_MAN_SUFFIX)|g' \
-                -e 's|@libmansuffix@|$(LIB_MAN_SUFFIX)|g' \
-                -e 's|@miscmansuffix@|$(MISC_MAN_SUFFIX)|g' \
-                -e 's|@filemansuffix@|$(FILE_MAN_SUFFIX)|g'
-
-# Add server specific man pages string substitution from XORG_MANPAGE_SECTIONS
-# 's|/,|/, |g' will add a space to help font path formatting
-MAN_SUBSTS += 	-e 's|[@]logdir[@]|$(logdir)|g' \
-		-e 's|[@]datadir[@]|$(datadir)|g' \
-		-e 's|[@]mandir[@]|$(mandir)|g' \
-		-e 's|[@]sysconfdir[@]|$(sysconfdir)|g' \
-		-e 's|[@]xconfigdir[@]|$(XCONFIGDIR)|g' \
-		-e 's|[@]xkbdir[@]|$(XKB_BASE_DIRECTORY)|g' \
-		-e 's|[@]XKB_DFLT_RULES[@]|$(XKB_DFLT_RULES)|g' \
-		-e 's|[@]XKB_DFLT_MODEL[@]|$(XKB_DFLT_MODEL)|g' \
-		-e 's|[@]XKB_DFLT_LAYOUT[@]|$(XKB_DFLT_LAYOUT)|g' \
-		-e 's|[@]XKB_DFLT_VARIANT[@]|$(XKB_DFLT_VARIANT)|g' \
-		-e 's|[@]XKB_DFLT_OPTIONS[@]|$(XKB_DFLT_OPTIONS)|g' \
-		-e 's|[@]bundle_id_prefix[@]|$(BUNDLE_ID_PREFIX)|g' \
-		-e 's|[@]modulepath[@]|$(DEFAULT_MODULE_PATH)|g' \
-		-e 's|[@]suid_wrapper_dir[@]|$(SUID_WRAPPER_DIR)|g' \
-		-e 's|[@]default_font_path[@]|$(COMPILEDDEFAULTFONTPATH)|g' \
-		-e '\|$(COMPILEDDEFAULTFONTPATH)| s|/,|/, |g'
-
-.man.$(APP_MAN_SUFFIX):
-	$(AM_V_GEN)$(SED) $(MAN_SUBSTS) < $< > $@
-.man.$(DRIVER_MAN_SUFFIX):
-	$(AM_V_GEN)$(SED) $(MAN_SUBSTS) < $< > $@
-.man.$(FILE_MAN_SUFFIX):
-	$(AM_V_GEN)$(SED) $(MAN_SUBSTS) < $< > $@
diff --git a/meson.build b/meson.build
index e6b6fc6e7..01e22b6a9 100644
--- a/meson.build
+++ b/meson.build
@@ -3,18 +3,18 @@ project('xserver', 'c',
             'buildtype=debugoptimized',
             'c_std=gnu99',
         ],
-        version: '21.1.6',
-        meson_version: '>= 0.47.0',
+        version: '21.1.99.1',
+        meson_version: '>= 0.52.0',
 )
-release_date = '2022-12-19'
+release_date = '2021-07-05'
 
 add_project_arguments('-DHAVE_DIX_CONFIG_H', language: ['c', 'objc'])
 cc = meson.get_compiler('c')
 
-add_global_arguments('-fno-strict-aliasing', language : 'c')
-add_global_arguments('-fvisibility=hidden', language : 'c')
+add_project_arguments('-fno-strict-aliasing', language : 'c')
+add_project_arguments('-fvisibility=hidden', language : 'c')
 
-add_global_link_arguments('-fvisibility=hidden', language : 'c')
+add_project_link_arguments('-fvisibility=hidden', language : 'c')
 
 if cc.get_id() == 'gcc' or cc.get_id() == 'clang'
     test_wflags = [
@@ -58,13 +58,13 @@ foreach wflag: test_wflags
     endif
 endforeach
 
-add_global_arguments(common_wflags, language : ['c', 'objc'])
+add_project_arguments(common_wflags, language : ['c', 'objc'])
 
 libdrm_req = '>= 2.4.89'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
-wayland_req = '>= 1.5.0'
-wayland_protocols_req = '>= 1.18'
+wayland_req = '>= 1.18.0'
+wayland_protocols_req = '>= 1.28'
 gbm_req = '>= 10.2'
 xf86dgaproto_req = '>= 2.0.99.1'
 
@@ -94,6 +94,7 @@ xf86bigfontproto_dep = dependency('xf86bigfontproto', version: '>= 1.2.0', fallb
 xf86vidmodeproto_dep = dependency('xf86vidmodeproto', version: '>= 2.2.99.1', fallback: ['xorgproto', 'ext_xorgproto'])
 applewmproto_dep = dependency('applewmproto', version: '>= 1.4', fallback: ['xorgproto', 'ext_xorgproto'], required: false)
 xshmfence_dep = dependency('xshmfence', version: '>= 1.1', required: false)
+xwaylandproto_dep = dependency('xwaylandproto', version: '>= 1.0', fallback: ['xorgproto', 'ext_xorgproto'], required: false)
 
 pixman_dep = dependency('pixman-1')
 libbsd_dep = dependency('libbsd', required: false)
@@ -140,8 +141,15 @@ endif
 
 dfp = get_option('default_font_path')
 if dfp == ''
-    fontutil_dep = dependency('fontutil')
-    fontrootdir = fontutil_dep.get_pkgconfig_variable('fontrootdir')
+    fontrootdir = get_option('fontrootdir')
+    if fontrootdir == ''
+        fontutil_dep = dependency('fontutil', required: false)
+        if fontutil_dep.found()
+            fontrootdir = fontutil_dep.get_pkgconfig_variable('fontrootdir')
+        else
+            fontrootdir = join_paths(get_option('prefix'), get_option('datadir'), 'fonts', 'X11')
+        endif
+    endif
     dfp_elements = [
         join_paths(fontrootdir, 'misc'),
         join_paths(fontrootdir, 'TTF'),
@@ -193,7 +201,42 @@ if (host_machine.system() != 'windows')
     endif
 endif
 xorgsdkdir = join_paths(get_option('prefix'), get_option('includedir'), 'xorg')
-libxcvt_dep = dependency('libxcvt', required: build_xorg)
+libxcvt_dep = dependency('libxcvt', fallback: ['libxcvt', 'libxcvt_dep'], required: build_xorg)
+
+build_xwayland = false
+if (host_machine.system() != 'darwin' and
+    host_machine.system() != 'windows' and
+    get_option('xwayland') != 'false')
+    xwayland_required = get_option('xwayland') == 'true'
+    build_glamor = glamor_option == 'true' or glamor_option == 'auto'
+
+    xwayland_path = get_option('xwayland-path')
+    if (xwayland_path == '')
+        xwayland_path = join_paths(get_option('prefix'), get_option('bindir'))
+    endif
+
+    wayland_client_dep = dependency('wayland-client', version: wayland_req, required: xwayland_required)
+    xwayland_dep = [
+        wayland_client_dep,
+        dependency('wayland-protocols', version: wayland_protocols_req, required: xwayland_required),
+        dependency('libxcvt', fallback: ['libxcvt', 'libxcvt_dep'], required: xwayland_required),
+    ]
+
+    if build_glamor
+        xwayland_dep += dependency('libdrm', version: libdrm_req, required: xwayland_required)
+        xwayland_dep += dependency('epoxy', required: xwayland_required)
+    endif
+
+    build_xwayland = true
+    # check for all the deps being found, to handle 'auto' mode.
+    foreach d: xwayland_dep
+        if not d.found()
+            build_xwayland = false
+        endif
+    endforeach
+else
+    wayland_client_dep = dependency('', required: false)
+endif
 
 build_xnest = false
 if (host_machine.system() != 'windows')
@@ -235,10 +278,8 @@ else
     build_xquartz = get_option('xquartz') == 'true'
 endif
 
-build_composite = true
 build_rootless = false
 if build_xquartz
-    build_composite = false
     build_rootless = true
 endif
 
@@ -251,7 +292,7 @@ endif
 int10 = get_option('int10')
 if int10 == 'auto'
     int10 = 'x86emu'
-    if host_machine.cpu() == 'powerpc' and host_machine.system() == 'freebsd'
+    if host_machine.cpu() == 'ppc' and host_machine.system() == 'freebsd'
         int10 = 'stub'
     endif
     if host_machine.cpu() == 'arm'
@@ -293,7 +334,7 @@ endif
 module_dir = join_paths(get_option('libdir'), get_option('module_dir'))
 
 if glamor_option == 'auto'
-    build_glamor = build_xorg
+    build_glamor = build_xorg or build_xwayland
 else
     build_glamor = glamor_option == 'true'
 endif
@@ -305,6 +346,36 @@ if build_glamor
     epoxy_dep = dependency('epoxy', required: false)
 endif
 
+if build_xwayland
+    libdecor_dep = dependency('libdecor-0', required: false)
+    libdecor_option = get_option('libdecor')
+    if libdecor_option == 'auto'
+        have_libdecor = libdecor_dep.found()
+    else
+        have_libdecor = libdecor_option == 'true'
+        if have_libdecor and not libdecor_dep.found()
+            error('libdecor support requested but not found')
+        endif
+    endif
+else
+    have_libdecor = false
+endif
+
+eglstream_option = get_option('xwayland_eglstream')
+if build_xwayland and build_glamor
+    eglstream_dep = dependency('wayland-eglstream-protocols', required:false)
+    if eglstream_option == 'auto'
+        build_eglstream = eglstream_dep.found()
+    else
+        build_eglstream = eglstream_option == 'true'
+        if build_eglstream and not eglstream_dep.found()
+            error('glamor EGLStream support requested, but wayland-eglstream-protocols not found')
+        endif
+    endif
+else
+    build_eglstream = false
+endif
+
 # Lots of sha1 options, because Linux is about choice :)
 
 # The idea behind the ordering here is that we should first prefer system
@@ -699,9 +770,7 @@ subdir('fb')
 subdir('mi')
 subdir('os')
 # X extensions
-if build_composite
-    subdir('composite')
-endif
+subdir('composite')
 subdir('damageext')
 subdir('dbe')
 subdir('miext/damage')
@@ -735,6 +804,7 @@ libxserver = [
     libxserver_mi,
     libxserver_dix,
 
+    libxserver_composite,
     libxserver_damageext,
     libxserver_dbe,
     libxserver_randr,
@@ -751,10 +821,6 @@ libxserver = [
     libxserver_os,
 ]
 
-if build_composite
-    libxserver += libxserver_composite
-endif
-
 libxserver += libxserver_dri3
 
 subdir('hw')
@@ -817,6 +883,13 @@ if build_xorg
     sdkconfig.set('symbol_visibility', '-fvisibility=hidden')
     sdkconfig.set('XORG_DRIVER_LIBS', '')
 
+    # On Windows, modules built with the SDK will need to link with server and
+    # module implibs to resolve symbols
+    if (host_machine.system() == 'cygwin' or
+        host_machine.system() == 'windows')
+        sdkconfig.set('XORG_DRIVER_LIBS', '-lXorg.exe -L\${moduledir} -lshadow -no-undefined')
+    endif
+
     configure_file(
         input: 'xorg-server.pc.in',
         output: 'xorg-server.pc',
diff --git a/meson_options.txt b/meson_options.txt
index b12d521ba..11d576780 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -2,8 +2,12 @@ option('xorg', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
        description: 'Enable Xorg X Server')
 option('xephyr', type: 'boolean', value: false,
        description: 'Enable Xephyr nested X server')
+option('xwayland', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
+       description: 'Enable Xwayland X server')
 option('glamor', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
-       description: 'Enable glamor (default yes for Xorg builds)')
+       description: 'Enable glamor (default yes for Xorg/Xwayland builds)')
+option('xwayland_eglstream', type: 'combo', choices: ['true', 'false', 'auto'],
+       value: 'auto', description: 'Enable EGLStream support for glamor on Xwayland')
 option('xnest', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
        description: 'Enable Xnest nested X server')
 option('xvfb', type: 'boolean', value: true,
@@ -21,6 +25,8 @@ option('log_dir', type: 'string')
 option('module_dir', type: 'string', value: 'xorg/modules',
        description: 'X.Org modules directory (absolute or relative to the directory specified by the libdir option)')
 option('default_font_path', type: 'string')
+option('fontrootdir', type: 'string',
+        description: 'Root directory for legacy fonts. Default: from font-utils.pc or $datadir/fonts/X11')
 
 option('glx', type: 'boolean', value: true)
 option('xdmcp', type: 'boolean', value: true)
@@ -57,12 +63,12 @@ option('listen_local', type: 'boolean', value: true,
 option('int10', type: 'combo', choices: ['stub', 'x86emu', 'vm86', 'auto', 'false'],
        value: 'auto',
        description: 'Xorg int10 backend (default: usually x86emu)')
-option('suid_wrapper', type: 'boolean', value: 'false',
+option('suid_wrapper', type: 'boolean', value: false,
        description: 'SUID wrapper for legacy driver support')
-option('pciaccess', type: 'boolean', value: 'true',
+option('pciaccess', type: 'boolean', value: true,
        description: 'Xorg pciaccess support')
-option('udev', type: 'boolean', value: 'true')
-option('udev_kms', type: 'boolean', value: 'true')
+option('udev', type: 'boolean', value: true)
+option('udev_kms', type: 'boolean', value: true)
 option('hal', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
        description: 'Enable HAL integration')
 option('systemd_logind', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
@@ -107,7 +113,7 @@ option('xf86-input-inputtest', type: 'boolean', value: true,
 option('dri1', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto', description: 'Build DRI1 extension (default: auto)')
 option('dri2', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto', description: 'Build DRI2 extension (default: auto)')
 option('dri3', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto', description: 'Build DRI3 extension (default: auto)')
-option('drm', type: 'boolean', value: 'true',
+option('drm', type: 'boolean', value: true,
         description: 'Build Xorg with libdrm support')
 
 option('apple-applications-dir', type: 'string', value: '/Applications/Utilities',
@@ -130,6 +136,10 @@ option('xpbproxy', type: 'boolean', value: false,
 option('libunwind', type: 'boolean', value: false,
         description: 'Use libunwind for backtrace reporting')
 
+option('xwayland-path', type: 'string', description: 'Directory containing Xwayland executable')
+option('libdecor', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
+        description: 'Whether Xwayland should use libdecor when running rootful.')
+
 option('docs', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
         description: 'Build documentation')
 option('devel-docs', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto',
diff --git a/mi/Makefile.am b/mi/Makefile.am
deleted file mode 100644
index 110c3f5dd..000000000
--- a/mi/Makefile.am
+++ /dev/null
@@ -1,56 +0,0 @@
-noinst_LTLIBRARIES = libmi.la
-
-if XORG
-sdk_HEADERS = micmap.h miline.h mipointer.h mi.h \
-              migc.h mipointrst.h mizerarc.h micoord.h \
-              mistruct.h mioverlay.h
-endif
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-libmi_la_SOURCES = 	\
-	mi.h		\
-	miarc.c		\
-	mibitblt.c	\
-	micmap.c	\
-	micmap.h	\
-	micoord.h	\
-	micopy.c	\
-	midash.c	\
-	midispcur.c	\
-	mieq.c		\
-	miexpose.c	\
-	mifillarc.c	\
-	mifillarc.h	\
-	mifillrct.c	\
-	mifpoly.h	\
-	migc.c		\
-	migc.h		\
-	miglblt.c	\
-	miline.h	\
-	mioverlay.c	\
-	mioverlay.h	\
-	mipointer.c	\
-	mipointer.h	\
-	mipointrst.h	\
-	mipoly.c	\
-	mipoly.h	\
-	mipolypnt.c	\
-	mipolyrect.c	\
-	mipolyseg.c	\
-	mipolytext.c	\
-	mipushpxl.c	\
-	miscanfill.h	\
-	miscrinit.c	\
-	misprite.c	\
-	misprite.h	\
-	mistruct.h	\
-	mivaltree.c	\
-	mivalidate.h	\
-	miwideline.c	\
-	miwideline.h	\
-	miwindow.c	\
-	mizerarc.c	\
-	mizerarc.h	\
-	mizerclip.c	\
-	mizerline.c
diff --git a/mi/miarc.c b/mi/miarc.c
index 3936f6c27..3a0ecc446 100644
--- a/mi/miarc.c
+++ b/mi/miarc.c
@@ -3151,10 +3151,10 @@ realFindSpan(int y)
         else
             newMaxy = finalMaxy + change;
         if (finalSpans) {
-            memmove(((char *) newSpans) +
+            memcpy(((char *) newSpans) +
                     (finalMiny - newMiny) * sizeof(struct finalSpan *),
-                    (char *) finalSpans,
-                    finalSize * sizeof(struct finalSpan *));
+                   finalSpans,
+                   finalSize * sizeof(struct finalSpan *));
             free(finalSpans);
         }
         if ((i = finalMiny - newMiny) > 0)
diff --git a/mi/miexpose.c b/mi/miexpose.c
index e54b18b30..6b6938a75 100644
--- a/mi/miexpose.c
+++ b/mi/miexpose.c
@@ -461,7 +461,7 @@ miPaintWindow(WindowPtr pWin, RegionPtr prgn, int what)
         tile_x_off = pWin->drawable.x;
         tile_y_off = pWin->drawable.y;
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
         draw_x_off = pixmap->screen_x;
         draw_y_off = pixmap->screen_y;
         tile_x_off -= draw_x_off;
diff --git a/miext/Makefile.am b/miext/Makefile.am
deleted file mode 100644
index add4d18b0..000000000
--- a/miext/Makefile.am
+++ /dev/null
@@ -1 +0,0 @@
-SUBDIRS = sync damage shadow rootless
diff --git a/miext/damage/Makefile.am b/miext/damage/Makefile.am
deleted file mode 100644
index a7f432a61..000000000
--- a/miext/damage/Makefile.am
+++ /dev/null
@@ -1,14 +0,0 @@
-noinst_LTLIBRARIES = libdamage.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-AM_CPPFLAGS = -I$(srcdir)/../cw
-
-if XORG
-sdk_HEADERS = damage.h damagestr.h
-endif
-
-libdamage_la_SOURCES =	\
-	damage.c	\
-	damage.h	\
-	damagestr.h
diff --git a/miext/damage/damage.c b/miext/damage/damage.c
index f3ae4ebbc..48e6af673 100644
--- a/miext/damage/damage.c
+++ b/miext/damage/damage.c
@@ -142,7 +142,7 @@ damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
     RegionRec pixClip;
     int draw_x, draw_y;
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     int screen_x = 0, screen_y = 0;
 #endif
 
@@ -150,7 +150,7 @@ damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
     if (!RegionNotEmpty(pRegion))
         return;
 
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     /*
      * When drawing to a pixmap which is storing window contents,
      * the region presented is in pixmap relative coordinates which
@@ -201,7 +201,7 @@ damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
 
         draw_x = pDamage->pDrawable->x;
         draw_y = pDamage->pDrawable->y;
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
         /*
          * Need to move everyone to screen coordinates
          * XXX what about off-screen pixmaps with non-zero x/y?
@@ -274,7 +274,7 @@ damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
         if (pDamageRegion == pRegion && (draw_x || draw_y))
             RegionTranslate(pDamageRegion, draw_x, draw_y);
     }
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
     if (screen_x || screen_y)
         RegionTranslate(pRegion, -screen_x, -screen_y);
 #endif
diff --git a/miext/rootless/Makefile.am b/miext/rootless/Makefile.am
deleted file mode 100644
index c97bebebe..000000000
--- a/miext/rootless/Makefile.am
+++ /dev/null
@@ -1,16 +0,0 @@
-AM_CFLAGS = $(DIX_CFLAGS) $(XSERVER_CFLAGS)
-
-noinst_LTLIBRARIES = librootless.la
-librootless_la_SOURCES = \
-	rootlessCommon.c \
-	rootlessGC.c \
-	rootlessScreen.c \
-	rootlessValTree.c \
-	rootlessWindow.c
-
-EXTRA_DIST = \
-	README.txt \
-	rootless.h \
-	rootlessCommon.h \
-	rootlessConfig.h \
-	rootlessWindow.h 
diff --git a/miext/rootless/README.txt b/miext/rootless/README.txt
index 754715d33..8a3b2bedf 100644
--- a/miext/rootless/README.txt
+++ b/miext/rootless/README.txt
@@ -88,14 +88,6 @@ rootlessConfig.h:
         the underlying window server. Most operations will be buffered until
         this time has expired.
 
-      o ROOTLESS_RESIZE_GRAVITY: If the underlying window system supports it,
-        some frame resizes can be optimized by relying on the frame contents
-        maintaining a particular gravity during the resize. In this way less
-        of the frame contents need to be preserved by the generic rootless
-        layer. If true, the generic rootless layer will pass gravity hints
-        during resizing and rely on the frame contents being preserved
-        accordingly.
-
         The following runtime options are defined in rootless.h:
 
       o rootlessGlobalOffsetX, rootlessGlobalOffsetY: These specify the global
diff --git a/miext/rootless/rootless.h b/miext/rootless/rootless.h
index ed3b6c489..b375731bf 100644
--- a/miext/rootless/rootless.h
+++ b/miext/rootless/rootless.h
@@ -140,8 +140,7 @@ typedef void (*RootlessMoveFrameProc)
  *  pScreen     Screen to move the new frame to
  *  newX, newY  New position of the frame
  *  newW, newH  New size of the frame
- *  gravity     Gravity for window contents (rl_gravity_enum). This is always
- *              RL_GRAVITY_NONE unless ROOTLESS_RESIZE_GRAVITY is set.
+ *  gravity     Gravity for window contents (rl_gravity_enum).
  */
 typedef void (*RootlessResizeFrameProc)
  (RootlessFrameID wid, ScreenPtr pScreen,
diff --git a/miext/rootless/rootlessCommon.c b/miext/rootless/rootlessCommon.c
index 504362790..44c2c3789 100644
--- a/miext/rootless/rootlessCommon.c
+++ b/miext/rootless/rootlessCommon.c
@@ -134,6 +134,23 @@ RootlessResolveColormap(ScreenPtr pScreen, int first_color,
     return TRUE;
 }
 
+unsigned long RootlessWID(WindowPtr pWindow) {
+    ScreenPtr pScreen = pWindow->drawable.pScreen;
+    WindowPtr top = TopLevelParent(pWindow);
+    RootlessWindowRec *winRec;
+    PixmapPtr curPixmap;
+
+    if (top == NULL) {
+        return 0;
+    }
+    winRec = WINREC(top);
+    if (winRec == NULL) {
+        return 0;
+    }
+
+    return (unsigned long)(uintptr_t)winRec->wid;
+}
+
 /*
  * RootlessStartDrawing
  *  Prepare a window for direct access to its backing buffer.
@@ -148,11 +165,15 @@ RootlessStartDrawing(WindowPtr pWindow)
     RootlessWindowRec *winRec;
     PixmapPtr curPixmap;
 
-    if (top == NULL)
+    if (top == NULL) {
+        RL_DEBUG_MSG("RootlessStartDrawing is a no-op because top == NULL.\n");
         return;
+    }
     winRec = WINREC(top);
-    if (winRec == NULL)
+    if (winRec == NULL) {
+        RL_DEBUG_MSG("RootlessStartDrawing is a no-op because winRec == NULL.\n");
         return;
+    }
 
     // Make sure the window's top-level parent is prepared for drawing.
     if (!winRec->is_drawing) {
@@ -166,10 +187,23 @@ RootlessStartDrawing(WindowPtr pWindow)
                                    top->drawable.depth,
                                    top->drawable.bitsPerPixel,
                                    winRec->bytesPerRow, winRec->pixelData);
+
+        RL_DEBUG_MSG("GetScratchPixmapHeader gave us %p %p (%d,%d %dx%d %d) for wid=%lu\n",
+                     winRec->pixmap, winRec->pixmap->devPrivate.ptr, winRec->pixmap->drawable.x,
+                     winRec->pixmap->drawable.y, winRec->pixmap->drawable.width, winRec->pixmap->drawable.height,
+                     winRec->pixmap->drawable.bitsPerPixel, RootlessWID(pWindow));
+
         SetPixmapBaseToScreen(winRec->pixmap,
                               top->drawable.x - bw, top->drawable.y - bw);
 
+        RL_DEBUG_MSG("After SetPixmapBaseToScreen(%d %d %d): %p (%d,%d %dx%d %d) for wid=%lu\n",
+                     top->drawable.x, top->drawable.y, bw, winRec->pixmap->devPrivate.ptr, winRec->pixmap->drawable.x,
+                     winRec->pixmap->drawable.y, winRec->pixmap->drawable.width, winRec->pixmap->drawable.height,
+                     winRec->pixmap->drawable.bitsPerPixel, RootlessWID(pWindow));
+
         winRec->is_drawing = TRUE;
+    } else {
+        RL_DEBUG_MSG("Skipped call to xprStartDrawing (wid: %lu) because winRec->is_drawing says we already did.\n", RootlessWID(pWindow));
     }
 
     curPixmap = pScreen->GetWindowPixmap(pWindow);
@@ -181,6 +215,10 @@ RootlessStartDrawing(WindowPtr pWindow)
         PixmapPtr oldPixmap =
             dixLookupPrivate(&pWindow->devPrivates,
                              rootlessWindowOldPixmapPrivateKey);
+
+        RL_DEBUG_MSG("curPixmap is %p %p for wid=%lu\n", curPixmap, curPixmap ? curPixmap->devPrivate.ptr : NULL, RootlessWID(pWindow));
+        RL_DEBUG_MSG("oldPixmap is %p %p for wid=%lu\n", oldPixmap, oldPixmap ? oldPixmap->devPrivate.ptr : NULL, RootlessWID(pWindow));
+
         if (oldPixmap != NULL) {
             if (oldPixmap == curPixmap)
                 RL_DEBUG_MSG
@@ -277,7 +315,7 @@ RootlessDamageRegion(WindowPtr pWindow, RegionPtr pRegion)
     WindowPtr pTop;
     BoxPtr b1, b2;
 
-    RL_DEBUG_MSG("Damaged win 0x%x ", pWindow);
+    RL_DEBUG_MSG("Damaged win %p\n", pWindow);
 
     pTop = TopLevelParent(pWindow);
     if (pTop == NULL)
diff --git a/miext/rootless/rootlessCommon.h b/miext/rootless/rootlessCommon.h
index 83dec3bb7..40400b395 100644
--- a/miext/rootless/rootlessCommon.h
+++ b/miext/rootless/rootlessCommon.h
@@ -226,20 +226,10 @@ extern RegionRec rootlessHugeRoot;
  *  Can't access the bits before the first word of the drawable's data in
  *  rootless mode, so make sure our base address is always 32-bit aligned.
  */
-#define SetPixmapBaseToScreen(pix, _x, _y) {                                \
-    PixmapPtr   _pPix = (PixmapPtr) (pix);                                  \
-    _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -              \
-                            ((int)(_x) * _pPix->drawable.bitsPerPixel/8 +   \
-                             (int)(_y) * _pPix->devKind);                   \
-    if (_pPix->drawable.bitsPerPixel != FB_UNIT) {                          \
-        size_t _diff = ((size_t) _pPix->devPrivate.ptr) &               \
-                         (FB_UNIT / CHAR_BIT - 1);                          \
-        _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -          \
-                                _diff;                                      \
-        _pPix->drawable.x = _diff /                                         \
-                            (_pPix->drawable.bitsPerPixel / CHAR_BIT);      \
-    }                                                                       \
-}
+#define SetPixmapBaseToScreen(pix, _x, _y) do { \
+    pix->screen_x = _x; \
+    pix->screen_y = _y; \
+} while(0)
 
 // Returns TRUE if this window is visible inside a frame
 // (e.g. it is visible and has a top-level or root parent)
@@ -282,4 +272,5 @@ void RootlessDisableRoot(ScreenPtr pScreen);
 
 void RootlessSetPixmapOfAncestors(WindowPtr pWin);
 
+unsigned long RootlessWID(WindowPtr pWindow);
 #endif                          /* _ROOTLESSCOMMON_H */
diff --git a/miext/rootless/rootlessConfig.h b/miext/rootless/rootlessConfig.h
index 4c464b9f5..80c2f6d8a 100644
--- a/miext/rootless/rootlessConfig.h
+++ b/miext/rootless/rootlessConfig.h
@@ -34,10 +34,6 @@
 #ifndef _ROOTLESSCONFIG_H
 #define _ROOTLESSCONFIG_H
 
-#ifdef __APPLE__
-#define ROOTLESS_RESIZE_GRAVITY TRUE
-#endif
-
 /*# define ROOTLESSDEBUG*/
 
 #define ROOTLESS_PROTECT_ALPHA TRUE
diff --git a/miext/rootless/rootlessGC.c b/miext/rootless/rootlessGC.c
index 52d9df9ce..5af18a4a0 100644
--- a/miext/rootless/rootlessGC.c
+++ b/miext/rootless/rootlessGC.c
@@ -549,7 +549,7 @@ RootlessCopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
     GC_SAVE(pGC);
     GCOP_UNWRAP(pGC);
 
-    RL_DEBUG_MSG("copy area start (src 0x%x, dst 0x%x)", pSrc, dst);
+    RL_DEBUG_MSG("copy area start (src %p, dst %p)", pSrc, dst);
 
     if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr) pSrc)) {
         /* If both source and dest are windows, and we're doing
@@ -800,7 +800,7 @@ static void
 RootlessPolySegment(DrawablePtr dst, GCPtr pGC, int nseg, xSegment * pSeg)
 {
     GCOP_UNWRAP(pGC);
-    RL_DEBUG_MSG("poly segment start (win 0x%x)", dst);
+    RL_DEBUG_MSG("poly segment start (dst %p)", dst);
 
     RootlessStartDrawing((WindowPtr) dst);
     pGC->ops->PolySegment(dst, pGC, nseg, pSeg);
@@ -998,7 +998,7 @@ RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
 {
     GC_SAVE(pGC);
     GCOP_UNWRAP(pGC);
-    RL_DEBUG_MSG("fill poly start (win 0x%x, fillStyle 0x%x)", dst,
+    RL_DEBUG_MSG("fill poly start (dst %p, fillStyle 0x%x)", dst,
                  pGC->fillStyle);
 
     if (count <= 2) {
@@ -1072,7 +1072,7 @@ RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
 {
     GC_SAVE(pGC);
     GCOP_UNWRAP(pGC);
-    RL_DEBUG_MSG("fill rect start (win 0x%x, fillStyle 0x%x)", dst,
+    RL_DEBUG_MSG("fill rect start (dst %p, fillStyle 0x%x)", dst,
                  pGC->fillStyle);
 
     if (nRectsInit <= 0) {
diff --git a/miext/rootless/rootlessWindow.c b/miext/rootless/rootlessWindow.c
index 106d4320e..643dedff6 100644
--- a/miext/rootless/rootlessWindow.c
+++ b/miext/rootless/rootlessWindow.c
@@ -325,7 +325,7 @@ RootlessPositionWindow(WindowPtr pWin, int x, int y)
     RootlessWindowRec *winRec = WINREC(pWin);
     Bool result;
 
-    RL_DEBUG_MSG("positionwindow start (win 0x%x @ %i, %i)\n", pWin, x, y);
+    RL_DEBUG_MSG("positionwindow start (win %p (%lu) @ %i, %i)\n", pWin, RootlessWID(pWin), x, y);
 
     if (winRec) {
         if (winRec->is_drawing) {
@@ -441,7 +441,7 @@ RootlessRealizeWindow(WindowPtr pWin)
     RegionRec saveRoot;
     ScreenPtr pScreen = pWin->drawable.pScreen;
 
-    RL_DEBUG_MSG("realizewindow start (win 0x%x) ", pWin);
+    RL_DEBUG_MSG("realizewindow start (win %p (%lu)) ", pWin, RootlessWID(pWin));
 
     if ((IsTopLevel(pWin) && pWin->drawable.class == InputOutput)) {
         RootlessWindowRec *winRec;
@@ -625,11 +625,6 @@ RootlessRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib)
  */
 
 // Globals needed during window resize and move.
-static void *gResizeDeathBits = NULL;
-static int gResizeDeathCount = 0;
-static PixmapPtr gResizeDeathPix[2] = { NULL, NULL };
-
-static BoxRec gResizeDeathBounds[2];
 static CopyWindowProcPtr gResizeOldCopyWindowProc = NULL;
 
 /*
@@ -649,74 +644,6 @@ RootlessNoCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     RegionTranslate(prgnSrc, -dx, -dy);
 }
 
-/*
- * RootlessResizeCopyWindow
- *  CopyWindow used during ResizeWindow for gravity moves. Based on
- *  fbCopyWindow. The original always draws on the root pixmap, which
- *  we don't have. Instead, draw on the parent window's pixmap.
- *  Resize version: the old location's pixels are in gResizeCopyWindowSource.
- */
-static void
-RootlessResizeCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
-                         RegionPtr prgnSrc)
-{
-    ScreenPtr pScreen = pWin->drawable.pScreen;
-    RegionRec rgnDst;
-    int dx, dy;
-
-    RL_DEBUG_MSG("resizecopywindowFB start (win 0x%x) ", pWin);
-
-    /* Don't unwrap pScreen->CopyWindow.
-       The bogus rewrap with RootlessCopyWindow causes a crash if
-       CopyWindow is called again during the same resize. */
-
-    if (gResizeDeathCount == 0)
-        return;
-
-    RootlessStartDrawing(pWin);
-
-    dx = ptOldOrg.x - pWin->drawable.x;
-    dy = ptOldOrg.y - pWin->drawable.y;
-    RegionTranslate(prgnSrc, -dx, -dy);
-    RegionNull(&rgnDst);
-    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
-
-    if (gResizeDeathCount == 1) {
-        /* Simple case, we only have a single source pixmap. */
-
-        miCopyRegion(&gResizeDeathPix[0]->drawable,
-                     &pScreen->GetWindowPixmap(pWin)->drawable, 0,
-                     &rgnDst, dx, dy, fbCopyWindowProc, 0, 0);
-    }
-    else {
-        int i;
-        RegionRec clip, clipped;
-
-        /* More complex case, N source pixmaps (usually two). So we
-           intersect the destination with each source and copy those bits. */
-
-        for (i = 0; i < gResizeDeathCount; i++) {
-            RegionInit(&clip, gResizeDeathBounds + 0, 1);
-            RegionNull(&clipped);
-            RegionIntersect(&rgnDst, &clip, &clipped);
-
-            miCopyRegion(&gResizeDeathPix[i]->drawable,
-                         &pScreen->GetWindowPixmap(pWin)->drawable, 0,
-                         &clipped, dx, dy, fbCopyWindowProc, 0, 0);
-
-            RegionUninit(&clipped);
-            RegionUninit(&clip);
-        }
-    }
-
-    /* Don't update - resize will update everything */
-    RegionUninit(&rgnDst);
-
-    fbValidateDrawable(&pWin->drawable);
-
-    RL_DEBUG_MSG("resizecopywindowFB end\n");
-}
-
 /*
  * RootlessCopyWindow
  *  Update *new* location of window. Old location is redrawn with
@@ -733,7 +660,7 @@ RootlessCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     BoxPtr extents;
     int area;
 
-    RL_DEBUG_MSG("copywindowFB start (win 0x%x) ", pWin);
+    RL_DEBUG_MSG("copywindowFB start (win %p (%lu)) ", pWin, RootlessWID(pWin));
 
     SCREEN_UNWRAP(pScreen, CopyWindow);
 
@@ -778,11 +705,17 @@ RootlessCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     else {
         RootlessStartDrawing(pWin);
 
-        miCopyRegion((DrawablePtr) pWin, (DrawablePtr) pWin,
+        PixmapPtr pPixmap = pScreen->GetWindowPixmap(pWin);
+        DrawablePtr pDrawable = &pPixmap->drawable;
+
+        if (pPixmap->screen_x || pPixmap->screen_y) {
+            RegionTranslate(&rgnDst, -pPixmap->screen_x, -pPixmap->screen_y);
+        }
+
+        miCopyRegion(pDrawable, pDrawable,
                      0, &rgnDst, dx, dy, fbCopyWindowProc, 0, 0);
 
-        /* prgnSrc has been translated to dst position */
-        RootlessDamageRegion(pWin, prgnSrc);
+        RootlessDamageRegion(pWin, &rgnDst);
     }
 
  out:
@@ -833,7 +766,6 @@ static inline unsigned int
 ResizeWeighting(int oldX1, int oldY1, int oldX2, int oldY2, int oldBW,
                 int newX1, int newY1, int newX2, int newY2, int newBW)
 {
-#ifdef ROOTLESS_RESIZE_GRAVITY
     if (newBW != oldBW)
         return RL_GRAVITY_NONE;
 
@@ -846,10 +778,7 @@ ResizeWeighting(int oldX1, int oldY1, int oldX2, int oldY2, int oldBW,
     else if (newX2 == oldX2 && newY1 == oldY1)
         return RL_GRAVITY_NORTH_EAST;
     else
-        return RL_GRAVITY_NONE;
-#else
-    return RL_GRAVITY_NONE;
-#endif
+        return RL_GRAVITY_NORTH_WEST;
 }
 
 /*
@@ -858,14 +787,13 @@ ResizeWeighting(int oldX1, int oldY1, int oldX2, int oldY2, int oldBW,
  *  saved and the implementation is told to change the window size.
  *  (x,y,w,h) is outer frame of window (outside border)
  */
-static Bool
+static void
 StartFrameResize(WindowPtr pWin, Bool gravity,
                  int oldX, int oldY, int oldW, int oldH, int oldBW,
                  int newX, int newY, int newW, int newH, int newBW)
 {
     ScreenPtr pScreen = pWin->drawable.pScreen;
     RootlessWindowRec *winRec = WINREC(pWin);
-    Bool need_window_source = FALSE, resize_after = FALSE;
 
     BoxRec rect;
     int oldX2, newX2;
@@ -891,279 +819,44 @@ StartFrameResize(WindowPtr pWin, Bool gravity,
 
     RootlessRedisplay(pWin);
 
-    /* If gravity is true, then we need to have a way of recovering all
-       the original bits in the window for when X rearranges the contents
-       based on the various gravity settings. The obvious way is to just
-       snapshot the entire backing store before resizing it, but that
-       it slow on large windows.
-
-       So the optimization here is to use the implementation's resize
-       weighting options (if available) to allow us to reason about what
-       is left in the backing store after the resize. We can then only
-       copy what won't be there after the resize, and do a two-stage copy
-       operation.
-
-       Most of these optimizations are only applied when the top-left
-       corner of the window is fixed, since that's the common case. They
-       could probably be extended with some thought. */
-
-    gResizeDeathCount = 0;
-
-    if (gravity && weight == RL_GRAVITY_NORTH_WEST) {
-        unsigned int code = 0;
-
-        /* Top left corner is anchored. We never need to copy the
-           entire window. */
-
-        need_window_source = TRUE;
-
-        /* These comparisons were chosen to avoid setting bits when the sizes
-           are the same. (So the fastest case automatically gets taken when
-           dimensions are unchanging.) */
-
-        if (newW < oldW)
-            code |= WIDTH_SMALLER;
-        if (newH < oldH)
-            code |= HEIGHT_SMALLER;
-
-        if (((code ^ (code >> 1)) & 1) == 0) {
-            /* Both dimensions are either getting larger, or both
-               are getting smaller. No need to copy anything. */
-
-            if (code == (WIDTH_SMALLER | HEIGHT_SMALLER)) {
-                /* Since the window is getting smaller, we can do gravity
-                   repair on it with its current size, then resize it
-                   afterwards. */
-
-                resize_after = TRUE;
-            }
-
-            gResizeDeathCount = 1;
-        }
-        else {
-            unsigned int copy_rowbytes, Bpp;
-            unsigned int copy_rect_width, copy_rect_height;
-            BoxRec copy_rect;
-
-            /* We can get away with a partial copy. 'rect' is the
-               intersection between old and new bounds, so copy
-               everything to the right of or below the intersection. */
-
-            RootlessStartDrawing(pWin);
-
-            if (code == WIDTH_SMALLER) {
-                copy_rect.x1 = rect.x2;
-                copy_rect.y1 = rect.y1;
-                copy_rect.x2 = oldX2;
-                copy_rect.y2 = oldY2;
-            }
-            else if (code == HEIGHT_SMALLER) {
-                copy_rect.x1 = rect.x1;
-                copy_rect.y1 = rect.y2;
-                copy_rect.x2 = oldX2;
-                copy_rect.y2 = oldY2;
-            }
-            else
-                OsAbort();
-
-            Bpp = winRec->win->drawable.bitsPerPixel / 8;
-            copy_rect_width = copy_rect.x2 - copy_rect.x1;
-            copy_rect_height = copy_rect.y2 - copy_rect.y1;
-            copy_rowbytes = ((copy_rect_width * Bpp) + 31) & ~31;
-            gResizeDeathBits = xallocarray(copy_rowbytes, copy_rect_height);
-
-            if (copy_rect_width * copy_rect_height >
-                rootless_CopyBytes_threshold &&
-                SCREENREC(pScreen)->imp->CopyBytes) {
-                SCREENREC(pScreen)->imp->CopyBytes(copy_rect_width * Bpp,
-                                                   copy_rect_height,
-                                                   ((char *) winRec->pixelData)
-                                                   +
-                                                   ((copy_rect.y1 -
-                                                     oldY) *
-                                                    winRec->bytesPerRow)
-                                                   + (copy_rect.x1 -
-                                                      oldX) * Bpp,
-                                                   winRec->bytesPerRow,
-                                                   gResizeDeathBits,
-                                                   copy_rowbytes);
-            }
-            else {
-                fbBlt((FbBits *) (winRec->pixelData
-                                  +
-                                  ((copy_rect.y1 - oldY) * winRec->bytesPerRow)
-                                  + (copy_rect.x1 - oldX) * Bpp),
-                      winRec->bytesPerRow / sizeof(FbBits), 0,
-                      (FbBits *) gResizeDeathBits,
-                      copy_rowbytes / sizeof(FbBits), 0, copy_rect_width * Bpp,
-                      copy_rect_height, GXcopy, FB_ALLONES, Bpp, 0, 0);
-            }
-
-            gResizeDeathBounds[1] = copy_rect;
-            gResizeDeathPix[1]
-                = GetScratchPixmapHeader(pScreen, copy_rect_width,
-                                         copy_rect_height,
-                                         winRec->win->drawable.depth,
-                                         winRec->win->drawable.bitsPerPixel,
-                                         winRec->bytesPerRow,
-                                         (void *) gResizeDeathBits);
-
-            SetPixmapBaseToScreen(gResizeDeathPix[1],
-                                  copy_rect.x1, copy_rect.y1);
-
-            gResizeDeathCount = 2;
-        }
-    }
-    else if (gravity) {
-        /* The general case. Just copy everything. */
-
-        RootlessStartDrawing(pWin);
-
-        gResizeDeathBits = xallocarray(winRec->bytesPerRow, winRec->height);
-
-        memcpy(gResizeDeathBits, winRec->pixelData,
-               winRec->bytesPerRow * winRec->height);
-
-        gResizeDeathBounds[0] = (BoxRec) {
-        oldX, oldY, oldX2, oldY2};
-        gResizeDeathPix[0]
-            = GetScratchPixmapHeader(pScreen, winRec->width,
-                                     winRec->height,
-                                     winRec->win->drawable.depth,
-                                     winRec->win->drawable.bitsPerPixel,
-                                     winRec->bytesPerRow,
-                                     (void *) gResizeDeathBits);
-
-        SetPixmapBaseToScreen(gResizeDeathPix[0], oldX, oldY);
-        gResizeDeathCount = 1;
-    }
-
-    RootlessStopDrawing(pWin, FALSE);
-
     winRec->x = newX;
     winRec->y = newY;
     winRec->width = newW;
     winRec->height = newH;
     winRec->borderWidth = newBW;
 
-    /* Unless both dimensions are getting smaller, Resize the frame
-       before doing gravity repair */
-
-    if (!resize_after) {
-        SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
-                                             newX + SCREEN_TO_GLOBAL_X,
-                                             newY + SCREEN_TO_GLOBAL_Y,
-                                             newW, newH, weight);
-    }
+    SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
+                                         newX + SCREEN_TO_GLOBAL_X,
+                                         newY + SCREEN_TO_GLOBAL_Y,
+                                         newW, newH, weight);
 
     RootlessStartDrawing(pWin);
 
-    /* If necessary, create a source pixmap pointing at the current
-       window bits. */
-
-    if (need_window_source) {
-        gResizeDeathBounds[0] = (BoxRec) {
-        oldX, oldY, oldX2, oldY2};
-        gResizeDeathPix[0]
-            = GetScratchPixmapHeader(pScreen, oldW, oldH,
-                                     winRec->win->drawable.depth,
-                                     winRec->win->drawable.bitsPerPixel,
-                                     winRec->bytesPerRow, winRec->pixelData);
-
-        SetPixmapBaseToScreen(gResizeDeathPix[0], oldX, oldY);
-    }
-
     /* Use custom CopyWindow when moving gravity bits around
        ResizeWindow assumes the old window contents are in the same
        pixmap, but here they're in deathPix instead. */
 
     if (gravity) {
         gResizeOldCopyWindowProc = pScreen->CopyWindow;
-        pScreen->CopyWindow = RootlessResizeCopyWindow;
-    }
-
-    /* If we can't rely on the window server preserving the bits we
-       need in the position we need, copy the pixels in the
-       intersection from src to dst. ResizeWindow assumes these pixels
-       are already present when making gravity adjustments. pWin
-       currently has new-sized pixmap but is in old position.
-
-       FIXME: border width change! (?) */
-
-    if (gravity && weight == RL_GRAVITY_NONE) {
-        PixmapPtr src, dst;
-
-        assert(gResizeDeathCount == 1);
-
-        src = gResizeDeathPix[0];
-        dst = pScreen->GetWindowPixmap(pWin);
-
-        RL_DEBUG_MSG("Resize copy rect %d %d %d %d\n",
-                     rect.x1, rect.y1, rect.x2, rect.y2);
-
-        /* rect is the intersection of the old location and new location */
-        if (BOX_NOT_EMPTY(rect) && src != NULL && dst != NULL) {
-            /* The window drawable still has the old frame position, which
-               means that DST doesn't actually point at the origin of our
-               physical backing store when adjusted by the drawable.x,y
-               position. So sneakily adjust it temporarily while copying.. */
-
-            ((PixmapPtr) dst)->devPrivate.ptr = winRec->pixelData;
-            SetPixmapBaseToScreen(dst, newX, newY);
-
-            fbCopyWindowProc(&src->drawable, &dst->drawable, NULL,
-                             &rect, 1, 0, 0, FALSE, FALSE, 0, 0);
-
-            ((PixmapPtr) dst)->devPrivate.ptr = winRec->pixelData;
-            SetPixmapBaseToScreen(dst, oldX, oldY);
-        }
+        pScreen->CopyWindow = RootlessNoCopyWindow;
     }
-
-    return resize_after;
 }
 
 static void
 FinishFrameResize(WindowPtr pWin, Bool gravity, int oldX, int oldY,
                   unsigned int oldW, unsigned int oldH, unsigned int oldBW,
                   int newX, int newY, unsigned int newW, unsigned int newH,
-                  unsigned int newBW, Bool resize_now)
+                  unsigned int newBW)
 {
     ScreenPtr pScreen = pWin->drawable.pScreen;
     RootlessWindowRec *winRec = WINREC(pWin);
     int i;
 
-    RootlessStopDrawing(pWin, FALSE);
-
-    if (resize_now) {
-        unsigned int weight;
-
-        /* We didn't resize anything earlier, so do it now, now that
-           we've finished gravitating the bits. */
-
-        weight = ResizeWeighting(oldX, oldY, oldW, oldH, oldBW,
-                                 newX, newY, newW, newH, newBW);
-
-        SCREENREC(pScreen)->imp->ResizeFrame(winRec->wid, pScreen,
-                                             newX + SCREEN_TO_GLOBAL_X,
-                                             newY + SCREEN_TO_GLOBAL_Y,
-                                             newW, newH, weight);
-    }
-
     /* Redraw everything. FIXME: there must be times when we don't need
        to do this. Perhaps when top-left weighting and no gravity? */
 
     RootlessDamageRect(pWin, -newBW, -newBW, newW, newH);
 
-    for (i = 0; i < 2; i++) {
-        if (gResizeDeathPix[i] != NULL) {
-            FreeScratchPixmapHeader(gResizeDeathPix[i]);
-            gResizeDeathPix[i] = NULL;
-        }
-    }
-
-    free(gResizeDeathBits);
-    gResizeDeathBits = NULL;
-
     if (gravity) {
         pScreen->CopyWindow = gResizeOldCopyWindowProc;
     }
@@ -1183,7 +876,6 @@ RootlessMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
     int oldX = 0, oldY = 0, newX = 0, newY = 0;
     unsigned int oldW = 0, oldH = 0, oldBW = 0;
     unsigned int newW = 0, newH = 0, newBW = 0;
-    Bool resize_after = FALSE;
     RegionRec saveRoot;
 
     RL_DEBUG_MSG("movewindow start \n");
@@ -1210,9 +902,9 @@ RootlessMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
             newW = pWin->drawable.width + 2 * newBW;
             newH = pWin->drawable.height + 2 * newBW;
 
-            resize_after = StartFrameResize(pWin, FALSE,
-                                            oldX, oldY, oldW, oldH, oldBW,
-                                            newX, newY, newW, newH, newBW);
+            StartFrameResize(pWin, FALSE,
+                             oldX, oldY, oldW, oldH, oldBW,
+                             newX, newY, newW, newH, newBW);
         }
     }
 
@@ -1241,8 +933,9 @@ RootlessMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind)
                                                y + SCREEN_TO_GLOBAL_Y);
         }
         else {
-            FinishFrameResize(pWin, FALSE, oldX, oldY, oldW, oldH, oldBW,
-                              newX, newY, newW, newH, newBW, resize_after);
+            FinishFrameResize(pWin, FALSE,
+                              oldX, oldY, oldW, oldH, oldBW,
+                              newX, newY, newW, newH, newBW);
         }
     }
 
@@ -1265,10 +958,9 @@ RootlessResizeWindow(WindowPtr pWin, int x, int y,
     ScreenPtr pScreen = pWin->drawable.pScreen;
     int oldX = 0, oldY = 0, newX = 0, newY = 0;
     unsigned int oldW = 0, oldH = 0, oldBW = 0, newW = 0, newH = 0, newBW = 0;
-    Bool resize_after = FALSE;
     RegionRec saveRoot;
 
-    RL_DEBUG_MSG("resizewindow start (win 0x%x) ", pWin);
+    RL_DEBUG_MSG("resizewindow start (win %p (%lu)) ", pWin, RootlessWID(pWin));
 
     if (pWin->parent) {
         if (winRec) {
@@ -1284,9 +976,9 @@ RootlessResizeWindow(WindowPtr pWin, int x, int y,
             newW = w + 2 * newBW;
             newH = h + 2 * newBW;
 
-            resize_after = StartFrameResize(pWin, TRUE,
-                                            oldX, oldY, oldW, oldH, oldBW,
-                                            newX, newY, newW, newH, newBW);
+            StartFrameResize(pWin, TRUE,
+                             oldX, oldY, oldW, oldH, oldBW,
+                             newX, newY, newW, newH, newBW);
         }
 
         HUGE_ROOT(pWin);
@@ -1296,8 +988,9 @@ RootlessResizeWindow(WindowPtr pWin, int x, int y,
         NORMAL_ROOT(pWin);
 
         if (winRec) {
-            FinishFrameResize(pWin, TRUE, oldX, oldY, oldW, oldH, oldBW,
-                              newX, newY, newW, newH, newBW, resize_after);
+            FinishFrameResize(pWin, TRUE,
+                              oldX, oldY, oldW, oldH, oldBW,
+                              newX, newY, newW, newH, newBW);
         }
     }
     else {
@@ -1454,7 +1147,6 @@ void
 RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width)
 {
     RegionRec saveRoot;
-    Bool resize_after = FALSE;
 
     RL_DEBUG_MSG("change border width ");
 
@@ -1477,9 +1169,9 @@ RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width)
             newW = pWin->drawable.width + 2 * newBW;
             newH = pWin->drawable.height + 2 * newBW;
 
-            resize_after = StartFrameResize(pWin, FALSE,
-                                            oldX, oldY, oldW, oldH, oldBW,
-                                            newX, newY, newW, newH, newBW);
+            StartFrameResize(pWin, FALSE,
+                             oldX, oldY, oldW, oldH, oldBW,
+                             newX, newY, newW, newH, newBW);
         }
 
         HUGE_ROOT(pWin);
@@ -1489,8 +1181,9 @@ RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width)
         NORMAL_ROOT(pWin);
 
         if (winRec) {
-            FinishFrameResize(pWin, FALSE, oldX, oldY, oldW, oldH, oldBW,
-                              newX, newY, newW, newH, newBW, resize_after);
+            FinishFrameResize(pWin, FALSE,
+                              oldX, oldY, oldW, oldH, oldBW,
+                              newX, newY, newW, newH, newBW);
         }
     }
 
@@ -1649,7 +1342,7 @@ RootlessSetPixmapOfAncestors(WindowPtr pWin)
             XID pixel = 0;
 
             ChangeWindowAttributes(pWin, CWBackPixel, &pixel, serverClient);
-            RL_DEBUG_MSG("Cleared ParentRelative on 0x%x.\n", pWin);
+            RL_DEBUG_MSG("Cleared ParentRelative on %p (%lu).\n", pWin, RootlessWID(pWin));
             break;
         }
 
diff --git a/miext/shadow/Makefile.am b/miext/shadow/Makefile.am
deleted file mode 100644
index dabbf038c..000000000
--- a/miext/shadow/Makefile.am
+++ /dev/null
@@ -1,37 +0,0 @@
-noinst_LTLIBRARIES = libshadow.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-if XORG
-sdk_HEADERS = shadow.h
-endif
-
-libshadow_la_SOURCES =		\
-	c2p_core.h		\
-	shadow.c		\
-	shadow.h		\
-	sh3224.c		\
-	shafb4.c		\
-	shafb8.c		\
-	shiplan2p4.c		\
-	shiplan2p8.c		\
-	shpacked.c		\
-	shplanar8.c		\
-	shplanar.c		\
-	shrot16pack_180.c	\
-	shrot16pack_270.c	\
-	shrot16pack_270YX.c	\
-	shrot16pack_90.c	\
-	shrot16pack_90YX.c	\
-	shrot16pack.c		\
-	shrot32pack_180.c	\
-	shrot32pack_270.c	\
-	shrot32pack_90.c	\
-	shrot32pack.c		\
-	shrot8pack_180.c	\
-	shrot8pack_270.c	\
-	shrot8pack_90.c		\
-	shrot8pack.c		\
-	shrotate.c		\
-	shrotpack.h		\
-	shrotpackYX.h
diff --git a/miext/sync/Makefile.am b/miext/sync/Makefile.am
deleted file mode 100644
index 34961d5ff..000000000
--- a/miext/sync/Makefile.am
+++ /dev/null
@@ -1,21 +0,0 @@
-noinst_LTLIBRARIES = libsync.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-AM_CPPFLAGS = 
-
-if XORG
-sdk_HEADERS = misync.h misyncstr.h misyncshm.h misyncfd.h
-endif
-
-XSHMFENCE_SRCS = misyncshm.c
-
-libsync_la_SOURCES =	\
-	misync.c	\
-	misync.h	\
-	misyncfd.c	\
-	misyncstr.h
-
-if XSHMFENCE
-libsync_la_SOURCES += $(XSHMFENCE_SRCS)
-endif
diff --git a/miext/sync/meson.build b/miext/sync/meson.build
index 78716e441..0892fd807 100644
--- a/miext/sync/meson.build
+++ b/miext/sync/meson.build
@@ -10,7 +10,7 @@ hdrs_miext_sync = [
     'misyncstr.h',
 ]
 
-if build_dri3
+if build_dri3 or build_xwayland
     srcs_miext_sync += 'misyncshm.c'
 endif
 
diff --git a/os/Makefile.am b/os/Makefile.am
deleted file mode 100644
index 30f516cfa..000000000
--- a/os/Makefile.am
+++ /dev/null
@@ -1,69 +0,0 @@
-noinst_LTLIBRARIES = libos.la
-
-AM_CFLAGS = $(DIX_CFLAGS) $(SHA1_CFLAGS)
-
-SECURERPC_SRCS = rpcauth.c
-XDMCP_SRCS = xdmcp.c
-XORG_SRCS = log.c
-BUSFAULT_SRCS = busfault.c
-
-XSERVER_POLL_SRCS=xserver_poll.c
-
-libos_la_SOURCES = 	\
-	WaitFor.c	\
-	access.c	\
-	auth.c		\
-	backtrace.c	\
-	client.c	\
-	connection.c	\
-	inputthread.c	\
-	io.c		\
-	mitauth.c	\
-	oscolor.c	\
-	osdep.h		\
-	osinit.c	\
-	ospoll.c	\
-	ospoll.h	\
-	utils.c		\
-	xdmauth.c	\
-	xsha1.c		\
-	xstrans.c	\
-	xprintf.c	\
-	$(XORG_SRCS)
-libos_la_LIBADD = @SHA1_LIBS@ $(DLOPEN_LIBS) $(LTLIBOBJS)
-
-if SECURE_RPC
-libos_la_SOURCES += $(SECURERPC_SRCS)
-endif
-
-if POLL
-else
-libos_la_SOURCES += $(XSERVER_POLL_SRCS)
-endif
-
-if XDMCP
-libos_la_SOURCES += $(XDMCP_SRCS)
-endif
-
-if HAVE_LIBUNWIND
-AM_CFLAGS += $(LIBUNWIND_CFLAGS)
-libos_la_LIBADD += $(LIBUNWIND_LIBS)
-endif
-
-if BUSFAULT
-libos_la_SOURCES += $(BUSFAULT_SRCS)
-endif
-
-EXTRA_DIST = $(SECURERPC_SRCS) $(XDMCP_SRCS)
-
-if SPECIAL_DTRACE_OBJECTS
-# Generate dtrace object code for probes in libos & libdix
-dtrace.o: $(top_srcdir)/include/Xserver.d libos.la
-	$(AM_V_GEN)$(DTRACE) -G -C -o $@ -s $(top_srcdir)/include/Xserver.d .libs/*.o ../dix/.libs/*.o
-
-noinst_PROGRAMS = os.O
-
-os_O_SOURCES =
-os.O: dtrace.o libos.la
-	$(AM_V_GEN)ld -r -o $@ dtrace.o .libs/*.o
-endif
diff --git a/os/access.c b/os/access.c
index b1703048d..61ee8e30f 100644
--- a/os/access.c
+++ b/os/access.c
@@ -116,6 +116,10 @@ SOFTWARE.
 #endif
 #endif
 
+#ifdef HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+
 #if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__)
 #include <sys/utsname.h>
 #endif
@@ -1167,15 +1171,19 @@ GetLocalClientCreds(ClientPtr client, LocalClientCredRec ** lccp)
     XtransConnInfo ci;
     LocalClientCredRec *lcc;
 
-#ifdef HAVE_GETPEEREID
-    uid_t uid;
-    gid_t gid;
-#elif defined(HAVE_GETPEERUCRED)
+#if defined(HAVE_GETPEERUCRED)
     ucred_t *peercred = NULL;
     const gid_t *gids;
 #elif defined(SO_PEERCRED)
     struct ucred peercred;
     socklen_t so_len = sizeof(peercred);
+#elif defined(HAVE_GETPEEREID)
+    uid_t uid;
+    gid_t gid;
+#if defined(LOCAL_PEERPID)
+    pid_t pid;
+    socklen_t so_len = sizeof(pid);
+#endif
 #endif
 
     if (client == NULL)
@@ -1197,16 +1205,7 @@ GetLocalClientCreds(ClientPtr client, LocalClientCredRec ** lccp)
     lcc = *lccp;
 
     fd = _XSERVTransGetConnectionNumber(ci);
-#ifdef HAVE_GETPEEREID
-    if (getpeereid(fd, &uid, &gid) == -1) {
-        FreeLocalClientCreds(lcc);
-        return -1;
-    }
-    lcc->euid = uid;
-    lcc->egid = gid;
-    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET;
-    return 0;
-#elif defined(HAVE_GETPEERUCRED)
+#if defined(HAVE_GETPEERUCRED)
     if (getpeerucred(fd, &peercred) < 0) {
         FreeLocalClientCreds(lcc);
         return -1;
@@ -1253,6 +1252,25 @@ GetLocalClientCreds(ClientPtr client, LocalClientCredRec ** lccp)
     lcc->egid = peercred.gid;
     lcc->pid = peercred.pid;
     lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET | LCC_PID_SET;
+    return 0;
+#elif defined(HAVE_GETPEEREID)
+    if (getpeereid(fd, &uid, &gid) == -1) {
+        FreeLocalClientCreds(lcc);
+        return -1;
+    }
+    lcc->euid = uid;
+    lcc->egid = gid;
+    lcc->fieldsSet = LCC_UID_SET | LCC_GID_SET;
+
+#if defined(LOCAL_PEERPID)
+    if (getsockopt(fd, SOL_LOCAL, LOCAL_PEERPID, &pid, &so_len) != 0) {
+        ErrorF("getsockopt failed to determine pid of socket %d: %s\n", fd, strerror(errno));
+    } else {
+        lcc->pid = pid;
+        lcc->fieldsSet |= LCC_PID_SET;
+    }
+#endif
+
     return 0;
 #endif
 #else
diff --git a/os/backtrace.c b/os/backtrace.c
index 99d776950..8025bffae 100644
--- a/os/backtrace.c
+++ b/os/backtrace.c
@@ -40,15 +40,73 @@
 #endif
 #include <dlfcn.h>
 
+static void
+print_registers(int frame, unw_cursor_t cursor)
+{
+    const struct {
+        const char *name;
+        int regnum;
+    } regs[] = {
+#if UNW_TARGET_X86_64
+        { "rax", UNW_X86_64_RAX },
+        { "rbx", UNW_X86_64_RBX },
+        { "rcx", UNW_X86_64_RCX },
+        { "rdx", UNW_X86_64_RDX },
+        { "rsi", UNW_X86_64_RSI },
+        { "rdi", UNW_X86_64_RDI },
+        { "rbp", UNW_X86_64_RBP },
+        { "rsp", UNW_X86_64_RSP },
+        { " r8", UNW_X86_64_R8  },
+        { " r9", UNW_X86_64_R9  },
+        { "r10", UNW_X86_64_R10 },
+        { "r11", UNW_X86_64_R11 },
+        { "r12", UNW_X86_64_R12 },
+        { "r13", UNW_X86_64_R13 },
+        { "r14", UNW_X86_64_R14 },
+        { "r15", UNW_X86_64_R15 },
+#endif
+    };
+    const int num_regs = sizeof(regs) / sizeof(*regs);
+    int ret, i;
+
+    if (num_regs == 0)
+        return;
+
+    /*
+     * Advance the cursor from the signal frame to the one that triggered the
+     * signal.
+     */
+    frame++;
+    ret = unw_step(&cursor);
+    if (ret < 0) {
+        ErrorFSigSafe("unw_step failed: %s [%d]\n", unw_strerror(ret), ret);
+        return;
+    }
+
+    ErrorFSigSafe("\n");
+    ErrorFSigSafe("Registers at frame #%d:\n", frame);
+
+    for (i = 0; i < num_regs; i++) {
+        uint64_t val;
+        ret = unw_get_reg(&cursor, regs[i].regnum, &val);
+        if (ret < 0) {
+            ErrorFSigSafe("unw_get_reg(%s) failed: %s [%d]\n",
+                          regs[i].name, unw_strerror(ret), ret);
+        } else {
+            ErrorFSigSafe("  %s: 0x%" PRIx64 "\n", regs[i].name, val);
+        }
+    }
+}
+
 void
 xorg_backtrace(void)
 {
-    unw_cursor_t cursor;
+    unw_cursor_t cursor, signal_cursor;
     unw_context_t context;
     unw_word_t ip;
     unw_word_t off;
     unw_proc_info_t pip;
-    int ret, i = 0;
+    int ret, i = 0, signal_frame = -1;
     char procname[256];
     const char *filename;
     Dl_info dlinfo;
@@ -97,14 +155,26 @@ xorg_backtrace(void)
         else
             filename = "?";
 
-        ErrorFSigSafe("%u: %s (%s%s+0x%x) [%p]\n", i++, filename, procname,
-            ret == -UNW_ENOMEM ? "..." : "", (int)off,
-            (void *)(uintptr_t)(ip));
+
+        if (unw_is_signal_frame(&cursor)) {
+            signal_cursor = cursor;
+            signal_frame = i;
+
+            ErrorFSigSafe("%u: <signal handler called>\n", i++);
+        } else {
+            ErrorFSigSafe("%u: %s (%s%s+0x%x) [%p]\n", i++, filename, procname,
+                ret == -UNW_ENOMEM ? "..." : "", (int)off,
+                (void *)(uintptr_t)(ip));
+        }
 
         ret = unw_step(&cursor);
         if (ret < 0)
             ErrorFSigSafe("unw_step failed: %s [%d]\n", unw_strerror(ret), ret);
     }
+
+    if (signal_frame >= 0)
+        print_registers(signal_frame, signal_cursor);
+
     ErrorFSigSafe("\n");
 }
 #else /* HAVE_LIBUNWIND */
diff --git a/os/client.c b/os/client.c
index 89a92d5b5..922172cc5 100644
--- a/os/client.c
+++ b/os/client.c
@@ -73,6 +73,12 @@
 #include <limits.h>
 #endif
 
+#ifdef __APPLE__
+#include <dispatch/dispatch.h>
+#include <errno.h>
+#include <sys/sysctl.h>
+#endif
+
 /**
  * Try to determine a PID for a client from its connection
  * information. This should be called only once when new client has
@@ -130,9 +136,11 @@ DetermineClientPid(struct _Client * client)
 void
 DetermineClientCmd(pid_t pid, const char **cmdname, const char **cmdargs)
 {
+#if !defined(__APPLE__)
     char path[PATH_MAX + 1];
     int totsize = 0;
     int fd = 0;
+#endif
 
     if (cmdname)
         *cmdname = NULL;
@@ -142,7 +150,107 @@ DetermineClientCmd(pid_t pid, const char **cmdname, const char **cmdargs)
     if (pid == -1)
         return;
 
-#if defined(__OpenBSD__)
+#if defined (__APPLE__)
+    {
+        static dispatch_once_t once;
+        static int argmax;
+        dispatch_once(&once, ^{
+            int mib[2];
+            size_t len;
+
+            mib[0] = CTL_KERN;
+            mib[1] = KERN_ARGMAX;
+
+            len = sizeof(argmax);
+            if (sysctl(mib, 2, &argmax, &len, NULL, 0) == -1) {
+                ErrorF("Unable to dynamically determine kern.argmax, using ARG_MAX (%d)\n", ARG_MAX);
+                argmax = ARG_MAX;
+            }
+        });
+
+        int mib[3];
+        size_t len = argmax;
+        int32_t argc = -1;
+
+        char * const procargs = malloc(len);
+        if (!procargs) {
+            ErrorF("Failed to allocate memory (%lu bytes) for KERN_PROCARGS2 result for pid %d: %s\n", len, pid, strerror(errno));
+            return;
+        }
+
+        mib[0] = CTL_KERN;
+        mib[1] = KERN_PROCARGS2;
+        mib[2] = pid;
+
+        if (sysctl(mib, 3, procargs, &len, NULL, 0) == -1) {
+            ErrorF("Failed to determine KERN_PROCARGS2 for pid %d: %s\n", pid, strerror(errno));
+            free(procargs);
+            return;
+        }
+
+        if (len < sizeof(argc) || len > argmax) {
+            ErrorF("Erroneous length returned when querying KERN_PROCARGS2 for pid %d: %zu\n", pid, len);
+            free(procargs);
+            return;
+        }
+
+        /* Ensure we have a failsafe NUL termination just in case the last entry
+         * was not actually NUL terminated.
+         */
+        procargs[len-1] = '\0';
+
+        /* Setup our iterator */
+        char *is = procargs;
+
+        /* The first element in the buffer is argc as a 32bit int. When using
+         * the older KERN_PROCARGS, this is omitted, and one needs to guess
+         * (usually by checking for an `=` character) when we start seeing
+         * envvars instead of arguments.
+         */
+        argc = *(int32_t *)is;
+        is += sizeof(argc);
+
+        /* The very next string is the executable path.  Skip over it since
+         * this function wants to return argv[0] and argv[1...n].
+         */
+        is += strlen(is) + 1;
+
+        /* Skip over extra NUL characters to get to the start of argv[0] */
+        for (; (is < &procargs[len]) && !(*is); is++);
+
+        if (! (is < &procargs[len])) {
+            ErrorF("Arguments were not returned when querying KERN_PROCARGS2 for pid %d: %zu\n", pid, len);
+            free(procargs);
+            return;
+        }
+
+        if (cmdname) {
+            *cmdname = strdup(is);
+        }
+
+        /* Jump over argv[0] and point to argv[1] */
+        is += strlen(is) + 1;
+
+        if (cmdargs && is < &procargs[len]) {
+            char *args = is;
+
+            /* Remove the NUL terminators except the last one */
+            for (int i = 1; i < argc - 1; i++) {
+                /* Advance to the NUL terminator */
+                is += strlen(is);
+
+                /* Change the NUL to a space, ensuring we don't accidentally remove the terminal NUL */
+                if (is < &procargs[len-1]) {
+                    *is = ' ';
+                }
+            }
+
+            *cmdargs = strdup(args);
+        }
+
+        free(procargs);
+    }
+#elif defined(__OpenBSD__)
     /* on OpenBSD use kvm_getargv() */
     {
         kvm_t *kd;
diff --git a/os/connection.c b/os/connection.c
index 55f1cd32e..a3c8f2a99 100644
--- a/os/connection.c
+++ b/os/connection.c
@@ -637,8 +637,8 @@ AllocNewConnection(XtransConnInfo trans_conn, int fd, CARD32 conn_time)
     set_poll_client(client);
 
 #ifdef DEBUG
-    ErrorF("AllocNewConnection: client index = %d, socket fd = %d\n",
-           client->index, fd);
+    ErrorF("AllocNewConnection: client index = %d, socket fd = %d, local = %d\n",
+           client->index, fd, client->local);
 #endif
 #ifdef XSERVER_DTRACE
     XSERVER_CLIENT_CONNECT(client->index, fd);
@@ -1018,7 +1018,7 @@ ListenOnOpenFD(int fd, int noxauth)
         }
     }
 
-    if (!display_env) {
+    if (!display_env || display_env[0] != '/') {
         /* Just some default so things don't break and die. */
         snprintf(port, sizeof(port), ":%d", atoi(display));
     }
diff --git a/os/io.c b/os/io.c
index 5b7fac349..841a0ee40 100644
--- a/os/io.c
+++ b/os/io.c
@@ -790,7 +790,7 @@ WriteToClient(ClientPtr who, int count, const void *__buf)
         }
     }
 #endif
-    if (oco->count == 0 || oco->count + count + padBytes > oco->size) {
+    if ((oco->count == 0 && who->local) || oco->count + count + padBytes > oco->size) {
         output_pending_clear(who);
         if (!any_output_pending()) {
             CriticalOutputPending = FALSE;
diff --git a/os/meson.build b/os/meson.build
index ab28fc4ed..85b445f20 100644
--- a/os/meson.build
+++ b/os/meson.build
@@ -58,7 +58,7 @@ rpc_dep = []
 if get_option('secure-rpc')
     # prefer libtirpc (if available), otherwise ensure RPC functions are
     # provided by libc.
-    rpc_dep = dependency('libtirpc', required: false)
+    rpc_dep = dependency('libtirpc', required: false, include_type: 'system')
     if not (rpc_dep.found() or cc.has_header('rpc/rpc.h'))
         error('secure-rpc requested, but neither libtirpc or libc RPC support were found')
     endif
diff --git a/os/mitauth.c b/os/mitauth.c
index a268f62f9..eb5ca3998 100644
--- a/os/mitauth.c
+++ b/os/mitauth.c
@@ -62,7 +62,7 @@ MitAddCookie(unsigned short data_length, const char *data, XID id)
     }
     new->next = mit_auth;
     mit_auth = new;
-    memmove(new->data, data, (int) data_length);
+    memcpy(new->data, data, (size_t) data_length);
     new->len = data_length;
     new->id = id;
     return 1;
diff --git a/os/rpcauth.c b/os/rpcauth.c
index 33260db72..0a752f013 100644
--- a/os/rpcauth.c
+++ b/os/rpcauth.c
@@ -70,7 +70,7 @@ authdes_ezdecode(const char *inmsg, int len)
         why = AUTH_FAILED; /* generic error, since there is no AUTH_BADALLOC */
         return NULL;
     }
-    memmove(temp_inmsg, inmsg, len);
+    memcpy(temp_inmsg, inmsg, len);
 
     memset((char *) &msg, 0, sizeof(msg));
     memset((char *) &r, 0, sizeof(r));
diff --git a/os/utils.c b/os/utils.c
index 92a66e81a..405bf7d8b 100644
--- a/os/utils.c
+++ b/os/utils.c
@@ -189,6 +189,8 @@ Bool CoreDump;
 
 Bool enableIndirectGLX = FALSE;
 
+Bool AllowByteSwappedClients = FALSE;
+
 #ifdef PANORAMIX
 Bool PanoramiXExtensionDisabledHack = FALSE;
 #endif
@@ -523,6 +525,8 @@ UseMsg(void)
     ErrorF("-br                    create root window with black background\n");
     ErrorF("+bs                    enable any backing store support\n");
     ErrorF("-bs                    disable any backing store support\n");
+    ErrorF("+byteswappedclients    Allow clients with endianess different to that of the server\n");
+    ErrorF("-byteswappedclients    Prohibit clients with endianess different to that of the server\n");
     ErrorF("-c                     turns off key-click\n");
     ErrorF("c #                    key-click volume (0-100)\n");
     ErrorF("-cc int                default color visual class\n");
@@ -681,6 +685,7 @@ ProcessCommandLine(int argc, char *argv[])
                     ErrorF("Failed to disable listen for %s transport",
                            defaultNoListenList[i]);
     }
+    SeatId = getenv("XDG_SEAT");
 
     for (i = 1; i < argc; i++) {
         /* call ddx first, so it can peek/override if it wants */
@@ -719,6 +724,11 @@ ProcessCommandLine(int argc, char *argv[])
             else
                 UseMsg();
         }
+        else if (strcmp(argv[i], "-byteswappedclients") == 0) {
+            AllowByteSwappedClients = FALSE;
+        } else if (strcmp(argv[i], "+byteswappedclients") == 0) {
+            AllowByteSwappedClients = TRUE;
+        }
         else if (strcmp(argv[i], "-br") == 0);  /* default */
         else if (strcmp(argv[i], "+bs") == 0)
             enableBackingStore = TRUE;
@@ -1107,9 +1117,9 @@ set_font_authorizations(char **authorizations, int *authlen, void *client)
         *p++ = (len) >> 8;
         *p++ = (len & 0xff);
 
-        memmove(p, AUTHORIZATION_NAME, sizeof(AUTHORIZATION_NAME));
+        memcpy(p, AUTHORIZATION_NAME, sizeof(AUTHORIZATION_NAME));
         p += sizeof(AUTHORIZATION_NAME);
-        memmove(p, hnameptr, len);
+        memcpy(p, hnameptr, len);
         p += len;
 #if defined(IPv6) && defined(AF_INET6)
         if (ai) {
diff --git a/os/xdmauth.c b/os/xdmauth.c
index c35cade5b..ba446e013 100644
--- a/os/xdmauth.c
+++ b/os/xdmauth.c
@@ -356,8 +356,8 @@ XdmAddCookie(unsigned short data_length, const char *data, XID id)
         return 0;
     new->next = xdmAuth;
     xdmAuth = new;
-    memmove(new->key.data, key_bits, (int) 8);
-    memmove(new->rho.data, rho_bits, (int) 8);
+    memcpy(new->key.data, key_bits, 8);
+    memcpy(new->rho.data, rho_bits, 8);
     new->id = id;
     return 1;
 }
diff --git a/os/xdmcp.c b/os/xdmcp.c
index 093e30096..2b7255644 100644
--- a/os/xdmcp.c
+++ b/os/xdmcp.c
@@ -1409,7 +1409,7 @@ get_addr_by_name(const char *argtype,
         FatalError("Xserver: %s unknown host: %s\n", argtype, namestr);
     }
     if (hep->h_length == sizeof(struct in_addr)) {
-        memmove(&addr->sin_addr, hep->h_addr, hep->h_length);
+        memcpy(&addr->sin_addr, hep->h_addr, hep->h_length);
         *addrlen = sizeof(struct sockaddr_in);
         addr->sin_family = AF_INET;
         addr->sin_port = htons(port);
diff --git a/present/Makefile.am b/present/Makefile.am
deleted file mode 100644
index a2d58212c..000000000
--- a/present/Makefile.am
+++ /dev/null
@@ -1,19 +0,0 @@
-noinst_LTLIBRARIES = libpresent.la
-AM_CFLAGS = \
-	@DIX_CFLAGS@
-
-libpresent_la_SOURCES = \
-	present.h \
-	present.c \
-	present_event.c \
-	present_execute.c \
-	present_fake.c \
-	present_fence.c \
-	present_notify.c \
-	present_priv.h \
-	present_request.c \
-	present_scmd.c \
-	present_screen.c \
-	present_vblank.c
-
-sdk_HEADERS = present.h presentext.h
diff --git a/present/present.h b/present/present.h
index d41b36033..1d7b0ce42 100644
--- a/present/present.h
+++ b/present/present.h
@@ -29,7 +29,9 @@
 
 typedef enum {
     PRESENT_FLIP_REASON_UNKNOWN,
-    PRESENT_FLIP_REASON_BUFFER_FORMAT
+    PRESENT_FLIP_REASON_BUFFER_FORMAT,
+    PRESENT_FLIP_REASON_DRIVER_TEARFREE,
+    PRESENT_FLIP_REASON_DRIVER_TEARFREE_FLIPPING
 } PresentFlipReason;
 
 typedef struct present_vblank present_vblank_rec, *present_vblank_ptr;
diff --git a/present/present_scmd.c b/present/present_scmd.c
index 239055bc1..200ded348 100644
--- a/present/present_scmd.c
+++ b/present/present_scmd.c
@@ -71,6 +71,7 @@ present_check_flip(RRCrtcPtr            crtc,
     PixmapPtr                   window_pixmap;
     WindowPtr                   root = screen->root;
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
+    PresentFlipReason           tmp_reason = PRESENT_FLIP_REASON_UNKNOWN;
 
     if (crtc) {
        screen_priv = present_screen_priv(crtc->pScreen);
@@ -91,6 +92,27 @@ present_check_flip(RRCrtcPtr            crtc,
     if (!screen_priv->info->flip)
         return FALSE;
 
+    /* Ask the driver for permission. Do this now to see if there's TearFree. */
+    if (screen_priv->info->version >= 1 && screen_priv->info->check_flip2) {
+        if (!(*screen_priv->info->check_flip2) (crtc, window, pixmap, sync_flip, &tmp_reason)) {
+            DebugPresent(("\td %08" PRIx32 " -> %08" PRIx32 "\n", window->drawable.id, pixmap ? pixmap->drawable.id : 0));
+            /* It's fine to return now unless the page flip failure reason is
+             * PRESENT_FLIP_REASON_BUFFER_FORMAT; we must only output that
+             * reason if all the other checks pass.
+             */
+            if (!reason || tmp_reason != PRESENT_FLIP_REASON_BUFFER_FORMAT) {
+                if (reason)
+                    *reason = tmp_reason;
+                return FALSE;
+            }
+        }
+    } else if (screen_priv->info->check_flip) {
+        if (!(*screen_priv->info->check_flip) (crtc, window, pixmap, sync_flip)) {
+            DebugPresent(("\td %08" PRIx32 " -> %08" PRIx32 "\n", window->drawable.id, pixmap ? pixmap->drawable.id : 0));
+            return FALSE;
+        }
+    }
+
     /* Make sure the window hasn't been redirected with Composite */
     window_pixmap = screen->GetWindowPixmap(window);
     if (window_pixmap != screen->GetScreenPixmap(screen) &&
@@ -115,7 +137,7 @@ present_check_flip(RRCrtcPtr            crtc,
 
     /* Does the window match the pixmap exactly? */
     if (window->drawable.x != 0 || window->drawable.y != 0 ||
-#ifdef COMPOSITE
+#if defined(COMPOSITE) || defined(ROOTLESS)
         window->drawable.x != pixmap->screen_x || window->drawable.y != pixmap->screen_y ||
 #endif
         window->drawable.width != pixmap->drawable.width ||
@@ -123,17 +145,10 @@ present_check_flip(RRCrtcPtr            crtc,
         return FALSE;
     }
 
-    /* Ask the driver for permission */
-    if (screen_priv->info->version >= 1 && screen_priv->info->check_flip2) {
-        if (!(*screen_priv->info->check_flip2) (crtc, window, pixmap, sync_flip, reason)) {
-            DebugPresent(("\td %08" PRIx32 " -> %08" PRIx32 "\n", window->drawable.id, pixmap ? pixmap->drawable.id : 0));
-            return FALSE;
-        }
-    } else if (screen_priv->info->check_flip) {
-        if (!(*screen_priv->info->check_flip) (crtc, window, pixmap, sync_flip)) {
-            DebugPresent(("\td %08" PRIx32 " -> %08" PRIx32 "\n", window->drawable.id, pixmap ? pixmap->drawable.id : 0));
-            return FALSE;
-        }
+    if (tmp_reason == PRESENT_FLIP_REASON_BUFFER_FORMAT) {
+        if (reason)
+            *reason = tmp_reason;
+        return FALSE;
     }
 
     return TRUE;
@@ -456,7 +471,9 @@ present_check_flip_window (WindowPtr window)
     xorg_list_for_each_entry(vblank, &window_priv->vblank, window_list) {
         if (vblank->queued && vblank->flip && !present_check_flip(vblank->crtc, window, vblank->pixmap, vblank->sync_flip, NULL, 0, 0, &reason)) {
             vblank->flip = FALSE;
-            vblank->reason = reason;
+            /* Don't spuriously flag this as a TearFree presentation */
+            if (reason < PRESENT_FLIP_REASON_DRIVER_TEARFREE)
+                vblank->reason = reason;
             if (vblank->sync_flip)
                 vblank->exec_msc = vblank->target_msc;
         }
@@ -537,6 +554,7 @@ present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
     WindowPtr                   window = vblank->window;
     ScreenPtr                   screen = window->drawable.pScreen;
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
+    uint64_t                    completion_msc;
     if (vblank && vblank->crtc) {
         screen_priv=present_screen_priv(vblank->crtc->pScreen);
     }
@@ -560,7 +578,9 @@ present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
     xorg_list_del(&vblank->window_list);
     vblank->queued = FALSE;
 
-    if (vblank->pixmap && vblank->window) {
+    if (vblank->pixmap && vblank->window &&
+        (vblank->reason < PRESENT_FLIP_REASON_DRIVER_TEARFREE ||
+         vblank->exec_msc != vblank->target_msc)) {
 
         if (vblank->flip) {
 
@@ -627,6 +647,30 @@ present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 
         present_execute_copy(vblank, crtc_msc);
 
+        /* The presentation will be visible at the next vblank with TearFree, so
+         * the PresentComplete notification needs to be sent at the next vblank.
+         * If TearFree is already flipping then the presentation will be visible
+         * at the *next* next vblank.
+         */
+        completion_msc = crtc_msc + 1;
+        switch (vblank->reason) {
+        case PRESENT_FLIP_REASON_DRIVER_TEARFREE_FLIPPING:
+            if (vblank->exec_msc < crtc_msc)
+                completion_msc++;
+        case PRESENT_FLIP_REASON_DRIVER_TEARFREE:
+            if (Success == screen_priv->queue_vblank(screen,
+                                                     window,
+                                                     vblank->crtc,
+                                                     vblank->event_id,
+                                                     completion_msc)) {
+                /* Ensure present_execute_post() runs at the next MSC */
+                vblank->exec_msc = vblank->target_msc;
+                vblank->queued = TRUE;
+            }
+        default:
+            break;
+        }
+
         if (vblank->queued) {
             xorg_list_add(&vblank->event_queue, &present_exec_queue);
             xorg_list_append(&vblank->window_list,
@@ -739,6 +783,11 @@ present_scmd_pixmap(WindowPtr window,
             if (vblank->crtc != target_crtc || vblank->target_msc != target_msc)
                 continue;
 
+            /* Too late to abort now if TearFree execution already happened */
+            if (vblank->reason >= PRESENT_FLIP_REASON_DRIVER_TEARFREE &&
+                vblank->exec_msc == vblank->target_msc)
+                continue;
+
             present_vblank_scrap(vblank);
             if (vblank->flip_ready)
                 present_re_execute(vblank);
@@ -767,7 +816,12 @@ present_scmd_pixmap(WindowPtr window,
 
     vblank->event_id = ++present_scmd_event_id;
 
-    if (vblank->flip && vblank->sync_flip)
+    /* The soonest presentation is crtc_msc+2 if TearFree is already flipping */
+    if (vblank->reason == PRESENT_FLIP_REASON_DRIVER_TEARFREE_FLIPPING &&
+        !msc_is_after(vblank->exec_msc, crtc_msc + 1))
+        vblank->exec_msc -= 2;
+    else if (vblank->reason >= PRESENT_FLIP_REASON_DRIVER_TEARFREE ||
+             (vblank->flip && vblank->sync_flip))
         vblank->exec_msc--;
 
     xorg_list_append(&vblank->event_queue, &present_exec_queue);
diff --git a/pseudoramiX/Makefile.am b/pseudoramiX/Makefile.am
deleted file mode 100644
index 17b664b9e..000000000
--- a/pseudoramiX/Makefile.am
+++ /dev/null
@@ -1,7 +0,0 @@
-# Fake Xinerama extension
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-noinst_LTLIBRARIES = libPseudoramiX.la
-
-libPseudoramiX_la_SOURCES = pseudoramiX.c pseudoramiX.h
diff --git a/randr/Makefile.am b/randr/Makefile.am
deleted file mode 100644
index f9cefd18a..000000000
--- a/randr/Makefile.am
+++ /dev/null
@@ -1,33 +0,0 @@
-noinst_LTLIBRARIES = librandr.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-XINERAMA_SRCS = rrxinerama.c
-
-if XORG
-sdk_HEADERS = randrstr.h rrtransform.h
-endif
-
-librandr_la_SOURCES =	\
-	randr.c		\
-	randrstr.h	\
-	rrcrtc.c	\
-	rrdispatch.c	\
-	rrinfo.c	\
-	rrlease.c	\
-	rrmode.c	\
-	rrmonitor.c	\
-	rroutput.c	\
-	rrpointer.c	\
-	rrproperty.c	\
-	rrprovider.c    \
-	rrproviderproperty.c    \
-	rrscreen.c	\
-	rrsdispatch.c	\
-	rrtransform.h	\
-	rrtransform.c
-
-if XINERAMA
-librandr_la_SOURCES += ${XINERAMA_SRCS}
-endif
-
diff --git a/randr/randrstr.h b/randr/randrstr.h
index b23390575..545348835 100644
--- a/randr/randrstr.h
+++ b/randr/randrstr.h
@@ -218,6 +218,10 @@ typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr pScreen,
                                   Rotation rotation,
                                   int numOutputs, RROutputPtr * outputs);
 
+typedef void (*RRCrtcGetProcPtr) (ScreenPtr pScreen,
+                                  RRCrtcPtr crtc,
+                                  xRRGetCrtcInfoReply *rep);
+
 typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);
 
 typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);
@@ -280,6 +284,15 @@ typedef int (*RRCreateLeaseProcPtr)(ScreenPtr screen,
 typedef void (*RRTerminateLeaseProcPtr)(ScreenPtr screen,
                                         RRLeasePtr lease);
 
+typedef int (*RRRequestLeaseProcPtr)(ClientPtr client,
+                                     ScreenPtr screen,
+                                     RRLeasePtr lease);
+
+typedef void (*RRGetLeaseProcPtr)(ClientPtr client,
+                                 ScreenPtr screen,
+                                 RRLeasePtr *lease,
+                                 int *fd);
+
 /* These are for 1.0 compatibility */
 
 typedef struct _rrRefresh {
@@ -408,6 +421,13 @@ typedef struct _rrScrPriv {
     RRMonitorPtr *monitors;
 
     struct xorg_list leases;
+
+    RRRequestLeaseProcPtr rrRequestLease;
+    RRGetLeaseProcPtr rrGetLease;
+
+#if RANDR_12_INTERFACE
+    RRCrtcGetProcPtr rrCrtcGet;
+#endif
 } rrScrPrivRec, *rrScrPrivPtr;
 
 extern _X_EXPORT DevPrivateKeyRec rrPrivKeyRec;
diff --git a/randr/rrcrtc.c b/randr/rrcrtc.c
index 3a9b620ab..0044fecce 100644
--- a/randr/rrcrtc.c
+++ b/randr/rrcrtc.c
@@ -461,20 +461,12 @@ rrGetPixmapSharingSyncProp(int numOutputs, RROutputPtr * outputs)
     for (o = 0; o < numOutputs; o++) {
         RRPropertyValuePtr val;
 
-        /* Try pending value first, then current value */
         if ((val = RRGetOutputProperty(outputs[o], syncProp, TRUE)) &&
             val->data) {
             if (!(*(char *) val->data))
                 return FALSE;
             continue;
         }
-
-        if ((val = RRGetOutputProperty(outputs[o], syncProp, FALSE)) &&
-            val->data) {
-            if (!(*(char *) val->data))
-                return FALSE;
-            continue;
-        }
     }
 
     return TRUE;
@@ -717,6 +709,25 @@ rrCheckPixmapBounding(ScreenPtr pScreen,
     return TRUE;
 }
 
+#define XRANDR_EMULATION_PROP "RANDR Emulation"
+static Bool
+rrCheckEmulated(RROutputPtr output)
+{
+    const char *emulStr = XRANDR_EMULATION_PROP;
+    Atom emulProp;
+    RRPropertyValuePtr val;
+
+    emulProp = MakeAtom(emulStr, strlen(emulStr), FALSE);
+    if (emulProp == None)
+        return FALSE;
+
+    val = RRGetOutputProperty(output, emulProp, TRUE);
+    if (val && val->data)
+        return !!val->data;
+
+    return FALSE;
+}
+
 /*
  * Request that the Crtc be reconfigured
  */
@@ -736,9 +747,11 @@ RRCrtcSet(RRCrtcPtr crtc,
 
     crtcChanged = FALSE;
     for (o = 0; o < numOutputs; o++) {
-        if (outputs[o] && outputs[o]->crtc != crtc) {
-            crtcChanged = TRUE;
-            break;
+        if (outputs[o]) {
+            if (rrCheckEmulated(outputs[o]) || (outputs[o]->crtc != crtc)) {
+                crtcChanged = TRUE;
+                break;
+            }
         }
     }
 
@@ -1248,6 +1261,9 @@ ProcRRGetCrtcInfo(ClientPtr client)
         }
     }
 
+    if (pScrPriv->rrCrtcGet)
+        pScrPriv->rrCrtcGet(pScreen, crtc, &rep);
+
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.length);
diff --git a/randr/rrlease.c b/randr/rrlease.c
index 11ba96f24..cb366e767 100644
--- a/randr/rrlease.c
+++ b/randr/rrlease.c
@@ -239,9 +239,19 @@ ProcRRCreateLease(ClientPtr client)
     if (!scr_priv)
         return BadMatch;
 
-    if (!scr_priv->rrCreateLease)
+    if (!scr_priv->rrCreateLease && !scr_priv->rrRequestLease)
         return BadMatch;
 
+    if (scr_priv->rrGetLease) {
+        scr_priv->rrGetLease(client, screen, &lease, &fd);
+        if (lease) {
+            if (fd >= 0)
+                goto leaseReturned;
+            else
+                goto bail_lease;
+        }
+    }
+
     /* Allocate a structure to hold all of the lease information */
 
     lease = RRLeaseAlloc(screen, stuff->lid, stuff->nCrtcs, stuff->nOutputs);
@@ -291,10 +301,19 @@ ProcRRCreateLease(ClientPtr client)
         lease->outputs[o] = output;
     }
 
-    rc = scr_priv->rrCreateLease(screen, lease, &fd);
-    if (rc != Success)
-        goto bail_lease;
+    if (scr_priv->rrRequestLease) {
+        rc = scr_priv->rrRequestLease(client, screen, lease);
+        if (rc == Success)
+            return Success;
+        else
+            goto bail_lease;
+    } else {
+        rc = scr_priv->rrCreateLease(screen, lease, &fd);
+        if (rc != Success)
+            goto bail_lease;
+    }
 
+leaseReturned:
     xorg_list_add(&lease->list, &scr_priv->leases);
 
     if (!AddResource(stuff->lid, RRLeaseType, lease)) {
diff --git a/randr/rrmonitor.c b/randr/rrmonitor.c
index e62bd484d..7b0bbfcd5 100644
--- a/randr/rrmonitor.c
+++ b/randr/rrmonitor.c
@@ -156,8 +156,8 @@ RRMonitorGetGeometry(RRMonitorPtr monitor, RRMonitorGeometryPtr geometry)
 
         /* Adjust physical sizes to account for total area */
         if (active_crtcs > 1 && first.box.x2 != first.box.x1 && first.box.y2 != first.box.y1) {
-            geometry->mmWidth = (this.box.x2 - this.box.x1) / (first.box.x2 - first.box.x1) * first.mmWidth;
-            geometry->mmHeight = (this.box.y2 - this.box.y1) / (first.box.y2 - first.box.y1) * first.mmHeight;
+            geometry->mmWidth = ((double)(geometry->box.x2 - geometry->box.x1) / (first.box.x2 - first.box.x1)) * first.mmWidth;
+            geometry->mmHeight = ((double)(geometry->box.y2 - geometry->box.y1) / (first.box.y2 - first.box.y1)) * first.mmHeight;
         }
     } else {
         *geometry = monitor->geometry;
diff --git a/record/Makefile.am b/record/Makefile.am
deleted file mode 100644
index 2a64f3189..000000000
--- a/record/Makefile.am
+++ /dev/null
@@ -1,7 +0,0 @@
-noinst_LTLIBRARIES = librecord.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-librecord_la_SOURCES = record.c set.c
-
-EXTRA_DIST = set.h
diff --git a/render/Makefile.am b/render/Makefile.am
deleted file mode 100644
index d02028b3b..000000000
--- a/render/Makefile.am
+++ /dev/null
@@ -1,20 +0,0 @@
-noinst_LTLIBRARIES = librender.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-librender_la_SOURCES =	\
-	animcur.c	\
-	filter.c	\
-	glyph.c		\
-	matrix.c	\
-	miindex.c	\
-	mipict.c	\
-	mirect.c	\
-	mitrap.c	\
-	mitri.c		\
-	picture.c	\
-	render.c
-
-if XORG
-sdk_HEADERS = picture.h mipict.h glyphstr.h picturestr.h
-endif
diff --git a/render/picture.h b/render/picture.h
index 4499a0021..c3a73d1d8 100644
--- a/render/picture.h
+++ b/render/picture.h
@@ -125,7 +125,10 @@ typedef enum _PictFormatShort {
 /* 1bpp formats */
     PICT_a1 = PIXMAN_a1,
 
-    PICT_g1 = PIXMAN_g1
+    PICT_g1 = PIXMAN_g1,
+
+/* YCbCr formats */
+    PICT_yuv2 = PIXMAN_yuy2
 } PictFormatShort;
 
 /*
diff --git a/test/Makefile.am b/test/Makefile.am
deleted file mode 100644
index ce07c3551..000000000
--- a/test/Makefile.am
+++ /dev/null
@@ -1,193 +0,0 @@
-if ENABLE_UNIT_TESTS
-SUBDIRS= .
-AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
-AM_CPPFLAGS = $(XORG_INCS)
-
-tests_CPPFLAGS=
-CLEANFILES=
-
-tests_SOURCES = \
-        tests-common.c \
-	tests-common.h \
-        list.c \
-        string.c \
-        tests.c \
-	tests.h
-
-noinst_PROGRAMS = simple-xinit tests
-
-if XVFB
-XVFB_TESTS = scripts/xvfb-piglit.sh
-if XEPHYR
-if GLAMOR
-XEPHYR_GLAMOR_TESTS = scripts/xephyr-glamor-piglit.sh
-endif
-endif
-endif
-
-SCRIPT_TESTS = \
-	$(XVFB_TESTS) \
-	$(XEPHYR_GLAMOR_TESTS) \
-	$(NULL)
-
-TESTS = tests \
-	$(SCRIPT_TESTS) \
-	$(NULL)
-
-TESTS_ENVIRONMENT = \
-	XSERVER_DIR=$(abs_top_srcdir) \
-	XSERVER_BUILDDIR=$(abs_top_builddir) \
-	$(XORG_MALLOC_DEBUG_ENV) \
-	$(NULL)
-
-tests_LDADD =
-
-if XORG
-
-# Tests that require at least some DDX functions in order to fully link
-# For now, requires xf86 ddx, could be adjusted to use another
-
-AM_CPPFLAGS += \
-	-I$(srcdir)/xi1 \
-	-I$(srcdir)/xi2 \
-	-I$(top_srcdir)/hw/xfree86/common \
-	-I$(top_srcdir)/hw/xfree86/parser \
-	-I$(top_srcdir)/hw/xfree86/ddc \
-	-I$(top_srcdir)/hw/xfree86/i2c -I$(top_srcdir)/hw/xfree86/modes \
-	-I$(top_srcdir)/hw/xfree86/ramdac -I$(top_srcdir)/hw/xfree86/dri \
-	-I$(top_srcdir)/hw/xfree86/dri2 -I$(top_srcdir)/dri3
-tests_CPPFLAGS += $(AM_CPPFLAGS)
-
-tests_SOURCES += \
-        fixes.c \
-        input.c \
-        misc.c \
-        signal-logging.c \
-        touch.c \
-        xfree86.c \
-        test_xkb.c \
-        xtest.c
-tests_CPPFLAGS += -DXORG_TESTS
-
-if RES
-tests_SOURCES += hashtabletest.c
-tests_CPPFLAGS += -DRES_TESTS
-endif
-
-endif XORG
-
-if HAVE_LD_WRAP
-
-tests_CPPFLAGS += -DLDWRAP_TESTS
-
-if XORG
-tests_SOURCES += \
-	xi1/protocol-xchangedevicecontrol.c \
-	xi2/protocol-common.c \
-	xi2/protocol-xiqueryversion.c \
-	xi2/protocol-xiquerydevice.c \
-	xi2/protocol-xiselectevents.c \
-	xi2/protocol-xigetselectedevents.c \
-	xi2/protocol-xisetclientpointer.c \
-	xi2/protocol-xigetclientpointer.c \
-	xi2/protocol-xiquerypointer.c \
-	xi2/protocol-xipassivegrabdevice.c \
-	xi2/protocol-xiwarppointer.c \
-	xi2/protocol-eventconvert.c \
-	xi2/xi2.c \
-	xi2/protocol-common.h
-
-tests_LDFLAGS = \
-	-Wl,-wrap,dixLookupWindow \
-	-Wl,-wrap,dixLookupClient \
-	-Wl,-wrap,WriteToClient \
-	-Wl,-wrap,dixLookupWindow \
-	-Wl,-wrap,XISetEventMask \
-	-Wl,-wrap,AddResource \
-	-Wl,-wrap,GrabButton \
-	$()
-endif XORG
-
-else !HAVE_LD_WRAP
-
-# Print that xi1-tests were skipped (exit code 77 for automake test harness)
-TESTS += xi1-tests
-CLEANFILES += xi1-tests
-
-xi1-tests:
-	@echo 'echo "ld -wrap support required for xi1 unit tests, skipping"' > $@
-	@echo 'exit 77' >> $@
-	$(AM_V_GEN)chmod +x $@
-
-# Print that xi2-tests were skipped (exit code 77 for automake test harness)
-TESTS += xi2-tests
-CLEANFILES += xi2-tests
-
-xi2-tests:
-	@echo 'echo "ld -wrap support required for xi2 unit tests, skipping"' > $@
-	@echo 'exit 77' >> $@
-	$(AM_V_GEN)chmod +x $@
-
-endif !HAVE_LD_WRAP
-
-if XORG
-
-nodist_tests_SOURCES = sdksyms.c
-
-tests_LDADD += \
-            $(top_builddir)/hw/xfree86/loader/libloader.la \
-            $(top_builddir)/hw/xfree86/common/libcommon.la \
-            $(top_builddir)/hw/xfree86/os-support/libxorgos.la \
-            $(top_builddir)/hw/xfree86/parser/libxf86config.la \
-            $(top_builddir)/hw/xfree86/dixmods/libdixmods.la \
-            $(top_builddir)/hw/xfree86/modes/libxf86modes.la \
-            $(top_builddir)/hw/xfree86/ramdac/libramdac.la \
-            $(top_builddir)/hw/xfree86/ddc/libddc.la \
-            $(top_builddir)/hw/xfree86/i2c/libi2c.la \
-            $(top_builddir)/hw/xfree86/xkb/libxorgxkb.la \
-            $(top_builddir)/Xext/libXvidmode.la \
-            $(top_builddir)/fb/libfb.la \
-            $(XSERVER_LIBS) \
-            $(XORG_LIBS)
-
-if !SPECIAL_DTRACE_OBJECTS
-tests_LDADD += $(top_builddir)/os/libos.la
-endif
-
-if GLX
-tests_LDADD += $(top_builddir)/glx/libglxvnd.la
-endif
-
-BUILT_SOURCES = sdksyms.c
-CLEANFILES += sdksyms.c
-
-sdksyms.c: $(top_builddir)/hw/xfree86/sdksyms.c
-	$(AM_V_GEN)$(LN_S) $(top_builddir)/hw/xfree86/sdksyms.c
-
-if DRI
-tests_LDADD += $(top_builddir)/hw/xfree86/dri/libdri.la
-endif
-
-if DRI2
-tests_LDADD += $(top_builddir)/hw/xfree86/dri2/libdri2.la
-endif
-
-if DRI3
-tests_LDADD += $(top_builddir)/dri3/libdri3.la
-endif
-
-endif XORG
-
-# GNU LD scans only in one direction, add the following dependencies at the end
-# so as they get picked up by the previously-linked libraries
-tests_LDADD += $(XORG_SYS_LIBS) $(XSERVER_SYS_LIBS) $(GLX_SYS_LIBS)
-
-endif ENABLE_UNIT_TESTS
-
-EXTRA_DIST = \
-	scripts/xvfb-piglit.sh \
-	scripts/xephyr-glamor-piglit.sh \
-	scripts/xinit-piglit-session.sh \
-	scripts/run-piglit.sh \
-	$(NULL)
-
diff --git a/test/bugs/bug1354.c b/test/bugs/bug1354.c
new file mode 100644
index 000000000..edc3f228c
--- /dev/null
+++ b/test/bugs/bug1354.c
@@ -0,0 +1,149 @@
+#include <xcb/xcb.h>
+#include <xcb/xcb_aux.h>
+#include <xcb/xcb_image.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <unistd.h>
+
+/*
+ * This is a test which try to test correct glamor colors when rendered.
+ * It should be run with fullscreen Xephyr (with glamor) with present and with 
+ * etalon high-level Xserver (can be any, on CI - Xvfb). For testing this test
+ * creates an image in Xephyr X server, which filled by one of colors defined in
+ * test_pixels. Then it captures central pixel from both Xephyr and Xserver above.
+ * If pixels differ - test failed. Sleep is used to ensure than presentation on both 
+ * Xephyr and Xvfb kicks (xcb_aux_sync was not enough) and test results will be actual
+ */
+
+#define WIDTH 300
+#define HEIGHT 300
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win);
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color);
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win)
+{
+	xcb_image_t *image;
+	uint32_t    pixel;
+	int format = XCB_IMAGE_FORMAT_XY_PIXMAP;
+
+	image = xcb_image_get (c, win,
+		 0, 0, WIDTH, HEIGHT,
+		 UINT32_MAX,
+		 format);
+	if (!image) {
+	  printf("xcb_image_get failed: exiting\n");
+	  exit(1);
+	}
+
+	pixel = xcb_image_get_pixel(image, WIDTH/2, HEIGHT/2);
+
+	return pixel;
+}
+
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color)
+{
+	xcb_gcontext_t       foreground;
+	uint32_t             mask = 0;
+
+	xcb_rectangle_t rectangles[] = {
+	  {0, 0, WIDTH, HEIGHT},
+	};
+
+	foreground = xcb_generate_id (c);
+	mask = XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH | XCB_GC_SUBWINDOW_MODE;
+
+	uint32_t values[] = {
+		pixel_color,
+		20,
+		XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS
+	};
+
+	xcb_create_gc (c, foreground, win, mask, values);
+
+	xcb_poly_fill_rectangle (c, win, foreground, 1, rectangles);
+	xcb_aux_sync ( c );
+}
+
+
+int main(int argc, char* argv[])
+{
+	xcb_connection_t    *c, *r;
+	xcb_screen_t        *screen1, *screen2;
+	xcb_drawable_t       win1, win2;
+    char *name_test = NULL, *name_relevant = NULL;
+	uint32_t pixel_server1, pixel_server2;
+	int result = 0;
+	uint32_t test_pixels[3] = {0xff0000, 0x00ff00, 0x0000ff};
+	int gv;
+
+	while ((gv = getopt (argc, argv, "t:r:")) != -1)
+	switch (gv)
+	  {
+	  case 't':
+		name_test = optarg;
+		break;
+	  case 'r':
+		name_relevant = optarg;
+		break;
+	  case '?':
+		if (optopt == 't' || optopt == 'r')
+		  fprintf (stderr, "Option -%c requires an argument - test screen name.\n", optopt);
+		else if (isprint (optopt))
+		  fprintf (stderr, "Unknown option `-%c'.\n", optopt);
+		else
+		  fprintf (stderr,
+		           "Unknown option character `\\x%x'.\n",
+		           optopt);
+		return 1;
+	  default:
+		abort ();
+	  }
+
+	printf("test=%s, rel=%s\n", name_test, name_relevant);
+
+	c = xcb_connect (name_test, NULL);
+	r = xcb_connect (name_relevant, NULL);
+
+	/* get the first screen */
+	screen1 = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
+
+    win1 = xcb_generate_id (c);
+    xcb_create_window (c,                    /* Connection          */
+                       XCB_COPY_FROM_PARENT,          /* depth (same as root)*/
+                       win1,                        /* window Id           */
+                       screen1->root,                  /* parent window       */
+                       0, 0,                          /* x, y                */
+                       WIDTH, HEIGHT,                /* width, height       */
+                       20,                            /* border_width        */
+                       XCB_WINDOW_CLASS_INPUT_OUTPUT, /* class               */
+                       screen1->root_visual,           /* visual              */
+                       0, NULL );                     /* masks, not used yet */
+
+
+    /* Map the window on the screen */
+    xcb_map_window (c, win1);
+    xcb_aux_sync(c);
+
+	/* get the first screen */
+	screen2 = xcb_setup_roots_iterator (xcb_get_setup (r)).data;
+
+	/* root window */
+	win2 = screen2->root;
+
+	for(int i = 0; i < 3; i++)
+	{
+		draw_display_pixel(c, win1, test_pixels[i]);
+		xcb_aux_sync(r);
+		pixel_server1 = get_display_pixel(c, win1);
+		sleep(1);
+		pixel_server2 = get_display_pixel(r, win2);
+		xcb_aux_sync(r);
+		printf("p=0x%x, p2=0x%x\n", pixel_server1, pixel_server2);
+		result+= pixel_server1 == pixel_server2;
+	}
+	return result == 3 ? 0 : 1;
+}
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
new file mode 100644
index 000000000..470706d56
--- /dev/null
+++ b/test/bugs/meson.build
@@ -0,0 +1,50 @@
+xcb_dep = dependency('xcb', required: false)
+xcb_image_dep = dependency('xcb-image', required: false)
+xcb_util_dep = dependency('xcb-util', required: false)
+
+if get_option('xvfb')
+    xvfb_args = [
+        xvfb_server.full_path(),
+        '-screen',
+        'scrn',
+        '1280x1024x24'
+    ]
+
+    if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_option('xvfb') and get_option('xephyr') and build_glamor
+        bug1354 = executable('bug1354', 'bug1354.c', dependencies: [xcb_dep, xcb_image_dep, xcb_util_dep])
+        test('bug1354-gl',
+                simple_xinit,
+                args: [simple_xinit.full_path(),
+                    bug1354.full_path(),
+                    '-t',':201','-r',':200',
+                    '----',
+                    xephyr_server.full_path(),
+                    '-glamor',
+                    '-schedMax', '2000',
+                    ':201',
+                    '--',
+                    xvfb_args,
+                    ':200'
+                    ],
+                suite: 'xephyr-glamor',
+                timeout: 300,
+            )
+        test('bug1354-gles',
+                simple_xinit,
+                args: [simple_xinit.full_path(),
+                    bug1354.full_path(),
+                    '-t',':199','-r',':198',
+                    '----',
+                    xephyr_server.full_path(),
+                    '-glamor_gles2',
+                    '-schedMax', '2000',
+                    ':199',
+                    '--',
+                    xvfb_args,
+                    ':198'
+                    ],
+                suite: 'xephyr-glamor-gles2',
+                timeout: 300,
+            )
+    endif
+endif
\ No newline at end of file
diff --git a/test/meson.build b/test/meson.build
index 7cd636939..662eee4ef 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -9,13 +9,24 @@ piglit_env.set('XSERVER_DIR', meson.source_root())
 piglit_env.set('XSERVER_BUILDDIR', meson.build_root())
 
 some_ops = ' -o clear,src,dst,over,xor,disjointover'
-rendercheck_tests = [
+gles2_working_formats = ' -f '+ ','.join(['a8',
+                                          'a8r8g8b8',
+                                          'x8r8g8b8',
+                                          'b8g8r8a8',
+                                          'b8g8r8x8',
+                                          'r8g8b8',
+                                          'r5g5b5',
+                                          'b5g5r5',
+                                          'r5g6b5',
+                                          'b5g6r5',
+                                          'b8g8r8',
+                                          'x8b8g8r8',
+                                          'x2r10g10b10',
+                                          'x2b10g10r10'])
+rendercheck_tests_noblend = [
     ['blend/All/a8r8g8b8', '-t blend -f a8r8g8b8'],
     ['blend/All/x8r8g8b8', '-t blend -f a8r8g8b8,x8r8g8b8'],
     ['blend/All/a2r10g10b10', '-t blend -f a8r8g8b8,a2r10g10b10'],
-    ['blend/Clear', '-t blend -o clear'],
-    ['blend/Src', '-t blend -o src'],
-    ['blend/Over', '-t blend -o over'],
     ['composite/Some/a8r8g8b8', '-t composite -f a8r8g8b8' + some_ops],
     ['composite/Some/x8r8g8b8', '-t composite -f a8r8g8b8,x8r8g8b8' + some_ops],
     ['composite/Some/a2r10g10b10', '-t composite -f a8r8g8b8,a2r10g10b10' + some_ops],
@@ -34,7 +45,19 @@ rendercheck_tests = [
     ['LibreOffice xRGB', '-t libreoffice_xrgb'],
     ['GTK ARGB vs xBGR', '-t gtk_argb_xbgr'],
 ]
-
+rendercheck_blend = [
+    ['blend/Clear', '-t blend -o clear'],
+    ['blend/Src', '-t blend -o src'],
+    ['blend/Over', '-t blend -o over'],
+]
+#Exclude 15bpp for now due to GLES limitation (see glamor.c:470)
+rendercheck_blend_gles2 = [
+    ['blend/Clear', '-t blend -o clear' + gles2_working_formats],
+    ['blend/Src', '-t blend -o src' + gles2_working_formats],
+    ['blend/Over', '-t blend -o over' + gles2_working_formats],
+]
+rendercheck_tests = rendercheck_blend + rendercheck_tests_noblend
+rendercheck_tests_gles2 = rendercheck_blend_gles2 + rendercheck_tests_noblend
 rendercheck = find_program('rendercheck', required:false)
 
 if get_option('xvfb')
@@ -74,7 +97,13 @@ if get_option('xvfb')
             find_program('scripts/xephyr-glamor-piglit.sh'),
             env: piglit_env,
             timeout: 1200,
-            suite: 'xephr-glamor',
+            suite: 'xephyr-glamor',
+        )
+        test('XTS',
+            find_program('scripts/xephyr-glamor-gles2-piglit.sh'),
+            env: piglit_env,
+            timeout: 1200,
+            suite: 'xephyr-glamor-gles2',
         )
 
         if rendercheck.found()
@@ -92,7 +121,25 @@ if get_option('xvfb')
                             '--',
                             xvfb_args,
                            ],
-                     suite: 'xephr-glamor',
+                     suite: 'xephyr-glamor',
+                     timeout: 300,
+                    )
+            endforeach
+            foreach rctest: rendercheck_tests_gles2
+                test(rctest[0],
+                     simple_xinit,
+                     args: [simple_xinit.full_path(),
+                            rendercheck.path(),
+                            rctest[1].split(' '),
+                            '----',
+                            xephyr_server.full_path(),
+                            '-glamor_gles2',
+                            '-glamor-skip-present',
+                            '-schedMax', '2000',
+                            '--',
+                            xvfb_args,
+                           ],
+                     suite: 'xephyr-glamor-gles2',
                      timeout: 300,
                     )
             endforeach
@@ -100,9 +147,23 @@ if get_option('xvfb')
     endif
 endif
 
+if build_xwayland
+    xwayland_args = [
+        xwayland_server.full_path(),
+    ]
+
+    test('XTS',
+        find_program('scripts/xwayland-piglit.sh'),
+        env: piglit_env,
+        timeout: 1200,
+        suite: 'xwayland'
+    )
+endif
+
 subdir('bigreq')
 subdir('damage')
 subdir('sync')
+subdir('bugs')
 
 if build_xorg
 # Tests that require at least some DDX functions in order to fully link
diff --git a/test/scripts/xephyr-glamor-gles2-piglit.sh b/test/scripts/xephyr-glamor-gles2-piglit.sh
new file mode 100755
index 000000000..59ca12d26
--- /dev/null
+++ b/test/scripts/xephyr-glamor-gles2-piglit.sh
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+# this times out on Travis, because the tests take too long.
+if test "x$TRAVIS_BUILD_DIR" != "x"; then
+    exit 77
+fi
+
+# Start a Xephyr server using glamor.  Since the test environment is
+# headless, we start an Xvfb first to host the Xephyr.
+export PIGLIT_RESULTS_DIR=$XSERVER_BUILDDIR/test/piglit-results/xephyr-glamor-gles2
+
+export SERVER_COMMAND="$XSERVER_BUILDDIR/hw/kdrive/ephyr/Xephyr \
+        -glamor_gles2 \
+        -glamor-skip-present \
+        -noreset \
+        -schedMax 2000 \
+        -screen 1280x1024"
+
+# Tests that currently fail on llvmpipe on CI
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@6"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@2"
+
+export PIGLIT_ARGS
+
+$XSERVER_BUILDDIR/test/simple-xinit \
+        $XSERVER_DIR/test/scripts/run-piglit.sh \
+        -- \
+        $XSERVER_BUILDDIR/hw/vfb/Xvfb \
+        -screen scrn 1280x1024x24
diff --git a/test/scripts/xephyr-glamor-piglit.sh b/test/scripts/xephyr-glamor-piglit.sh
index 0458f271b..62c17701f 100755
--- a/test/scripts/xephyr-glamor-piglit.sh
+++ b/test/scripts/xephyr-glamor-piglit.sh
@@ -22,6 +22,8 @@ PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@2"
 
 export PIGLIT_ARGS
 
diff --git a/test/scripts/xinit-piglit-session.sh b/test/scripts/xinit-piglit-session.sh
index 97bf2b9e0..6a51f9650 100755
--- a/test/scripts/xinit-piglit-session.sh
+++ b/test/scripts/xinit-piglit-session.sh
@@ -31,6 +31,8 @@ PIGLIT_ARGS="$PIGLIT_ARGS -x xlistfontswithinfo@4"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xloadqueryfont@1"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xqueryfont@1"
 PIGLIT_ARGS="$PIGLIT_ARGS -x xqueryfont@2"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@2"
 # Run as meson unit tests.
 PIGLIT_ARGS="$PIGLIT_ARGS -x rendercheck"
 
diff --git a/test/scripts/xwayland-piglit.sh b/test/scripts/xwayland-piglit.sh
new file mode 100755
index 000000000..7c30ecbab
--- /dev/null
+++ b/test/scripts/xwayland-piglit.sh
@@ -0,0 +1,47 @@
+#!/bin/sh -e
+
+# this times out on Travis, because the tests take too long.
+if test "x$TRAVIS_BUILD_DIR" != "x"; then
+    exit 77
+fi
+
+# Weston requires XDG_RUNTIME_DIR
+if test "x$XDG_RUNTIME_DIR" = "x"; then
+    export XDG_RUNTIME_DIR=$(mktemp -d)
+fi
+
+# Skip if weston isn't available
+weston --version >/dev/null || exit 77
+
+weston --no-config --backend=headless-backend.so --socket=wayland-$$ &
+WESTON_PID=$!
+export WAYLAND_DISPLAY=wayland-$$
+
+# Wait for weston to initialize before starting Xwayland
+timeout --preserve-status 60s bash -c 'while ! weston-info &>/dev/null; do sleep 1; done'
+
+# Start an Xwayland server
+export PIGLIT_RESULTS_DIR=$XSERVER_BUILDDIR/test/piglit-results/xwayland
+export SERVER_COMMAND="$XSERVER_BUILDDIR/hw/xwayland/Xwayland -noreset"
+
+# Make sure glamor doesn't use HW acceleration
+export GBM_ALWAYS_SOFTWARE=1
+
+# Tests that currently fail on llvmpipe on CI
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@6"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@2"
+
+export PIGLIT_ARGS
+
+# Do not let run-piglit.sh exit status terminate this script prematurely
+set +e
+$XSERVER_DIR/test/scripts/run-piglit.sh
+PIGLIT_STATUS=$?
+
+kill $WESTON_PID
+exit $PIGLIT_STATUS
diff --git a/test/test_xkb.c b/test/test_xkb.c
index f81a7ed65..a13107390 100644
--- a/test/test_xkb.c
+++ b/test/test_xkb.c
@@ -48,7 +48,6 @@
 #include "../xkb/xkbgeom.h"
 #include <X11/extensions/XKMformat.h>
 #include "xkbfile.h"
-#include "../xkb/xkb.h"
 #include <assert.h>
 
 #include "tests-common.h"
diff --git a/xfixes/Makefile.am b/xfixes/Makefile.am
deleted file mode 100644
index 52a7e6c6a..000000000
--- a/xfixes/Makefile.am
+++ /dev/null
@@ -1,13 +0,0 @@
-noinst_LTLIBRARIES = libxfixes.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-libxfixes_la_SOURCES = 	\
-	cursor.c	\
-	disconnect.c	\
-	region.c	\
-	saveset.c	\
-	select.c	\
-	xfixes.c	\
-	xfixes.h	\
-	xfixesint.h
diff --git a/xkb/Makefile.am b/xkb/Makefile.am
deleted file mode 100644
index e386ce5a2..000000000
--- a/xkb/Makefile.am
+++ /dev/null
@@ -1,42 +0,0 @@
-noinst_LTLIBRARIES = libxkb.la libxkbstubs.la
-
-AM_CFLAGS = $(DIX_CFLAGS)
-
-DDX_SRCS = \
-        ddxBeep.c \
-        ddxCtrls.c \
-        ddxLEDs.c \
-        ddxLoad.c
-
-DIX_SRCS = \
-        xkb.c \
-        xkbUtils.c \
-        xkbEvents.c \
-        xkbAccessX.c \
-        xkbSwap.c \
-        xkbLEDs.c \
-        xkbInit.c \
-        xkbActions.c \
-        xkbPrKeyEv.c
-
-# this should be replaced by a common library or something, ideally -d
-XKBFILE_SRCS = \
-        maprules.c \
-        xkmread.c \
-        xkbtext.c \
-        xkbfmisc.c \
-        xkbout.c
-
-X11_SRCS = \
-        XKBMisc.c \
-        XKBAlloc.c \
-        XKBGAlloc.c \
-        XKBMAlloc.c
-
-libxkb_la_SOURCES = $(DDX_SRCS) $(DIX_SRCS) $(XKBFILE_SRCS) $(X11_SRCS)
-libxkbstubs_la_SOURCES = ddxVT.c ddxPrivate.c ddxKillSrv.c
-
-EXTRA_DIST = xkbDflts.h xkbgeom.h xkb.h
-
-xkbcompileddir = $(XKB_COMPILED_DIR)
-dist_xkbcompiled_DATA = README.compiled
diff --git a/xkb/ddxLoad.c b/xkb/ddxLoad.c
index f9b7b06d9..2d203ce11 100644
--- a/xkb/ddxLoad.c
+++ b/xkb/ddxLoad.c
@@ -43,7 +43,6 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #define	XKBSRV_NEED_FILE_FUNCS
 #include <xkbsrv.h>
 #include <X11/extensions/XI.h>
-#include "xkb.h"
 
 #define	PRE_ERROR_MSG "\"The XKEYBOARD keymap compiler (xkbcomp) reports:\""
 #define	ERROR_PREFIX	"\"> \""
diff --git a/xkb/xkb.h b/xkb/xkb-procs.h
similarity index 96%
rename from xkb/xkb.h
rename to xkb/xkb-procs.h
index f3a60af6b..d0ae8309a 100644
--- a/xkb/xkb.h
+++ b/xkb/xkb-procs.h
@@ -27,4 +27,7 @@ extern int ProcXkbGetKbdByName(ClientPtr client);
 extern int ProcXkbGetDeviceInfo(ClientPtr client);
 extern int ProcXkbSetDeviceInfo(ClientPtr client);
 extern int ProcXkbSetDebuggingFlags(ClientPtr client);
+
+extern int SProcXkbDispatch(ClientPtr client);
+
 #endif
diff --git a/xkb/xkb.c b/xkb/xkb.c
index 276dc1938..f9e3acbdc 100644
--- a/xkb/xkb.c
+++ b/xkb/xkb.c
@@ -38,7 +38,7 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include "extnsionst.h"
 #include "extinit.h"
 #include "xace.h"
-#include "xkb.h"
+#include "xkb-procs.h"
 #include "protocol-versions.h"
 
 #include <X11/extensions/XI.h>
@@ -2433,7 +2433,7 @@ _XkbSetMapCheckLength(xkbSetMapReq *req)
     }
     /* actions */
     if (req->present & XkbKeyActionsMask) {
-        _add_check_len(req->totalActs * sz_xkbActionWireDesc 
+        _add_check_len(req->totalActs * sz_xkbActionWireDesc
                        + XkbPaddedSize(req->nKeyActs));
     }
     /* behaviours */
@@ -5799,7 +5799,8 @@ static unsigned char componentExprLegal[] = {
 };
 
 static char *
-GetComponentSpec(unsigned char **pWire, Bool allowExpr, int *errRtrn)
+GetComponentSpec(ClientPtr client, xkbGetKbdByNameReq *stuff,
+                 unsigned char **pWire, Bool allowExpr, int *errRtrn)
 {
     int len;
     register int i;
@@ -5811,8 +5812,16 @@ GetComponentSpec(unsigned char **pWire, Bool allowExpr, int *errRtrn)
         legal = &componentSpecLegal[0];
 
     wire = *pWire;
+    if (!_XkbCheckRequestBounds(client, stuff, wire, wire + 1)) {
+        *errRtrn = BadLength;
+        return NULL;
+    }
     len = (*(unsigned char *) wire++);
     if (len > 0) {
+        if (!_XkbCheckRequestBounds(client, stuff, wire, wire + len)) {
+            *errRtrn = BadLength;
+            return NULL;
+        }
         str = calloc(1, len + 1);
         if (str) {
             tmp = str;
@@ -5866,6 +5875,8 @@ ProcXkbListComponents(ClientPtr client)
      * length wrong. */
     str = (unsigned char *) &stuff[1];
     for (i = 0; i < 6; i++) {
+        if (!_XkbCheckRequestBounds(client, stuff, str, str + 1))
+            return BadLength;
         size = *((uint8_t *)str);
         len = (str + size + 1) - ((unsigned char *) stuff);
         if ((XkbPaddedSize(len) / 4) > stuff->length)
@@ -5941,17 +5952,17 @@ ProcXkbGetKbdByName(ClientPtr client)
     status = Success;
     str = (unsigned char *) &stuff[1];
     {
-        char *keymap = GetComponentSpec(&str, TRUE, &status);  /* keymap, unsupported */
+        char *keymap = GetComponentSpec(client, stuff, &str, TRUE, &status);  /* keymap, unsupported */
         if (keymap) {
             free(keymap);
             return BadMatch;
         }
     }
-    names.keycodes = GetComponentSpec(&str, TRUE, &status);
-    names.types = GetComponentSpec(&str, TRUE, &status);
-    names.compat = GetComponentSpec(&str, TRUE, &status);
-    names.symbols = GetComponentSpec(&str, TRUE, &status);
-    names.geometry = GetComponentSpec(&str, TRUE, &status);
+    names.keycodes = GetComponentSpec(client, stuff, &str, TRUE, &status);
+    names.types = GetComponentSpec(client, stuff, &str, TRUE, &status);
+    names.compat = GetComponentSpec(client, stuff, &str, TRUE, &status);
+    names.symbols = GetComponentSpec(client, stuff, &str, TRUE, &status);
+    names.geometry = GetComponentSpec(client, stuff, &str, TRUE, &status);
     if (status == Success) {
         len = str - ((unsigned char *) stuff);
         if ((XkbPaddedSize(len) / 4) != stuff->length)
@@ -6832,7 +6843,7 @@ _XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
     ed.deviceID = dev->id;
     wire = (char *) &stuff[1];
     if (stuff->change & XkbXI_ButtonActionsMask) {
-	int nBtns, sz, i;
+        int nBtns, sz, i;
         XkbAction *acts;
         DeviceIntPtr kbd;
 
diff --git a/xkb/xkbActions.c b/xkb/xkbActions.c
index db29091e7..5e9a6b6d6 100644
--- a/xkb/xkbActions.c
+++ b/xkb/xkbActions.c
@@ -38,7 +38,6 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include "exevents.h"
 #include "eventstr.h"
 #include <xkbsrv.h>
-#include "xkb.h"
 #include <ctype.h>
 #include "mi.h"
 #include "mipointer.h"
diff --git a/xkb/xkbEvents.c b/xkb/xkbEvents.c
index 0bbd66186..f8f65d4a7 100644
--- a/xkb/xkbEvents.c
+++ b/xkb/xkbEvents.c
@@ -39,7 +39,6 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include "exglobals.h"
 #include "windowstr.h"
 #include <xkbsrv.h>
-#include "xkb.h"
 
 /***====================================================================***/
 
diff --git a/xkb/xkbInit.c b/xkb/xkbInit.c
index 4108e1b26..de1dd3fe3 100644
--- a/xkb/xkbInit.c
+++ b/xkb/xkbInit.c
@@ -49,7 +49,6 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include "xkbgeom.h"
 #include <X11/extensions/XKMformat.h>
 #include "xkbfile.h"
-#include "xkb.h"
 
 #define	CREATE_ATOM(s)	MakeAtom(s,sizeof(s)-1,1)
 
diff --git a/xkb/xkbLEDs.c b/xkb/xkbLEDs.c
index 5792d9fb7..d4690dad9 100644
--- a/xkb/xkbLEDs.c
+++ b/xkb/xkbLEDs.c
@@ -38,7 +38,6 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 #include <X11/extensions/XI.h>
 #include <xkbsrv.h>
-#include "xkb.h"
 
 /***====================================================================***/
 
diff --git a/xkb/xkbSwap.c b/xkb/xkbSwap.c
index 50cabb90e..efbdb81c1 100644
--- a/xkb/xkbSwap.c
+++ b/xkb/xkbSwap.c
@@ -36,7 +36,7 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include <xkbsrv.h>
 #include "xkbstr.h"
 #include "extnsionst.h"
-#include "xkb.h"
+#include "xkb-procs.h"
 
         /*
          * REQUEST SWAPPING
diff --git a/xkb/xkbUtils.c b/xkb/xkbUtils.c
index 9bc51fc71..3f5791a18 100644
--- a/xkb/xkbUtils.c
+++ b/xkb/xkbUtils.c
@@ -67,7 +67,6 @@ DEALINGS IN THE SOFTWARE.
 #define	XKBSRV_NEED_FILE_FUNCS
 #include <xkbsrv.h>
 #include "xkbgeom.h"
-#include "xkb.h"
 
 /***====================================================================***/
 
diff --git a/xkb/xkbfmisc.c b/xkb/xkbfmisc.c
index 2ecdcd555..fc9197f2d 100644
--- a/xkb/xkbfmisc.c
+++ b/xkb/xkbfmisc.c
@@ -46,7 +46,6 @@
 #define XKBSRV_NEED_FILE_FUNCS	1
 #include <xkbsrv.h>
 #include "xkbgeom.h"
-#include "xkb.h"
 
 unsigned
 _XkbKSCheckCase(KeySym ks)
diff --git a/xkb/xkbtext.c b/xkb/xkbtext.c
index 00a26c576..fb17f513e 100644
--- a/xkb/xkbtext.c
+++ b/xkb/xkbtext.c
@@ -967,8 +967,7 @@ CopySetLockControlsArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
         int nOut = 0;
 
         if (tmp & XkbRepeatKeysMask) {
-            snprintf(tbuf, sizeof(tbuf), "%sRepeatKeys", (nOut > 0 ? "+" : ""));
-            TryCopyStr(buf, tbuf, sz);
+            TryCopyStr(buf, "RepeatKeys", sz);
             nOut++;
         }
         if (tmp & XkbSlowKeysMask) {
